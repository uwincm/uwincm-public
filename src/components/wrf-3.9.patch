diff -Naur WRFV3.9/dyn_em/module_first_rk_step_part1.F WRFV3.9.patch/dyn_em/module_first_rk_step_part1.F
--- WRFV3.9/dyn_em/module_first_rk_step_part1.F	2017-04-07 18:20:07.000000000 -0400
+++ WRFV3.9.patch/dyn_em/module_first_rk_step_part1.F	2017-07-03 16:17:29.564226000 -0400
@@ -5,6 +5,10 @@
 
 MODULE module_first_rk_step_part1
 
+LOGICAL :: UMCM_sstFromOcean             = .FALSE. ! uwin
+LOGICAL :: UMCM_windStressFromWaves      = .FALSE. ! uwin
+LOGICAL :: UMCM_currentDependentHeatFlux = .FALSE. ! uwin
+
 CONTAINS
 
   SUBROUTINE first_rk_step_part1 (   grid , config_flags              &
@@ -113,6 +117,11 @@
     LOGICAL, INTENT(IN), OPTIONAL                 ::  f_flux
 
 ! Local
+
+    REAL,DIMENSION(ims:ime,jms:jme) :: psim10  ! uwin
+    REAL,DIMENSION(ims:ime,jms:jme) :: wspdfac ! uwin
+    INTEGER :: i,j                             ! uwin
+
     real :: HYDRO_dt
     REAL, DIMENSION( ims:ime, jms:jme ) :: exch_temf  ! 1/7/09 WA
 
@@ -392,6 +401,30 @@
 
 BENCH_END(rad_driver_tim)
 
+!********* UWIN coupling layer; uwin start
+      IF(UMCM_windStressFromWaves)THEN
+
+        ! Compute friction velocity over sea points 
+        ! using stress fields from the wave model
+        WHERE(grid % xland > 1.5)
+
+          grid % ust = SQRT(SQRT(grid % taux_esmf**2+grid % tauy_esmf**2)&
+                            *grid % alt(:,1,:))
+
+          ! If there is a mask mismatch between atmosphere and wave model,
+          ! revert to default u* based on uncoupled WRF
+          WHERE(grid % ust == 0)
+            grid % ust = SQRT(grid % cd*(grid % u10**2+grid % v10**2))
+          ENDWHERE
+
+          ! Limit if too low
+          WHERE(grid % ust < 1E-2)grid % ust = 1E-2
+
+        ENDWHERE
+
+      ENDIF
+!******************************* uwin end  
+
 !********* Surface driver
 ! surface
 
@@ -460,7 +493,7 @@
      &        ,PSFC=grid%psfc          ,PSHLTR=grid%pshltr      ,PSIH=psih          &
      &        ,BLDT=grid%bldt     ,CURR_SECS=curr_secs, ADAPT_STEP_FLAG=adapt_step_flag  &
      &        ,BLDTACTTIME=grid%bldtacttime                                              & 
-     &        ,PSIM=psim          ,P_PHY=grid%p_hyd        ,Q10=grid%q10            &
+     &        ,PSIM=psim,PSIM10=psim10,P_PHY=grid%p_hyd,Q10=grid%q10 & ! uwin added PSIM10
      &        ,Q2=grid%q2              ,QFX=grid%qfx            ,QSFC=grid%qsfc          &
      &        ,QSHLTR=grid%qshltr      ,QZ0=grid%qz0            ,RAINCV=grid%raincv      &
      &        ,RA_LW_PHYSICS=config_flags%ra_lw_physics         ,RHO=grid%rho            &
@@ -830,6 +863,32 @@
      &     grid%j_start(1),min(grid%j_end(1), jde-1) )
 #endif
 
+!******** uwin start
+! Stability function Psim(10/L) for UWIN coupling
+grid % psim_esmf = 0
+grid % psim_esmf(ims:ime,jms:jme) = psim10(ims:ime,jms:jme)
+
+IF(UMCM_currentDependentHeatFlux)THEN
+
+  ! Compute wind speed relative to water surface
+  grid % wspdrel = SQRT((grid % u10-grid % ue_esmf-grid % ust_esmf)**2&
+                       +(grid % v10-grid % ve_esmf-grid % vst_esmf)**2)
+
+  wspdfac = 0
+  wspdfac(ims:ime,jms:jme) = grid % wspdrel(ims:ime,jms:jme)     &
+                           / SQRT(grid % u10(ims:ime,jms:jme)**2 &
+                                 +grid % v10(ims:ime,jms:jme)**2)
+
+  FORALL(i=ims:ime,j=jms:jme,grid % xland(i,j) > 1.5)
+    grid % hfx(i,j) = grid % hfx(i,j)*wspdfac(i,j)
+    grid % qfx(i,j) = grid % qfx(i,j)*wspdfac(i,j)
+    grid % lh(i,j)  = grid % lh(i,j)*wspdfac(i,j)
+  ENDFORALL
+
+ENDIF
+!******** uwin end
+
+
 BENCH_END(surf_driver_tim)
 
 !*********
@@ -858,6 +917,7 @@
      &        ,RA_LW_PHYSICS=config_flags%ra_lw_physics                   &
      &        ,RHO=grid%rho            ,RQCBLTEN=grid%rqcblten  ,RQIBLTEN=grid%rqiblten  &
      &        ,RQVBLTEN=grid%rqvblten  ,RTHBLTEN=grid%rthblten  ,RUBLTEN=grid%rublten    &
+     &        ,TAUX_ESMF=grid%taux_esmf,TAUY_ESMF=grid%tauy_esmf  & ! uwin
      &        ,RVBLTEN=grid%rvblten    ,SNOW=grid%snow          ,STEPBL=grid%stepbl      &
      &        ,THZ0=grid%thz0          ,TH_PHY=th_phy                               &
      &        ,TSK=grid%tsk            ,T_PHY=grid%t_phy        ,UST=grid%ust       &
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_AlarmClock.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_AlarmClock.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_AlarmClock.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_AlarmClock.F90	2017-07-03 16:17:29.679817000 -0400
@@ -9,8 +9,8 @@
 !
 !==============================================================================
 !
-!     ESMF Alarm-Clock Module
-      module ESMF_AlarmClockMod
+!     timelib Alarm-Clock Module
+      module timelib_AlarmClockMod
 !
 !==============================================================================
 !
@@ -18,31 +18,31 @@
 !
 !------------------------------------------------------------------------------
 ! INCLUDES
-#include <ESMF_TimeMgr.inc>
+#include <timelib_TimeMgr.inc>
 
 !===============================================================================
 !BOPI
 !
-! !MODULE: ESMF_AlarmClockMod
+! !MODULE: timelib_AlarmClockMod
 !
 ! !DESCRIPTION:
-! Separate module that uses both ESMF_AlarmMod and ESMF_ClockMod.  
+! Separate module that uses both timelib_AlarmMod and timelib_ClockMod.  
 ! Separation is needed to avoid cyclic dependence.  
 !
 ! Defines F90 wrapper entry points for corresponding
-! C++ class {\tt ESMC\_Alarm}
+! C++ class {\tt timelibc\_Alarm}
 !
-! See {\tt ../include/ESMC\_Alarm.h} for complete description
+! See {\tt ../include/timelibc\_Alarm.h} for complete description
 !
 !------------------------------------------------------------------------------
 ! !USES:
-      ! inherit ESMF_Alarm and ESMF_Clock
-      use ESMF_AlarmMod, only : ESMF_Alarm, ESMF_AlarmSet
-      use ESMF_ClockMod, only : ESMF_Clock, ESMF_ClockAddAlarm
+      ! inherit timelib_Alarm and timelib_Clock
+      use timelib_AlarmMod, only : timelib_Alarm, timelib_AlarmSet
+      use timelib_ClockMod, only : timelib_Clock, timelib_ClockAddAlarm
 
       ! associated derived types
-      use ESMF_TimeIntervalMod, only : ESMF_TimeInterval
-      use ESMF_TimeMod,         only : ESMF_Time
+      use timelib_TimeIntervalMod, only : timelib_TimeInterval
+      use timelib_TimeMod,         only : timelib_Time
 
       implicit none
 
@@ -52,7 +52,7 @@
 !------------------------------------------------------------------------------
 
 ! !PUBLIC MEMBER FUNCTIONS:
-      public ESMF_AlarmCreate
+      public timelib_AlarmCreate
 
 !==============================================================================
 
@@ -61,36 +61,36 @@
 !==============================================================================
 
 
-! Create ESMF_Alarm using ESMF 2.1.0+ semantics
-      FUNCTION ESMF_AlarmCreate( clock, RingTime, RingInterval, &
+! Create timelib_Alarm using timelib 2.1.0+ semantics
+      FUNCTION timelib_AlarmCreate( clock, RingTime, RingInterval, &
                                  StopTime, Enabled, rc )
 
         ! return value
-        type(ESMF_Alarm) :: ESMF_AlarmCreate
+        type(timelib_Alarm) :: timelib_AlarmCreate
         ! !ARGUMENTS:
-        type(ESMF_Clock), intent(inout), optional :: clock
-        type(ESMF_Time), intent(in), optional :: RingTime
-        type(ESMF_TimeInterval), intent(in), optional :: RingInterval
-        type(ESMF_Time), intent(in), optional :: StopTime
+        type(timelib_Clock), intent(inout), optional :: clock
+        type(timelib_Time), intent(in), optional :: RingTime
+        type(timelib_TimeInterval), intent(in), optional :: RingInterval
+        type(timelib_Time), intent(in), optional :: StopTime
         logical, intent(in), optional :: Enabled
         integer, intent(out), optional :: rc
         ! locals
-        type(ESMF_Alarm) :: alarmtmp
+        type(timelib_Alarm) :: alarmtmp
          ! TBH:  ignore allocate errors, for now
         ALLOCATE( alarmtmp%alarmint )
-        CALL ESMF_AlarmSet( alarmtmp,                  &
+        CALL timelib_AlarmSet( alarmtmp,                  &
                             RingTime=RingTime,         &
                             RingInterval=RingInterval, &
                             StopTime=StopTime,         &
                             Enabled=Enabled,           &
                             rc=rc )
         IF ( PRESENT ( clock ) ) THEN
-          CALL ESMF_ClockAddAlarm( clock, alarmtmp, rc )
+          CALL timelib_ClockAddAlarm( clock, alarmtmp, rc )
         ENDIF
-        ESMF_AlarmCreate = alarmtmp
-      END FUNCTION ESMF_AlarmCreate
+        timelib_AlarmCreate = alarmtmp
+      END FUNCTION timelib_AlarmCreate
 
 
 !------------------------------------------------------------------------------
 
-      end module ESMF_AlarmClockMod
+      end module timelib_AlarmClockMod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Alarm.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_Alarm.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_Alarm.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Alarm.F90	2017-07-03 16:17:29.679421000 -0400
@@ -9,8 +9,8 @@
 !
 !==============================================================================
 !
-!     ESMF Alarm Module
-      module ESMF_AlarmMod
+!     timelib Alarm Module
+      module timelib_AlarmMod
 !
 !==============================================================================
 !
@@ -19,30 +19,30 @@
 !
 !------------------------------------------------------------------------------
 ! INCLUDES
-#include <ESMF_TimeMgr.inc>
+#include <timelib_TimeMgr.inc>
 
 !===============================================================================
 !BOPI
 !
-! !MODULE: ESMF_AlarmMod
+! !MODULE: timelib_AlarmMod
 !
 ! !DESCRIPTION:
 ! Part of Time Manager F90 API wrapper of C++ implemenation
 !
 ! Defines F90 wrapper entry points for corresponding
-! C++ class {\tt ESMC\_Alarm}
+! C++ class {\tt timelibc\_Alarm}
 !
-! See {\tt ../include/ESMC\_Alarm.h} for complete description
+! See {\tt ../include/timelibc\_Alarm.h} for complete description
 !
 !------------------------------------------------------------------------------
 ! !USES:
-      ! inherit from ESMF base class
-      use ESMF_BaseMod
+      ! inherit from timelib base class
+      use timelib_BaseMod
 
       ! associated derived types
-      use ESMF_TimeIntervalMod, only : ESMF_TimeInterval, &
-                                       ESMF_TimeIntervalAbsValue
-      use ESMF_TimeMod,         only : ESMF_Time
+      use timelib_TimeIntervalMod, only : timelib_TimeInterval, &
+                                       timelib_TimeIntervalAbsValue
+      use timelib_TimeMod,         only : timelib_Time
 
       implicit none
 
@@ -50,17 +50,17 @@
 ! !PRIVATE TYPES:
      private
 !------------------------------------------------------------------------------
-!     ! ESMF_Alarm
+!     ! timelib_Alarm
 !
 !     ! F90 class type to match C++ Alarm class in size only;
 !     !  all dereferencing within class is performed by C++ implementation
 
-! internals for ESMF_Alarm
-      type ESMF_AlarmInt
-        type(ESMF_TimeInterval) :: RingInterval
-        type(ESMF_Time)  :: RingTime
-        type(ESMF_Time)  :: PrevRingTime
-        type(ESMF_Time)  :: StopTime
+! internals for timelib_Alarm
+      type timelib_AlarmInt
+        type(timelib_TimeInterval) :: RingInterval
+        type(timelib_Time)  :: RingTime
+        type(timelib_Time)  :: PrevRingTime
+        type(timelib_Time)  :: StopTime
         integer :: ID
         integer :: AlarmMutex
         logical :: Ringing
@@ -70,50 +70,50 @@
         logical :: StopTimeSet
       end type
 
-! Actual public type:  this bit allows easy mimic of "deep" ESMF_AlarmCreate
-! in ESMF 2.1.0+.  Note that ESMF_AlarmCreate is in a separate module to avoid 
+! Actual public type:  this bit allows easy mimic of "deep" timelib_AlarmCreate
+! in timelib 2.1.0+.  Note that timelib_AlarmCreate is in a separate module to avoid 
 ! cyclic dependence.  
-! NOTE:  DO NOT ADD NON-POINTER STATE TO THIS DATA TYPE.  It emulates ESMF 
+! NOTE:  DO NOT ADD NON-POINTER STATE TO THIS DATA TYPE.  It emulates timelib 
 !        shallow-copy-masquerading-as-reference-copy insanity.  
-      type ESMF_Alarm
-        type(ESMF_AlarmInt), pointer :: alarmint
+      type timelib_Alarm
+        type(timelib_AlarmInt), pointer :: alarmint
       end type
 
 !------------------------------------------------------------------------------
 ! !PUBLIC TYPES:
-      public ESMF_Alarm
-      public ESMF_AlarmInt   ! needed on AIX but not PGI
+      public timelib_Alarm
+      public timelib_AlarmInt   ! needed on AIX but not PGI
 !------------------------------------------------------------------------------
 
 ! !PUBLIC MEMBER FUNCTIONS:
-      public ESMF_AlarmDestroy
-      public ESMF_AlarmSet
-      public ESMF_AlarmGet
-!      public ESMF_AlarmGetRingInterval
-!      public ESMF_AlarmSetRingInterval
-!      public ESMF_AlarmGetRingTime
-!      public ESMF_AlarmSetRingTime
-!      public ESMF_AlarmGetPrevRingTime
-!      public ESMF_AlarmSetPrevRingTime
-!      public ESMF_AlarmGetStopTime
-!      public ESMF_AlarmSetStopTime
-      public ESMF_AlarmEnable
-      public ESMF_AlarmDisable
-      public ESMF_AlarmRingerOn
-      public ESMF_AlarmRingerOff
-      public ESMF_AlarmIsRinging
-!      public ESMF_AlarmCheckRingTime
+      public timelib_AlarmDestroy
+      public timelib_AlarmSet
+      public timelib_AlarmGet
+!      public timelib_AlarmGetRingInterval
+!      public timelib_AlarmSetRingInterval
+!      public timelib_AlarmGetRingTime
+!      public timelib_AlarmSetRingTime
+!      public timelib_AlarmGetPrevRingTime
+!      public timelib_AlarmSetPrevRingTime
+!      public timelib_AlarmGetStopTime
+!      public timelib_AlarmSetStopTime
+      public timelib_AlarmEnable
+      public timelib_AlarmDisable
+      public timelib_AlarmRingerOn
+      public timelib_AlarmRingerOff
+      public timelib_AlarmIsRinging
+!      public timelib_AlarmCheckRingTime
       public operator(==)
  
-! Required inherited and overridden ESMF_Base class methods
+! Required inherited and overridden timelib_Base class methods
 
-!      public ESMF_AlarmRead
-!      public ESMF_AlarmWrite
-      public ESMF_AlarmValidate
-      public ESMF_AlarmPrint
+!      public timelib_AlarmRead
+!      public timelib_AlarmWrite
+      public timelib_AlarmValidate
+      public timelib_AlarmPrint
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      private ESMF_AlarmEQ
+      private timelib_AlarmEQ
 !EOPI
 
 !==============================================================================
@@ -126,10 +126,10 @@
       interface operator(==)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_AlarmEQ
+      module procedure timelib_AlarmEQ
 
 ! !DESCRIPTION:
-!     This interface overloads the == operator for the {\tt ESMF\_Alarm} class
+!     This interface overloads the == operator for the {\tt timelib\_Alarm} class
 !
 !EOP
       end interface
@@ -148,22 +148,22 @@
 !
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_AlarmSet - Initializes an alarm
+! !IROUTINE: timelib_AlarmSet - Initializes an alarm
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmSet(alarm, RingTime, RingInterval, PrevRingTime, &
+      subroutine timelib_AlarmSet(alarm, RingTime, RingInterval, PrevRingTime, &
                                StopTime, Enabled, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
-      type(ESMF_Time), intent(in), optional :: RingTime, PrevRingTime
-      type(ESMF_TimeInterval), intent(in), optional :: RingInterval
-      type(ESMF_Time), intent(in), optional :: StopTime
+      type(timelib_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
+      type(timelib_Time), intent(in), optional :: RingTime, PrevRingTime
+      type(timelib_TimeInterval), intent(in), optional :: RingInterval
+      type(timelib_Time), intent(in), optional :: StopTime
       logical, intent(in), optional :: Enabled
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Initializes an {\tt ESMF\_Alarm}
+!     Initializes an {\tt timelib\_Alarm}
 !
 !     The arguments are:
 !     \begin{description}
@@ -178,7 +178,7 @@
 !     \item[Enabled]
 !          Alarm enabled/disabled
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -191,7 +191,7 @@
         IF ( PRESENT( RingInterval ) ) THEN
           ! force RingInterval to be positive
           alarm%alarmint%RingInterval = &
-            ESMF_TimeIntervalAbsValue( RingInterval )
+            timelib_TimeIntervalAbsValue( RingInterval )
           alarm%alarmint%RingIntervalSet = .TRUE.
         ENDIF
         IF ( PRESENT( PrevRingTime ) ) THEN
@@ -210,45 +210,45 @@
           alarm%alarmint%Enabled = Enabled
         ENDIF
         IF ( PRESENT( rc ) ) THEN
-          rc = ESMF_SUCCESS
+          rc = timelib_SUCCESS
         ENDIF
         alarm%alarmint%Ringing = .FALSE.
         alarm%alarmint%Enabled = .TRUE.
       ELSE
-        IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+        IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       ENDIF
 
-      end subroutine ESMF_AlarmSet
+      end subroutine timelib_AlarmSet
 
 
 
-! Deallocate memory for ESMF_Alarm
-      SUBROUTINE ESMF_AlarmDestroy( alarm, rc )
-         TYPE(ESMF_Alarm), INTENT(INOUT) :: alarm
+! Deallocate memory for timelib_Alarm
+      SUBROUTINE timelib_AlarmDestroy( alarm, rc )
+         TYPE(timelib_Alarm), INTENT(INOUT) :: alarm
          INTEGER,          INTENT(  OUT), OPTIONAL :: rc
          IF ( ASSOCIATED( alarm%alarmint ) ) THEN
            DEALLOCATE( alarm%alarmint )
          ENDIF
          ! TBH:  ignore deallocate errors, for now
-         IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
-      END SUBROUTINE ESMF_AlarmDestroy
+         IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
+      END SUBROUTINE timelib_AlarmDestroy
 
 
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_AlarmGetRingInterval - Get an alarm's ring interval
+! !IROUTINE: timelib_AlarmGetRingInterval - Get an alarm's ring interval
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmGetRingInterval(alarm, RingInterval, rc)
+      subroutine timelib_AlarmGetRingInterval(alarm, RingInterval, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
-      type(ESMF_TimeInterval), intent(out) :: RingInterval
+      type(timelib_Alarm), intent(in) :: alarm
+      type(timelib_TimeInterval), intent(out) :: RingInterval
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Alarm}'s ring interval
+!     Get an {\tt timelib\_Alarm}'s ring interval
 !
 !     The arguments are:
 !     \begin{description}
@@ -257,7 +257,7 @@
 !     \item[RingInterval]
 !          The {\tt Alarm}'s ring interval
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
@@ -265,22 +265,22 @@
 !EOP
       RingInterval = alarm%alarmint%RingInterval
 
-      end subroutine ESMF_AlarmGetRingInterval
+      end subroutine timelib_AlarmGetRingInterval
  
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_AlarmSetRingInterval - Set an alarm's ring interval
+! !IROUTINE: timelib_AlarmSetRingInterval - Set an alarm's ring interval
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmSetRingInterval(alarm, RingInterval, rc)
+      subroutine timelib_AlarmSetRingInterval(alarm, RingInterval, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(out) :: alarm
-      type(ESMF_TimeInterval), intent(in) :: RingInterval
+      type(timelib_Alarm), intent(out) :: alarm
+      type(timelib_TimeInterval), intent(in) :: RingInterval
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Set an {\tt ESMF\_Alarm}'s ring interval
+!     Set an {\tt timelib\_Alarm}'s ring interval
 !
 !     The arguments are:
 !     \begin{description}
@@ -289,146 +289,146 @@
 !     \item[RingInterval]
 !          The {\tt Alarm}'s ring interval
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG4.5.2, TMG4.7
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmSetRingInterval not supported' )
-      end subroutine ESMF_AlarmSetRingInterval
+      CALL wrf_error_fatal( 'timelib_AlarmSetRingInterval not supported' )
+      end subroutine timelib_AlarmSetRingInterval
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmGetRingTime - Get an alarm's time to ring
+! !IROUTINE:  timelib_AlarmGetRingTime - Get an alarm's time to ring
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmGetRingTime(alarm, RingTime, rc)
+      subroutine timelib_AlarmGetRingTime(alarm, RingTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
-      type(ESMF_Time), intent(out) :: RingTime
+      type(timelib_Alarm), intent(in) :: alarm
+      type(timelib_Time), intent(out) :: RingTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Alarm}'s time to ring
+!     Get an {\tt timelib\_Alarm}'s time to ring
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to get the ring time
 !     \item[RingTime]
-!          The {\tt ESMF\_Alarm}'s ring time
+!          The {\tt timelib\_Alarm}'s ring time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG4.7, TMG4.8
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmGetRingTime not supported' )
-      end subroutine ESMF_AlarmGetRingTime
+      CALL wrf_error_fatal( 'timelib_AlarmGetRingTime not supported' )
+      end subroutine timelib_AlarmGetRingTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmSetRingTime - Set an alarm's time to ring
+! !IROUTINE:  timelib_AlarmSetRingTime - Set an alarm's time to ring
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmSetRingTime(alarm, RingTime, rc)
+      subroutine timelib_AlarmSetRingTime(alarm, RingTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(out) :: alarm
-      type(ESMF_Time), intent(in) :: RingTime
+      type(timelib_Alarm), intent(out) :: alarm
+      type(timelib_Time), intent(in) :: RingTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Set an {\tt ESMF\_Alarm}'s time to ring
+!     Set an {\tt timelib\_Alarm}'s time to ring
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to set the ring time
 !     \item[RingTime]
-!          The {\tt ESMF\_Alarm}'s ring time to set
+!          The {\tt timelib\_Alarm}'s ring time to set
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG4.5.1, TMG4.7, TMG4.8
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmSetRingTime not supported' )
-      end subroutine ESMF_AlarmSetRingTime
+      CALL wrf_error_fatal( 'timelib_AlarmSetRingTime not supported' )
+      end subroutine timelib_AlarmSetRingTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmGet - Get an alarm's parameters -- compatibility with ESMF 2.0.1
+! !IROUTINE:  timelib_AlarmGet - Get an alarm's parameters -- compatibility with timelib 2.0.1
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmGet(alarm, PrevRingTime, RingInterval, rc)
+      subroutine timelib_AlarmGet(alarm, PrevRingTime, RingInterval, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
-      type(ESMF_Time), intent(out), optional :: PrevRingTime
-      type(ESMF_TimeInterval), intent(out), optional :: RingInterval
+      type(timelib_Alarm), intent(in) :: alarm
+      type(timelib_Time), intent(out), optional :: PrevRingTime
+      type(timelib_TimeInterval), intent(out), optional :: RingInterval
       integer, intent(out), optional :: rc
       integer :: ierr
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Alarm}'s previous ring time
+!     Get an {\tt timelib\_Alarm}'s previous ring time
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to get the previous ring time
 !     \item[PrevRingTime]
-!          The {\tt ESMF\_Alarm}'s previous ring time
+!          The {\tt timelib\_Alarm}'s previous ring time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG4.7, TMG4.8
 !EOP
 
-      ierr = ESMF_SUCCESS
+      ierr = timelib_SUCCESS
 
       IF ( PRESENT(PrevRingTime) ) THEN
-        CALL ESMF_AlarmGetPrevRingTime(alarm, PrevRingTime, rc=ierr)
+        CALL timelib_AlarmGetPrevRingTime(alarm, PrevRingTime, rc=ierr)
       ENDIF
       IF ( PRESENT(RingInterval) ) THEN
-        CALL ESMF_AlarmGetRingInterval(alarm, RingInterval, rc=ierr)
+        CALL timelib_AlarmGetRingInterval(alarm, RingInterval, rc=ierr)
       ENDIF
 
       IF ( PRESENT(rc) ) THEN
         rc = ierr
       ENDIF
 
-      end subroutine ESMF_AlarmGet
+      end subroutine timelib_AlarmGet
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmGetPrevRingTime - Get an alarm's previous ring time
+! !IROUTINE:  timelib_AlarmGetPrevRingTime - Get an alarm's previous ring time
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmGetPrevRingTime(alarm, PrevRingTime, rc)
+      subroutine timelib_AlarmGetPrevRingTime(alarm, PrevRingTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
-      type(ESMF_Time), intent(out) :: PrevRingTime
+      type(timelib_Alarm), intent(in) :: alarm
+      type(timelib_Time), intent(out) :: PrevRingTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Alarm}'s previous ring time
+!     Get an {\tt timelib\_Alarm}'s previous ring time
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to get the previous ring time
 !     \item[PrevRingTime]
-!          The {\tt ESMF\_Alarm}'s previous ring time
+!          The {\tt timelib\_Alarm}'s previous ring time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -436,125 +436,125 @@
 !EOP
       IF ( ASSOCIATED( alarm%alarmint ) ) THEN
         PrevRingTime = alarm%alarmint%PrevRingTime
-        IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+        IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
       ELSE
-        IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+        IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       ENDIF
-      end subroutine ESMF_AlarmGetPrevRingTime
+      end subroutine timelib_AlarmGetPrevRingTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmSetPrevRingTime - Set an alarm's previous ring time
+! !IROUTINE:  timelib_AlarmSetPrevRingTime - Set an alarm's previous ring time
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmSetPrevRingTime(alarm, PrevRingTime, rc)
+      subroutine timelib_AlarmSetPrevRingTime(alarm, PrevRingTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(out) :: alarm
-      type(ESMF_Time), intent(in) :: PrevRingTime
+      type(timelib_Alarm), intent(out) :: alarm
+      type(timelib_Time), intent(in) :: PrevRingTime
       integer, intent(out), optional :: rc
    
 ! !DESCRIPTION:
-!     Set an {\tt ESMF\_Alarm}'s previous ring time
+!     Set an {\tt timelib\_Alarm}'s previous ring time
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to set the previous ring time
 !     \item[PrevRingTime]
-!          The {\tt ESMF\_Alarm}'s previous ring time to set
+!          The {\tt timelib\_Alarm}'s previous ring time to set
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG4.7, TMG4.8
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmSetPrevRingTime not supported' )
-      end subroutine ESMF_AlarmSetPrevRingTime
+      CALL wrf_error_fatal( 'timelib_AlarmSetPrevRingTime not supported' )
+      end subroutine timelib_AlarmSetPrevRingTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmGetStopTime - Get an alarm's stop time
+! !IROUTINE:  timelib_AlarmGetStopTime - Get an alarm's stop time
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmGetStopTime(alarm, StopTime, rc)
+      subroutine timelib_AlarmGetStopTime(alarm, StopTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
-      type(ESMF_Time), intent(out) :: StopTime
+      type(timelib_Alarm), intent(in) :: alarm
+      type(timelib_Time), intent(out) :: StopTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Alarm}'s stop time
+!     Get an {\tt timelib\_Alarm}'s stop time
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to get the stop time
 !     \item[StopTime]
-!          The {\tt ESMF\_Alarm}'s stop time
+!          The {\tt timelib\_Alarm}'s stop time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG4.5.2, TMG4.7
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmGetStopTime not supported' )
-      end subroutine ESMF_AlarmGetStopTime
+      CALL wrf_error_fatal( 'timelib_AlarmGetStopTime not supported' )
+      end subroutine timelib_AlarmGetStopTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmSetStopTime - Set an alarm's stop time
+! !IROUTINE:  timelib_AlarmSetStopTime - Set an alarm's stop time
 !
 ! !INTERFACE:
-      subroutine ESMF_AlarmSetStopTime(alarm, StopTime, rc)
+      subroutine timelib_AlarmSetStopTime(alarm, StopTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(out) :: alarm
-      type(ESMF_Time), intent(in) :: StopTime
+      type(timelib_Alarm), intent(out) :: alarm
+      type(timelib_Time), intent(in) :: StopTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Set an {\tt ESMF\_Alarm}'s stop time
+!     Set an {\tt timelib\_Alarm}'s stop time
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to set the stop time
 !     \item[StopTime]
-!          The {\tt ESMF\_Alarm}'s stop time
+!          The {\tt timelib\_Alarm}'s stop time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG4.5.2, TMG4.7
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmSetStopTime not supported' )
-      end subroutine ESMF_AlarmSetStopTime
+      CALL wrf_error_fatal( 'timelib_AlarmSetStopTime not supported' )
+      end subroutine timelib_AlarmSetStopTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_AlarmEnable - Enables an alarm
+! !IROUTINE: timelib_AlarmEnable - Enables an alarm
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmEnable(alarm, rc)
+      subroutine timelib_AlarmEnable(alarm, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
+      type(timelib_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Enables an {\tt ESMF\_Alarm} to function
+!     Enables an {\tt timelib\_Alarm} to function
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to enable
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
@@ -562,32 +562,32 @@
 !EOP
       IF ( ASSOCIATED( alarm%alarmint ) ) THEN
         alarm%alarmint%Enabled = .TRUE.
-        IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+        IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
       ELSE
-        IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+        IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       ENDIF
-      end subroutine ESMF_AlarmEnable
+      end subroutine timelib_AlarmEnable
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_AlarmDisable - Disables an alarm
+! !IROUTINE: timelib_AlarmDisable - Disables an alarm
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmDisable(alarm, rc)
+      subroutine timelib_AlarmDisable(alarm, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
+      type(timelib_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Disables an {\tt ESMF\_Alarm}
+!     Disables an {\tt timelib\_Alarm}
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to disable
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
@@ -595,33 +595,33 @@
 !EOP
       IF ( ASSOCIATED( alarm%alarmint ) ) THEN
         alarm%alarmint%Enabled = .FALSE.
-        IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+        IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
       ELSE
-        IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+        IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       ENDIF
-      end subroutine ESMF_AlarmDisable
+      end subroutine timelib_AlarmDisable
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmRingerOn - Turn on an alarm
+! !IROUTINE:  timelib_AlarmRingerOn - Turn on an alarm
 
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmRingerOn(alarm, rc)
+      subroutine timelib_AlarmRingerOn(alarm, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
+      type(timelib_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
       integer, intent(out), optional :: rc
     
 ! !DESCRIPTION:
-!     Turn on an {\tt ESMF\_Alarm}; sets ringing state
+!     Turn on an {\tt timelib\_Alarm}; sets ringing state
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to turn on
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -630,37 +630,37 @@
       IF ( ASSOCIATED( alarm%alarmint ) ) THEN
         IF ( alarm%alarmint%Enabled ) THEN
           alarm%alarmint%Ringing = .TRUE.
-          IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+          IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
         ELSE
           alarm%alarmint%Ringing = .FALSE.
-          IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+          IF ( PRESENT( rc ) ) rc = timelib_FAILURE
         ENDIF
       ELSE
-        IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+        IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       ENDIF
 
-      end subroutine ESMF_AlarmRingerOn
+      end subroutine timelib_AlarmRingerOn
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmRingerOff - Turn off an alarm
+! !IROUTINE:  timelib_AlarmRingerOff - Turn off an alarm
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmRingerOff(alarm, rc)
+      subroutine timelib_AlarmRingerOff(alarm, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
+      type(timelib_Alarm), intent(inout) :: alarm  ! really INTENT(OUT)
       integer, intent(out), optional :: rc
     
 ! !DESCRIPTION:
-!     Turn off an {\tt ESMF\_Alarm}; unsets ringing state
+!     Turn off an {\tt timelib\_Alarm}; unsets ringing state
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to turn off   
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
@@ -669,38 +669,38 @@
       IF ( ASSOCIATED( alarm%alarmint ) ) THEN
         alarm%alarmint%Ringing = .FALSE.
         IF ( alarm%alarmint%Enabled ) THEN
-          IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+          IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
         ELSE
-          IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+          IF ( PRESENT( rc ) ) rc = timelib_FAILURE
         ENDIF
       ELSE
-        IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+        IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       ENDIF
-      end subroutine ESMF_AlarmRingerOff
+      end subroutine timelib_AlarmRingerOff
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmIsRinging - Check if alarm is ringing
+! !IROUTINE:  timelib_AlarmIsRinging - Check if alarm is ringing
 
 ! !INTERFACE:
-      function ESMF_AlarmIsRinging(alarm, rc)
+      function timelib_AlarmIsRinging(alarm, rc)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_AlarmIsRinging
+      logical :: timelib_AlarmIsRinging
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
+      type(timelib_Alarm), intent(in) :: alarm
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Check if {\tt ESMF\_Alarm} is ringing.
+!     Check if {\tt timelib\_Alarm} is ringing.
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to check for ringing state  
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
@@ -708,69 +708,69 @@
 !EOP
       IF ( ASSOCIATED( alarm%alarmint ) ) THEN
         IF ( alarm%alarmint%Enabled ) THEN
-          ESMF_AlarmIsRinging = alarm%alarmint%Ringing
-          IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+          timelib_AlarmIsRinging = alarm%alarmint%Ringing
+          IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
         ELSE
-          ESMF_AlarmIsRinging = .FALSE.
-          IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+          timelib_AlarmIsRinging = .FALSE.
+          IF ( PRESENT( rc ) ) rc = timelib_FAILURE
         ENDIF
       ELSE
-        IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+        IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       ENDIF
-      end function ESMF_AlarmIsRinging
+      end function timelib_AlarmIsRinging
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_AlarmCheckRingTime - Method used by a clock to check whether to trigger an alarm
+! !IROUTINE: timelib_AlarmCheckRingTime - Method used by a clock to check whether to trigger an alarm
 !
 ! !INTERFACE:
-      function ESMF_AlarmCheckRingTime(alarm, ClockCurrTime, positive, rc)
+      function timelib_AlarmCheckRingTime(alarm, ClockCurrTime, positive, rc)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_AlarmCheckRingTime
+      logical :: timelib_AlarmCheckRingTime
 !
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(inout) :: alarm
-      type(ESMF_Time), intent(in) :: ClockCurrTime
+      type(timelib_Alarm), intent(inout) :: alarm
+      type(timelib_Time), intent(in) :: ClockCurrTime
       integer, intent(in) :: positive
       integer, intent(out), optional :: rc
 !
 ! !DESCRIPTION:
-!     Main method used by a {\tt ESMF\_Clock} to check whether to trigger
-!     the {\tt ESMF\_Alarm} 
+!     Main method used by a {\tt timelib\_Clock} to check whether to trigger
+!     the {\tt timelib\_Alarm} 
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
 !          The object instance to check if time to ring   
 !     \item[ClockCurrTime]
-!          The {\tt ESMF\_Clock}'s current time
+!          The {\tt timelib\_Clock}'s current time
 !     \item[positive]
 !          Whether to check ring time in the positive or negative direction
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
 !     TMG4.4, TMG4.6
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmCheckRingTime not supported' )
-      ESMF_AlarmCheckRingTime = .FALSE.  ! keep compilers happy
-      end function ESMF_AlarmCheckRingTime
+      CALL wrf_error_fatal( 'timelib_AlarmCheckRingTime not supported' )
+      timelib_AlarmCheckRingTime = .FALSE.  ! keep compilers happy
+      end function timelib_AlarmCheckRingTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmEQ - Compare two alarms for equality
+! !IROUTINE:  timelib_AlarmEQ - Compare two alarms for equality
 !
 ! !INTERFACE:
-      function ESMF_AlarmEQ(alarm1, alarm2)
+      function timelib_AlarmEQ(alarm1, alarm2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_AlarmEQ
+      logical :: timelib_AlarmEQ
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm1
-      type(ESMF_Alarm), intent(in) :: alarm2
+      type(timelib_Alarm), intent(in) :: alarm1
+      type(timelib_Alarm), intent(in) :: alarm2
 
 ! !DESCRIPTION:
 !     Compare two alarms for equality; return true if equal, false otherwise
@@ -779,44 +779,44 @@
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm1]
-!          The first {\tt ESMF\_Alarm} to compare
+!          The first {\tt timelib\_Alarm} to compare
 !     \item[alarm2]
-!          The second {\tt ESMF\_Alarm} to compare
+!          The second {\tt timelib\_Alarm} to compare
 !     \end{description}
 !
 ! !REQUIREMENTS:  
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmEQ not supported ' )
-      ESMF_AlarmEQ = .FALSE.       ! keep compilers happy
-      end function ESMF_AlarmEQ
+      CALL wrf_error_fatal( 'timelib_AlarmEQ not supported ' )
+      timelib_AlarmEQ = .FALSE.       ! keep compilers happy
+      end function timelib_AlarmEQ
 
 !------------------------------------------------------------------------------
 !
 ! This section defines the overridden Read, Write, Validate and Print methods
-! from the ESMF_Base class
+! from the timelib_Base class
 !
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_AlarmRead - restores an alarm
+! !IROUTINE: timelib_AlarmRead - restores an alarm
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmRead(alarm, RingInterval, RingTime, &
+      subroutine timelib_AlarmRead(alarm, RingInterval, RingTime, &
                            PrevRingTime, StopTime, Ringing, &
                            Enabled, ID, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(out) :: alarm
-      type(ESMF_TimeInterval), intent(in) :: RingInterval
-      type(ESMF_Time), intent(in) :: RingTime
-      type(ESMF_Time), intent(in) :: PrevRingTime
-      type(ESMF_Time), intent(in) :: StopTime
+      type(timelib_Alarm), intent(out) :: alarm
+      type(timelib_TimeInterval), intent(in) :: RingInterval
+      type(timelib_Time), intent(in) :: RingTime
+      type(timelib_Time), intent(in) :: PrevRingTime
+      type(timelib_Time), intent(in) :: StopTime
       logical, intent(in) :: Ringing
       logical, intent(in) :: Enabled
       integer, intent(in) :: ID
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Restores an {\tt ESMF\_Alarm}
+!     Restores an {\tt timelib\_Alarm}
 !
 !     The arguments are:
 !     \begin{description}
@@ -827,46 +827,46 @@
 !     \item[RingTime]
 !          Ring time for one-shot or first repeating alarm
 !     \item[PrevRingTime]
-!          The {\tt ESMF\_Alarm}'s previous ring time
+!          The {\tt timelib\_Alarm}'s previous ring time
 !     \item[StopTime]
 !          Stop time for repeating alarms
 !     \item[Ringing]
-!          The {\tt ESMF\_Alarm}'s ringing state
+!          The {\tt timelib\_Alarm}'s ringing state
 !     \item[Enabled]
-!          {\tt ESMF\_Alarm} enabled/disabled
+!          {\tt timelib\_Alarm} enabled/disabled
 !     \item[ID]
-!          The {\tt ESMF\_Alarm}'s ID
+!          The {\tt timelib\_Alarm}'s ID
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmRead not supported' )
-      end subroutine ESMF_AlarmRead
+      CALL wrf_error_fatal( 'timelib_AlarmRead not supported' )
+      end subroutine timelib_AlarmRead
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_AlarmWrite - saves an alarm
+! !IROUTINE: timelib_AlarmWrite - saves an alarm
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmWrite(alarm, RingInterval, RingTime, &
+      subroutine timelib_AlarmWrite(alarm, RingInterval, RingTime, &
                             PrevRingTime, StopTime, Ringing, &
                             Enabled, ID, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
-      type(ESMF_TimeInterval), intent(out) :: RingInterval
-      type(ESMF_Time), intent(out) :: RingTime
-      type(ESMF_Time), intent(out) :: PrevRingTime
-      type(ESMF_Time), intent(out) :: StopTime
+      type(timelib_Alarm), intent(in) :: alarm
+      type(timelib_TimeInterval), intent(out) :: RingInterval
+      type(timelib_Time), intent(out) :: RingTime
+      type(timelib_Time), intent(out) :: PrevRingTime
+      type(timelib_Time), intent(out) :: StopTime
       logical, intent(out) :: Ringing
       logical, intent(out) :: Enabled
       integer, intent(out) :: ID
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Saves an {\tt ESMF\_Alarm}
+!     Saves an {\tt timelib\_Alarm}
 !
 !     The arguments are:
 !     \begin{description}
@@ -877,87 +877,87 @@
 !     \item[RingTime]
 !          Ring time for one-shot or first repeating alarm
 !     \item[PrevRingTime]
-!          The {\tt ESMF\_Alarm}'s previous ring time
+!          The {\tt timelib\_Alarm}'s previous ring time
 !     \item[StopTime]
 !          Stop time for repeating alarms
 !     \item[Ringing]
-!          The {\tt ESMF\_Alarm}'s ringing state
+!          The {\tt timelib\_Alarm}'s ringing state
 !     \item[Enabled]
-!          {\tt ESMF\_Alarm} enabled/disabled
+!          {\tt timelib\_Alarm} enabled/disabled
 !     \item[ID]
-!          The {\tt ESMF\_Alarm}'s ID
+!          The {\tt timelib\_Alarm}'s ID
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmWrite not supported' )
-      end subroutine ESMF_AlarmWrite
+      CALL wrf_error_fatal( 'timelib_AlarmWrite not supported' )
+      end subroutine timelib_AlarmWrite
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmValidate - Validate an Alarm's properties
+! !IROUTINE:  timelib_AlarmValidate - Validate an Alarm's properties
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmValidate(alarm, opts, rc)
+      subroutine timelib_AlarmValidate(alarm, opts, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
+      type(timelib_Alarm), intent(in) :: alarm
       character (len=*), intent(in), optional :: opts
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Perform a validation check on a {\tt ESMF\_Alarm}'s properties
+!     Perform a validation check on a {\tt timelib\_Alarm}'s properties
 !
 !     The arguments are:  
 !     \begin{description}
 !     \item[alarm]
-!          {\tt ESMF\_Alarm} to validate
+!          {\tt timelib\_Alarm} to validate
 !     \item[{[opts]}]
 !          Validate options
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description} 
 !
 ! !REQUIREMENTS:
 !     TMGn.n.n
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmValidate not supported' )
-      end subroutine ESMF_AlarmValidate
+      CALL wrf_error_fatal( 'timelib_AlarmValidate not supported' )
+      end subroutine timelib_AlarmValidate
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AlarmPrint - Print out an Alarm's properties
+! !IROUTINE:  timelib_AlarmPrint - Print out an Alarm's properties
 
 ! !INTERFACE:
-      subroutine ESMF_AlarmPrint(alarm, opts, rc)
+      subroutine timelib_AlarmPrint(alarm, opts, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Alarm), intent(in) :: alarm
+      type(timelib_Alarm), intent(in) :: alarm
       character (len=*), intent(in), optional :: opts
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     To support testing/debugging, print out a {\tt ESMF\_Alarm}'s
+!     To support testing/debugging, print out a {\tt timelib\_Alarm}'s
 !     properties.
 ! 
 !     The arguments are:
 !     \begin{description}
 !     \item[alarm]
-!          {\tt ESMF\_Alarm} to print out
+!          {\tt timelib\_Alarm} to print out
 !     \item[{[opts]}]
 !          Print options
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMGn.n.n
 !EOP
-      CALL wrf_error_fatal( 'ESMF_AlarmPrint not supported' )
-      end subroutine ESMF_AlarmPrint
+      CALL wrf_error_fatal( 'timelib_AlarmPrint not supported' )
+      end subroutine timelib_AlarmPrint
 
 !------------------------------------------------------------------------------
 
-      end module ESMF_AlarmMod
+      end module timelib_AlarmMod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Base.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_Base.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_Base.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Base.F90	2017-07-03 16:17:29.680284000 -0400
@@ -7,7 +7,7 @@
 ! NASA Goddard Space Flight Center.
 ! Licensed under the University of Illinois-NCSA license.
 !
-! ESMF Base Module
+! timelib Base Module
 !
 ! (all lines between the !BOP and !EOP markers will be included in the
 ! automated document processing.)
@@ -16,10 +16,10 @@
 !------------------------------------------------------------------------------
 ! module definition
 
-      module ESMF_BaseMod
+      module timelib_BaseMod
  
 !BOP
-! !MODULE: ESMF_BaseMod - Base class for all ESMF classes
+! !MODULE: timelib_BaseMod - Base class for all timelib classes
 !
 ! !DESCRIPTION:
 !
@@ -27,7 +27,7 @@
 !  and functions which operate on all types.  This is an
 !  interface to the actual C++ base class implementation in the ../src dir.
 !
-! See the ESMF Developers Guide document for more details.
+! See the timelib Developers Guide document for more details.
 !
 !------------------------------------------------------------------------------
 
@@ -41,41 +41,41 @@
 !
 !    Global integer parameters, used frequently
 
-      integer, parameter :: ESMF_SUCCESS = 0, ESMF_FAILURE = -1
-      integer, parameter :: ESMF_MAXSTR = 128
-      integer, parameter :: ESMF_MAXDIM = 7, &
-                            ESMF_MAXDECOMPDIM=3, &
-                            ESMF_MAXGRIDDIM=2
+      integer, parameter :: timelib_SUCCESS = 0, timelib_FAILURE = -1
+      integer, parameter :: timelib_MAXSTR = 128
+      integer, parameter :: timelib_MAXDIM = 7, &
+                            timelib_MAXDECOMPDIM=3, &
+                            timelib_MAXGRIDDIM=2
      
-      integer, parameter :: ESMF_MAJOR_VERSION = 2
-      integer, parameter :: ESMF_MINOR_VERSION = 1
-      integer, parameter :: ESMF_REVISION      = 1
-      integer, parameter :: ESMF_PATCHLEVEL    = 0
-      character(32), parameter :: ESMF_VERSION_STRING = "2.1.1"
+      integer, parameter :: timelib_MAJOR_VERSION = 2
+      integer, parameter :: timelib_MINOR_VERSION = 1
+      integer, parameter :: timelib_REVISION      = 1
+      integer, parameter :: timelib_PATCHLEVEL    = 0
+      character(32), parameter :: timelib_VERSION_STRING = "2.1.1"
 
 !------------------------------------------------------------------------------
 !
-      type ESMF_Status
+      type timelib_Status
       private
           integer :: status
       end type
 
-      type(ESMF_Status), parameter :: ESMF_STATE_UNINIT = ESMF_Status(1), &
-                                      ESMF_STATE_READY = ESMF_Status(2), &
-                                      ESMF_STATE_UNALLOCATED = ESMF_Status(3), &
-                                      ESMF_STATE_ALLOCATED = ESMF_Status(4), &
-                                      ESMF_STATE_BUSY = ESMF_Status(5), &
-                                      ESMF_STATE_INVALID = ESMF_Status(6)
+      type(timelib_Status), parameter :: timelib_STATE_UNINIT = timelib_Status(1), &
+                                      timelib_STATE_READY = timelib_Status(2), &
+                                      timelib_STATE_UNALLOCATED = timelib_Status(3), &
+                                      timelib_STATE_ALLOCATED = timelib_Status(4), &
+                                      timelib_STATE_BUSY = timelib_Status(5), &
+                                      timelib_STATE_INVALID = timelib_Status(6)
  
 !------------------------------------------------------------------------------
 !
-      type ESMF_Pointer
+      type timelib_Pointer
       private
           integer*8 :: ptr
       end type
 
-      type(ESMF_Pointer), parameter :: ESMF_NULL_POINTER = ESMF_Pointer(0), &
-                                       ESMF_BAD_POINTER = ESMF_Pointer(-1)
+      type(timelib_Pointer), parameter :: timelib_NULL_POINTER = timelib_Pointer(0), &
+                                       timelib_BAD_POINTER = timelib_Pointer(-1)
 
 
 !------------------------------------------------------------------------------
@@ -84,33 +84,33 @@
       !!   a datatype into integer, then we could use the type and kind as
       !!   targets in a select case() statement and make the contents private.
       !!   (see pg 248 of the "big book")
-      type ESMF_DataType
+      type timelib_DataType
       !!private
           integer :: dtype
       end type
 
-      type(ESMF_DataType), parameter :: ESMF_DATA_INTEGER = ESMF_DataType(1), &
-                                        ESMF_DATA_REAL = ESMF_DataType(2), &
-                                        ESMF_DATA_LOGICAL = ESMF_DataType(3), &
-                                        ESMF_DATA_CHARACTER = ESMF_DataType(4)
+      type(timelib_DataType), parameter :: timelib_DATA_INTEGER = timelib_DataType(1), &
+                                        timelib_DATA_REAL = timelib_DataType(2), &
+                                        timelib_DATA_LOGICAL = timelib_DataType(3), &
+                                        timelib_DATA_CHARACTER = timelib_DataType(4)
 
 !------------------------------------------------------------------------------
 
       integer, parameter :: &
-                   ESMF_KIND_I1 = selected_int_kind(2), &
-                   ESMF_KIND_I2 = selected_int_kind(4), &
-                   ESMF_KIND_I4 = selected_int_kind(9), &
-                   ESMF_KIND_I8 = selected_int_kind(14), &
-                   ESMF_KIND_R4 = selected_real_kind(3,25), &
-                   ESMF_KIND_R8 = selected_real_kind(6,45), &
-                   ESMF_KIND_C8 = selected_real_kind(3,25), &
-                   ESMF_KIND_C16 = selected_real_kind(6,45)
+                   timelib_KIND_I1 = selected_int_kind(2), &
+                   timelib_KIND_I2 = selected_int_kind(4), &
+                   timelib_KIND_I4 = selected_int_kind(9), &
+                   timelib_KIND_I8 = selected_int_kind(14), &
+                   timelib_KIND_R4 = selected_real_kind(3,25), &
+                   timelib_KIND_R8 = selected_real_kind(6,45), &
+                   timelib_KIND_C8 = selected_real_kind(3,25), &
+                   timelib_KIND_C16 = selected_real_kind(6,45)
 
 !------------------------------------------------------------------------------
 
-      type ESMF_DataValue
+      type timelib_DataValue
       private
-          type(ESMF_DataType) :: dt
+          type(timelib_DataType) :: dt
           integer :: rank
           ! how do you do values of all types here ? TODO
           ! in C++ i'd do a union w/ overloaded access funcs
@@ -120,24 +120,24 @@
           !real, dimension (:), pointer :: vrp
           !logical :: vl
           !logical, pointer :: vlp
-          !character (len=ESMF_MAXSTR) :: vc
+          !character (len=timelib_MAXSTR) :: vc
           !character, pointer :: vcp
       end type
 
 !------------------------------------------------------------------------------
 !
-      type ESMF_Attribute
+      type timelib_Attribute
       private
-          character (len=ESMF_MAXSTR) :: attr_name
-          type (ESMF_DataType) :: attr_type
-          type (ESMF_DataValue) :: attr_value
+          character (len=timelib_MAXSTR) :: attr_name
+          type (timelib_DataType) :: attr_type
+          type (timelib_DataValue) :: attr_value
       end type
 
 !------------------------------------------------------------------------------
 !
       !! TODO: this should be a shallow object, with a simple init() and
       !!  get() function, and the contents should go back to being private.
-      type ESMF_AxisIndex
+      type timelib_AxisIndex
 !     !!private
           integer :: l
           integer :: r
@@ -147,7 +147,7 @@
       end type
 
       !! TODO: same comment as above.
-      type ESMF_MemIndex
+      type timelib_MemIndex
 !     !!private
           integer :: l
           integer :: r
@@ -157,7 +157,7 @@
 
 !------------------------------------------------------------------------------
 !
-      type ESMF_BasePointer
+      type timelib_BasePointer
       private
           integer*8 :: base_ptr
       end type
@@ -166,59 +166,59 @@
 
 !------------------------------------------------------------------------------
 !
-!     ! WARNING: must match corresponding values in ../include/ESMC_Base.h
-      type ESMF_Logical
+!     ! WARNING: must match corresponding values in ../include/timelibc_Base.h
+      type timelib_Logical
       private
           integer :: value
       end type
 
-      type(ESMF_Logical), parameter :: ESMF_TF_UNKNOWN  = ESMF_Logical(1), &
-                                       ESMF_TF_TRUE     = ESMF_Logical(2), &
-                                       ESMF_TF_FALSE    = ESMF_Logical(3)
+      type(timelib_Logical), parameter :: timelib_TF_UNKNOWN  = timelib_Logical(1), &
+                                       timelib_TF_TRUE     = timelib_Logical(2), &
+                                       timelib_TF_FALSE    = timelib_Logical(3)
 
 !------------------------------------------------------------------------------
 !
-      type ESMF_Base
+      type timelib_Base
       private
          integer :: ID
          integer :: ref_count
-         type (ESMF_Status) :: base_status
-         character (len=ESMF_MAXSTR) :: name
+         type (timelib_Status) :: base_status
+         character (len=timelib_MAXSTR) :: name
      end type
 
 ! !PUBLIC TYPES:
 
-      public ESMF_STATE_INVALID
-!      public ESMF_STATE_UNINIT, ESMF_STATE_READY, &
-!             ESMF_STATE_UNALLOCATED, ESMF_STATE_ALLOCATED, &
-!             ESMF_STATE_BUSY
+      public timelib_STATE_INVALID
+!      public timelib_STATE_UNINIT, timelib_STATE_READY, &
+!             timelib_STATE_UNALLOCATED, timelib_STATE_ALLOCATED, &
+!             timelib_STATE_BUSY
 
-      public ESMF_DATA_INTEGER, ESMF_DATA_REAL, &
-             ESMF_DATA_LOGICAL, ESMF_DATA_CHARACTER
+      public timelib_DATA_INTEGER, timelib_DATA_REAL, &
+             timelib_DATA_LOGICAL, timelib_DATA_CHARACTER
 
-      public ESMF_KIND_I1, ESMF_KIND_I2, ESMF_KIND_I4, ESMF_KIND_I8, & 
-             ESMF_KIND_R4, ESMF_KIND_R8, ESMF_KIND_C8, ESMF_KIND_C16
+      public timelib_KIND_I1, timelib_KIND_I2, timelib_KIND_I4, timelib_KIND_I8, & 
+             timelib_KIND_R4, timelib_KIND_R8, timelib_KIND_C8, timelib_KIND_C16
 
-      public ESMF_NULL_POINTER, ESMF_BAD_POINTER
+      public timelib_NULL_POINTER, timelib_BAD_POINTER
 
 
-      public ESMF_FAILURE, ESMF_SUCCESS
-      public ESMF_MAXSTR
-      public ESMF_MAXDIM, ESMF_MAXDECOMPDIM, ESMF_MAXGRIDDIM
+      public timelib_FAILURE, timelib_SUCCESS
+      public timelib_MAXSTR
+      public timelib_MAXDIM, timelib_MAXDECOMPDIM, timelib_MAXGRIDDIM
      
-      public ESMF_MAJOR_VERSION, ESMF_MINOR_VERSION, ESMF_REVISION
-      public ESMF_VERSION_STRING 
+      public timelib_MAJOR_VERSION, timelib_MINOR_VERSION, timelib_REVISION
+      public timelib_VERSION_STRING 
 
-      public ESMF_Status, ESMF_Pointer, ESMF_DataType
-      public ESMF_DataValue, ESMF_Attribute
-!      public ESMF_MemIndex
-!      public ESMF_BasePointer
-      public ESMF_Base
-
-      public ESMF_AxisIndex, ESMF_AxisIndexGet
-!      public ESMF_AxisIndexInit
-      public ESMF_Logical
-!      public ESMF_TF_TRUE, ESMF_TF_FALSE
+      public timelib_Status, timelib_Pointer, timelib_DataType
+      public timelib_DataValue, timelib_Attribute
+!      public timelib_MemIndex
+!      public timelib_BasePointer
+      public timelib_Base
+
+      public timelib_AxisIndex, timelib_AxisIndexGet
+!      public timelib_AxisIndexInit
+      public timelib_Logical
+!      public timelib_TF_TRUE, timelib_TF_FALSE
 
 ! !PUBLIC MEMBER FUNCTIONS:
 !
@@ -228,51 +228,51 @@
 !     routines need to be specialized by the higher level objects.
 !
 !   Base class methods
-!      public ESMF_BaseInit
+!      public timelib_BaseInit
    
-!      public ESMF_BaseGetConfig
-!      public ESMF_BaseSetConfig
+!      public timelib_BaseGetConfig
+!      public timelib_BaseSetConfig
 
-!      public ESMF_BaseGetInstCount
+!      public timelib_BaseGetInstCount
 
-!      public ESMF_BaseSetID
-!      public ESMF_BaseGetID
+!      public timelib_BaseSetID
+!      public timelib_BaseGetID
 
-!      public ESMF_BaseSetRefCount
-!      public ESMF_BaseGetRefCount
+!      public timelib_BaseSetRefCount
+!      public timelib_BaseGetRefCount
 
-!      public ESMF_BaseSetStatus
-!      public ESMF_BaseGetStatus
+!      public timelib_BaseSetStatus
+!      public timelib_BaseGetStatus
 
 !   Virtual methods to be defined by derived classes
-!      public ESMF_Read
-!      public ESMF_Write
-!      public ESMF_Validate
-!      public ESMF_Print
+!      public timelib_Read
+!      public timelib_Write
+!      public timelib_Validate
+!      public timelib_Print
 
 !  Attribute methods
-      public ESMF_AttributeSet
-      public ESMF_AttributeGet
-      public ESMF_AttributeGetCount
-      public ESMF_AttributeGetbyNumber
-      public ESMF_AttributeGetNameList
-      public ESMF_AttributeSetList
-      public ESMF_AttributeGetList
-      public ESMF_AttributeSetObjectList
-      public ESMF_AttributeGetObjectList
-      public ESMF_AttributeCopy
-      public ESMF_AttributeCopyAll
+      public timelib_AttributeSet
+      public timelib_AttributeGet
+      public timelib_AttributeGetCount
+      public timelib_AttributeGetbyNumber
+      public timelib_AttributeGetNameList
+      public timelib_AttributeSetList
+      public timelib_AttributeGetList
+      public timelib_AttributeSetObjectList
+      public timelib_AttributeGetObjectList
+      public timelib_AttributeCopy
+      public timelib_AttributeCopyAll
  
 !  Misc methods
-      public ESMF_SetName
-      public ESMF_GetName
-      public ESMF_SetPointer
-      public ESMF_SetNullPointer
-      public ESMF_GetPointer
+      public timelib_SetName
+      public timelib_GetName
+      public timelib_SetPointer
+      public timelib_SetNullPointer
+      public timelib_GetPointer
 
 !  Print methods for calling by higher level print functions
 !  (they have little formatting other than the actual values)
-      public ESMF_StatusString, ESMF_DataTypeString
+      public timelib_StatusString, timelib_DataTypeString
 
 !  Overloaded = operator functions
       public operator(.eq.), operator(.ne.), assignment(=)
@@ -287,24 +287,24 @@
  
 
 interface operator (.eq.)
- module procedure ESMF_sfeq
- module procedure ESMF_dteq
- module procedure ESMF_pteq
- module procedure ESMF_tfeq
- module procedure ESMF_aieq
+ module procedure timelib_sfeq
+ module procedure timelib_dteq
+ module procedure timelib_pteq
+ module procedure timelib_tfeq
+ module procedure timelib_aieq
 end interface
 
 interface operator (.ne.)
- module procedure ESMF_sfne
- module procedure ESMF_dtne
- module procedure ESMF_ptne
- module procedure ESMF_tfne
- module procedure ESMF_aine
+ module procedure timelib_sfne
+ module procedure timelib_dtne
+ module procedure timelib_ptne
+ module procedure timelib_tfne
+ module procedure timelib_aine
 end interface
 
 interface assignment (=)
- module procedure ESMF_dtas
- module procedure ESMF_ptas
+ module procedure timelib_dtas
+ module procedure timelib_ptas
 end interface
 
 !------------------------------------------------------------------------------
@@ -312,97 +312,97 @@
       contains
 
 !------------------------------------------------------------------------------
-! function to compare two ESMF_Status flags to see if they're the same or not
+! function to compare two timelib_Status flags to see if they're the same or not
 
-function ESMF_sfeq(sf1, sf2)
- logical ESMF_sfeq
- type(ESMF_Status), intent(in) :: sf1, sf2
+function timelib_sfeq(sf1, sf2)
+ logical timelib_sfeq
+ type(timelib_Status), intent(in) :: sf1, sf2
 
- ESMF_sfeq = (sf1%status .eq. sf2%status)
+ timelib_sfeq = (sf1%status .eq. sf2%status)
 end function
 
-function ESMF_sfne(sf1, sf2)
- logical ESMF_sfne
- type(ESMF_Status), intent(in) :: sf1, sf2
+function timelib_sfne(sf1, sf2)
+ logical timelib_sfne
+ type(timelib_Status), intent(in) :: sf1, sf2
 
- ESMF_sfne = (sf1%status .ne. sf2%status)
+ timelib_sfne = (sf1%status .ne. sf2%status)
 end function
 
 !------------------------------------------------------------------------------
-! function to compare two ESMF_DataTypes to see if they're the same or not
+! function to compare two timelib_DataTypes to see if they're the same or not
 
-function ESMF_dteq(dt1, dt2)
- logical ESMF_dteq
- type(ESMF_DataType), intent(in) :: dt1, dt2
+function timelib_dteq(dt1, dt2)
+ logical timelib_dteq
+ type(timelib_DataType), intent(in) :: dt1, dt2
 
- ESMF_dteq = (dt1%dtype .eq. dt2%dtype)
+ timelib_dteq = (dt1%dtype .eq. dt2%dtype)
 end function
 
-function ESMF_dtne(dt1, dt2)
- logical ESMF_dtne
- type(ESMF_DataType), intent(in) :: dt1, dt2
+function timelib_dtne(dt1, dt2)
+ logical timelib_dtne
+ type(timelib_DataType), intent(in) :: dt1, dt2
 
- ESMF_dtne = (dt1%dtype .ne. dt2%dtype)
+ timelib_dtne = (dt1%dtype .ne. dt2%dtype)
 end function
 
-subroutine ESMF_dtas(intval, dtval)
+subroutine timelib_dtas(intval, dtval)
  integer, intent(out) :: intval
- type(ESMF_DataType), intent(in) :: dtval
+ type(timelib_DataType), intent(in) :: dtval
 
  intval = dtval%dtype
 end subroutine
 
 
 !------------------------------------------------------------------------------
-! function to compare two ESMF_Pointers to see if they're the same or not
+! function to compare two timelib_Pointers to see if they're the same or not
 
-function ESMF_pteq(pt1, pt2)
- logical ESMF_pteq
- type(ESMF_Pointer), intent(in) :: pt1, pt2
+function timelib_pteq(pt1, pt2)
+ logical timelib_pteq
+ type(timelib_Pointer), intent(in) :: pt1, pt2
 
- ESMF_pteq = (pt1%ptr .eq. pt2%ptr)
+ timelib_pteq = (pt1%ptr .eq. pt2%ptr)
 end function
 
-function ESMF_ptne(pt1, pt2)
- logical ESMF_ptne
- type(ESMF_Pointer), intent(in) :: pt1, pt2
+function timelib_ptne(pt1, pt2)
+ logical timelib_ptne
+ type(timelib_Pointer), intent(in) :: pt1, pt2
 
- ESMF_ptne = (pt1%ptr .ne. pt2%ptr)
+ timelib_ptne = (pt1%ptr .ne. pt2%ptr)
 end function
 
-subroutine ESMF_ptas(ptval, intval)
- type(ESMF_Pointer), intent(out) :: ptval
+subroutine timelib_ptas(ptval, intval)
+ type(timelib_Pointer), intent(out) :: ptval
  integer, intent(in) :: intval
 
  ptval%ptr = intval
 end subroutine
 
 !------------------------------------------------------------------------------
-! function to compare two ESMF_Logicals to see if they're the same or not
+! function to compare two timelib_Logicals to see if they're the same or not
 ! also need assignment to real f90 logical?
 
-function ESMF_tfeq(tf1, tf2)
- logical ESMF_tfeq
- type(ESMF_Logical), intent(in) :: tf1, tf2
+function timelib_tfeq(tf1, tf2)
+ logical timelib_tfeq
+ type(timelib_Logical), intent(in) :: tf1, tf2
 
- ESMF_tfeq = (tf1%value .eq. tf2%value)
+ timelib_tfeq = (tf1%value .eq. tf2%value)
 end function
 
-function ESMF_tfne(tf1, tf2)
- logical ESMF_tfne
- type(ESMF_Logical), intent(in) :: tf1, tf2
+function timelib_tfne(tf1, tf2)
+ logical timelib_tfne
+ type(timelib_Logical), intent(in) :: tf1, tf2
 
- ESMF_tfne = (tf1%value .ne. tf2%value)
+ timelib_tfne = (tf1%value .ne. tf2%value)
 end function
 
 !------------------------------------------------------------------------------
-! function to compare two ESMF_AxisIndex to see if they're the same or not
+! function to compare two timelib_AxisIndex to see if they're the same or not
 
-function ESMF_aieq(ai1, ai2)
- logical ESMF_aieq
- type(ESMF_AxisIndex), intent(in) :: ai1, ai2
+function timelib_aieq(ai1, ai2)
+ logical timelib_aieq
+ type(timelib_AxisIndex), intent(in) :: ai1, ai2
 
- ESMF_aieq = ((ai1%l .eq. ai2%l) .and. &
+ timelib_aieq = ((ai1%l .eq. ai2%l) .and. &
               (ai1%r .eq. ai2%r) .and. &
               (ai1%max .eq. ai2%max) .and. &
               (ai1%decomp .eq. ai2%decomp) .and. &
@@ -410,11 +410,11 @@
 
 end function
 
-function ESMF_aine(ai1, ai2)
- logical ESMF_aine
- type(ESMF_AxisIndex), intent(in) :: ai1, ai2
+function timelib_aine(ai1, ai2)
+ logical timelib_aine
+ type(timelib_AxisIndex), intent(in) :: ai1, ai2
 
- ESMF_aine = ((ai1%l .ne. ai2%l) .or. &
+ timelib_aine = ((ai1%l .ne. ai2%l) .or. &
               (ai1%r .ne. ai2%r) .or. &
               (ai1%max .ne. ai2%max) .or. &
               (ai1%decomp .ne. ai2%decomp) .or. &
@@ -430,13 +430,13 @@
 !------------------------------------------------------------------------------
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_BaseInit - initialize a Base object
+! !IROUTINE:  timelib_BaseInit - initialize a Base object
 !
 ! !INTERFACE:
-      subroutine ESMF_BaseInit(base, rc)
+      subroutine timelib_BaseInit(base, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base) :: base                 
+      type(timelib_Base) :: base                 
       integer, intent(out), optional :: rc     
 
 !
@@ -450,7 +450,7 @@
 !           derived types will include a {\tt Base} object as the first
 !           entry.
 !     \item [{[rc]}]
-!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!           Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !
 !     \end{description}
 !
@@ -462,28 +462,28 @@
       rcpresent = .FALSE.
       if(present(rc)) then
         rcpresent = .TRUE.
-        rc = ESMF_FAILURE
+        rc = timelib_FAILURE
       endif
 
       global_count = global_count + 1
       base%ID = global_count
       base%ref_count = 1
-      base%base_status = ESMF_STATE_READY
+      base%base_status = timelib_STATE_READY
       base%name = "undefined"
 
-      if (rcpresent) rc = ESMF_SUCCESS
+      if (rcpresent) rc = timelib_SUCCESS
 
-      end subroutine ESMF_BaseInit
+      end subroutine timelib_BaseInit
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_SetName - set the name of this object
+! !IROUTINE:  timelib_SetName - set the name of this object
 !
 ! !INTERFACE:
-      subroutine ESMF_SetName(anytype, name, namespace, rc)
+      subroutine timelib_SetName(anytype, name, namespace, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base) :: anytype                 
+      type(timelib_Base) :: anytype                 
       character (len = *), intent(in), optional :: name   
       character (len = *), intent(in), optional :: namespace
       integer, intent(out), optional :: rc     
@@ -501,7 +501,7 @@
 !     \item [[name]]
 !           Object name.  An error will be returned if a duplicate name 
 !           is specified.  If a name is not given a unique name will be
-!           generated and can be queried by the {\tt ESMF_GetName} routine.
+!           generated and can be queried by the {\tt timelib_GetName} routine.
 !     \item [[namespace]]
 !           Object namespace (e.g. "Application", "Component", "Grid", etc).
 !           If given, the name will be checked that it is unique within
@@ -510,7 +510,7 @@
 !           a default "global" namespace will be assumed and the same rules
 !           for names will be followed.
 !     \item [[rc]]
-!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!           Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !
 !     \end{description}
 !
@@ -520,8 +520,8 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.5, FLD1.5.3
       logical :: rcpresent                          ! Return code present   
-      character (len = ESMF_MAXSTR) :: ournamespace ! Namespace if not given
-      character (len = ESMF_MAXSTR) :: defaultname  ! Name if not given
+      character (len = timelib_MAXSTR) :: ournamespace ! Namespace if not given
+      character (len = timelib_MAXSTR) :: defaultname  ! Name if not given
       integer, save :: seqnum = 0       ! HACK - generate uniq names
                                         ! but not coordinated across procs
 
@@ -529,7 +529,7 @@
       rcpresent = .FALSE.
       if(present(rc)) then
         rcpresent = .TRUE.
-        rc = ESMF_FAILURE
+        rc = timelib_FAILURE
       endif
 
 !     ! TODO: this code should generate a unique name if a name
@@ -564,19 +564,19 @@
          anytype%name = defaultname
       endif
 
-      if (rcpresent) rc = ESMF_SUCCESS
+      if (rcpresent) rc = timelib_SUCCESS
 
-      end subroutine ESMF_SetName
+      end subroutine timelib_SetName
 
 !-------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_GetName - get the name of this object
+! !IROUTINE:  timelib_GetName - get the name of this object
 !
 ! !INTERFACE:
-      subroutine ESMF_GetName(anytype, name, rc)
+      subroutine timelib_GetName(anytype, name, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: anytype             ! any ESMF object/type
+      type(timelib_Base), intent(in) :: anytype             ! any timelib object/type
       character (len = *), intent(out) :: name           ! object/type name
       integer, intent(out), optional :: rc               ! return code
 
@@ -589,22 +589,22 @@
 ! !REQUIREMENTS:  FLD1.5, FLD1.5.3
 
       name = anytype%name
-      if (present(rc)) rc = ESMF_SUCCESS
+      if (present(rc)) rc = timelib_SUCCESS
 
-      end subroutine ESMF_GetName
+      end subroutine timelib_GetName
 
 
 !-------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AttributeSet - set attribute on an ESMF type
+! !IROUTINE:  timelib_AttributeSet - set attribute on an timelib type
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeSet(anytype, name, value, rc)
+      subroutine timelib_AttributeSet(anytype, name, value, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: anytype             ! any ESMF type
+      type(timelib_Base), intent(in) :: anytype             ! any timelib type
       character (len = *), intent(in) :: name            ! attribute name
-      type(ESMF_DataValue), intent(in) :: value              ! attribute value
+      type(timelib_DataValue), intent(in) :: value              ! attribute value
       integer, intent(out), optional :: rc               ! return code
 
 !
@@ -615,21 +615,21 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.5, FLD1.5.3
 
-      end subroutine ESMF_AttributeSet
+      end subroutine timelib_AttributeSet
 
 
 !-------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_AttributeGet - get attribute from an ESMF type
+! !IROUTINE:  timelib_AttributeGet - get attribute from an timelib type
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeGet(anytype, name, type, value, rc)
+      subroutine timelib_AttributeGet(anytype, name, type, value, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: anytype           ! any ESMF type
+      type(timelib_Base), intent(in) :: anytype           ! any timelib type
       character (len = *), intent(in) :: name          ! attribute name
-      type(ESMF_DataType), intent(out) :: type             ! all possible data types
-      type(ESMF_DataValue), intent(out) :: value           ! attribute value
+      type(timelib_DataType), intent(out) :: type             ! all possible data types
+      type(timelib_DataValue), intent(out) :: value           ! attribute value
       integer, intent(out), optional :: rc             ! return code
 
 !
@@ -639,19 +639,19 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.5.1, FLD1.5.3
 
-      end subroutine ESMF_AttributeGet
+      end subroutine timelib_AttributeGet
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
-! !IROUTINE:  ESMF_AttributeGetCount - get an ESMF object's number of attributes
+! !IROUTINE:  timelib_AttributeGetCount - get an timelib object's number of attributes
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeGetCount(anytype, count, rc)
+      subroutine timelib_AttributeGetCount(anytype, count, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: anytype             ! any ESMF type
+      type(timelib_Base), intent(in) :: anytype             ! any timelib type
       integer, intent(out) :: count                      ! attribute count
       integer, intent(out), optional :: rc               ! return code
 
@@ -663,23 +663,23 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.7.5
 
-      end subroutine ESMF_AttributeGetCount
+      end subroutine timelib_AttributeGetCount
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
-! !IROUTINE:  ESMF_AttributeGetbyNumber - get an ESMF object's attribute by num ber
+! !IROUTINE:  timelib_AttributeGetbyNumber - get an timelib object's attribute by num ber
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeGetbyNumber(anytype, number, name, type, value, rc)
+      subroutine timelib_AttributeGetbyNumber(anytype, number, name, type, value, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: anytype             ! any ESMF type
+      type(timelib_Base), intent(in) :: anytype             ! any timelib type
       integer, intent(in) :: number                      ! attribute number
       character (len = *), intent(in) :: name            ! attribute name
-      type(ESMF_DataType), intent(out) :: type               ! all possible data types
-      type(ESMF_DataValue), intent(out) :: value             ! attribute value
+      type(timelib_DataType), intent(out) :: type               ! all possible data types
+      type(timelib_DataValue), intent(out) :: value             ! attribute value
       integer, intent(out), optional :: rc               ! return code
 
 !
@@ -690,19 +690,19 @@
 !EOP
 ! !REQUIREMENTS: 
 
-      end subroutine ESMF_AttributeGetbyNumber
+      end subroutine timelib_AttributeGetbyNumber
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
-!IROUTINE:  ESMF_AttributeGetNameList - get an ESMF object's attribute name list
+!IROUTINE:  timelib_AttributeGetNameList - get an timelib object's attribute name list
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeGetNameList(anytype, count, namelist, rc)
+      subroutine timelib_AttributeGetNameList(anytype, count, namelist, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: anytype             ! any ESMF type
+      type(timelib_Base), intent(in) :: anytype             ! any timelib type
       integer, intent(out) :: count                      ! attribute count
       character (len = *), dimension (:), intent(out) :: namelist   ! attribute names
       integer, intent(out), optional :: rc               ! return code
@@ -715,22 +715,22 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.7.3
 
-      end subroutine ESMF_AttributeGetNameList
+      end subroutine timelib_AttributeGetNameList
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
-! !IROUTINE:  ESMF_AttributeSetList - set an ESMF object's attributes 
+! !IROUTINE:  timelib_AttributeSetList - set an timelib object's attributes 
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeSetList(anytype, namelist, valuelist, rc)
+      subroutine timelib_AttributeSetList(anytype, namelist, valuelist, rc)
 
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: anytype             ! any ESMF type
+      type(timelib_Base), intent(in) :: anytype             ! any timelib type
       character (len = *), dimension (:), intent(in) :: namelist    ! attribute names
-      type(ESMF_DataValue), dimension (:), intent(in) :: valuelist      ! attribute values
+      type(timelib_DataValue), dimension (:), intent(in) :: valuelist      ! attribute values
       integer, intent(out), optional :: rc               ! return code
 
 !
@@ -741,22 +741,22 @@
 !EOP
 ! !REQUIREMENTS:  (none.  added for completeness)
 
-      end subroutine ESMF_AttributeSetList
+      end subroutine timelib_AttributeSetList
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
-! !IROUTINE:  ESMF_AttributeGetList - get an ESMF object's attributes
+! !IROUTINE:  timelib_AttributeGetList - get an timelib object's attributes
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeGetList(anytype, namelist, typelist, valuelist, rc)
+      subroutine timelib_AttributeGetList(anytype, namelist, typelist, valuelist, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: anytype             ! any ESMF type
+      type(timelib_Base), intent(in) :: anytype             ! any timelib type
       character (len = *), dimension (:), intent(in) :: namelist    ! attribute names
-      type(ESMF_DataType), dimension (:), intent(out) :: typelist       ! all possible data types
-      type(ESMF_DataValue), dimension (:), intent(out) :: valuelist     ! attribute values
+      type(timelib_DataType), dimension (:), intent(out) :: typelist       ! all possible data types
+      type(timelib_DataValue), dimension (:), intent(out) :: valuelist     ! attribute values
       integer, intent(out), optional :: rc               ! return code
 
 !
@@ -767,21 +767,21 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.7.4
 
-      end subroutine ESMF_AttributeGetList
+      end subroutine timelib_AttributeGetList
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
-! !IROUTINE:  ESMF_AttributeSetObjectList - set an attribute on multiple ESMF objects 
+! !IROUTINE:  timelib_AttributeSetObjectList - set an attribute on multiple timelib objects 
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeSetObjectList(anytypelist, name, value, rc)
+      subroutine timelib_AttributeSetObjectList(anytypelist, name, value, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), dimension (:), intent(in) :: anytypelist     ! list of any ESMF types
+      type(timelib_Base), dimension (:), intent(in) :: anytypelist     ! list of any timelib types
       character (len = *), intent(in) :: name            ! attribute name
-      type(ESMF_DataValue), dimension (:), intent(in) :: value          ! attribute value
+      type(timelib_DataValue), dimension (:), intent(in) :: value          ! attribute value
       integer, intent(out), optional :: rc               ! return code
 
 !
@@ -792,23 +792,23 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.5.5 (pri 2)
 
-      end subroutine ESMF_AttributeSetObjectList
+      end subroutine timelib_AttributeSetObjectList
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
 !
-! !IROUTINE:  ESMF_AttributeGetObjectList - get an attribute from multiple ESMF objects 
+! !IROUTINE:  timelib_AttributeGetObjectList - get an attribute from multiple timelib objects 
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeGetObjectList(anytypelist, name, typelist, valuelist, rc)
+      subroutine timelib_AttributeGetObjectList(anytypelist, name, typelist, valuelist, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), dimension (:), intent(in) :: anytypelist     ! list of any ESMF types
+      type(timelib_Base), dimension (:), intent(in) :: anytypelist     ! list of any timelib types
       character (len = *), intent(in) :: name            ! attribute name
-      type(ESMF_DataType), dimension (:), intent(out) :: typelist       ! all possible data types
-      type(ESMF_DataValue), dimension (:), intent(out) :: valuelist     ! attribute values
+      type(timelib_DataType), dimension (:), intent(out) :: typelist       ! all possible data types
+      type(timelib_DataValue), dimension (:), intent(out) :: valuelist     ! attribute values
       integer, intent(out), optional :: rc               ! return code
 
 !
@@ -819,21 +819,21 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.5.5 (pri 2)
 
-      end subroutine ESMF_AttributeGetObjectList
+      end subroutine timelib_AttributeGetObjectList
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
-! !IROUTINE:  ESMF_AttributeCopy - copy an attribute between two objects
+! !IROUTINE:  timelib_AttributeCopy - copy an attribute between two objects
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeCopy(name, source, destination, rc)
+      subroutine timelib_AttributeCopy(name, source, destination, rc)
 !
 ! !ARGUMENTS:
       character (len = *), intent(in) :: name            ! attribute name
-      type(ESMF_Base), intent(in) :: source              ! any ESMF type
-      type(ESMF_Base), intent(in) :: destination         ! any ESMF type
+      type(timelib_Base), intent(in) :: source              ! any timelib type
+      type(timelib_Base), intent(in) :: destination         ! any timelib type
       integer, intent(out), optional :: rc               ! return code
 
 !
@@ -848,21 +848,21 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.5.4
 
-      end subroutine ESMF_AttributeCopy
+      end subroutine timelib_AttributeCopy
 
 
 !-------------------------------------------------------------------------
 !BOP
 !
-!IROUTINE:  ESMC_AttributeCopyAll - copy attributes between two objects
+!IROUTINE:  timelibc_AttributeCopyAll - copy attributes between two objects
 
 !
 ! !INTERFACE:
-      subroutine ESMF_AttributeCopyAll(source, destination, rc)
+      subroutine timelib_AttributeCopyAll(source, destination, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Base), intent(in) :: source              ! any ESMF type
-      type(ESMF_Base), intent(in) :: destination         ! any ESMF type
+      type(timelib_Base), intent(in) :: source              ! any timelib type
+      type(timelib_Base), intent(in) :: destination         ! any timelib type
       integer, intent(out), optional :: rc               ! return code
 
 !
@@ -876,21 +876,21 @@
 !EOP
 ! !REQUIREMENTS:  FLD1.5.4
 
-      end subroutine ESMF_AttributeCopyAll
+      end subroutine timelib_AttributeCopyAll
 
 !=========================================================================
 ! Misc utility routines, perhaps belongs in a utility file?
 !-------------------------------------------------------------------------
 !BOP
 !
-!IROUTINE:  ESMC_AxisIndexInit - initialize an AxisIndex object
+!IROUTINE:  timelibc_AxisIndexInit - initialize an AxisIndex object
 
 !
 ! !INTERFACE:
-      subroutine ESMF_AxisIndexInit(ai, l, r, max, decomp, gstart, rc)
+      subroutine timelib_AxisIndexInit(ai, l, r, max, decomp, gstart, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_AxisIndex), intent(inout) :: ai
+      type(timelib_AxisIndex), intent(inout) :: ai
       integer, intent(in) :: l, r, max, decomp, gstart
       integer, intent(out), optional :: rc  
 !
@@ -907,20 +907,20 @@
       ai%decomp = decomp
       ai%gstart = gstart
 
-      if (present(rc)) rc = ESMF_SUCCESS
+      if (present(rc)) rc = timelib_SUCCESS
 
-      end subroutine ESMF_AxisIndexInit
+      end subroutine timelib_AxisIndexInit
 
 !BOP
 !
-!IROUTINE:  ESMC_AxisIndexInit - initialize an AxisIndex object
+!IROUTINE:  timelibc_AxisIndexInit - initialize an AxisIndex object
 
 !
 ! !INTERFACE:
-      subroutine ESMF_AxisIndexGet(ai, l, r, max, decomp, gstart, rc)
+      subroutine timelib_AxisIndexGet(ai, l, r, max, decomp, gstart, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_AxisIndex), intent(inout) :: ai
+      type(timelib_AxisIndex), intent(inout) :: ai
       integer, intent(out), optional :: l, r, max, decomp, gstart
       integer, intent(out), optional :: rc  
 !
@@ -937,22 +937,22 @@
       if (present(decomp)) decomp = ai%decomp
       if (present(gstart)) gstart = ai%gstart
 
-      if (present(rc)) rc = ESMF_SUCCESS
+      if (present(rc)) rc = timelib_SUCCESS
 
-      end subroutine ESMF_AxisIndexGet
+      end subroutine timelib_AxisIndexGet
 
 !-------------------------------------------------------------------------
 !-------------------------------------------------------------------------
 !BOP
 !
-!IROUTINE:  ESMF_SetPointer - set an opaque value
+!IROUTINE:  timelib_SetPointer - set an opaque value
 
 !
 ! !INTERFACE:
-      subroutine ESMF_SetPointer(ptype, contents, rc)
+      subroutine timelib_SetPointer(ptype, contents, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Pointer) :: ptype 
+      type(timelib_Pointer) :: ptype 
       integer*8, intent(in) :: contents
       integer, intent(out), optional :: rc  
 
@@ -964,21 +964,21 @@
 !EOP
 ! !REQUIREMENTS:
       ptype%ptr = contents
-      if (present(rc)) rc = ESMF_SUCCESS
+      if (present(rc)) rc = timelib_SUCCESS
 
-      end subroutine ESMF_SetPointer
+      end subroutine timelib_SetPointer
 
 !-------------------------------------------------------------------------
 !BOP
 !
-!IROUTINE:  ESMF_SetNullPointer - set an opaque value
+!IROUTINE:  timelib_SetNullPointer - set an opaque value
 
 !
 ! !INTERFACE:
-      subroutine ESMF_SetNullPointer(ptype, rc)
+      subroutine timelib_SetNullPointer(ptype, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Pointer) :: ptype 
+      type(timelib_Pointer) :: ptype 
       integer, intent(out), optional :: rc  
 
 !
@@ -991,21 +991,21 @@
       integer*8, parameter :: nullp = 0
 
       ptype%ptr = nullp
-      if (present(rc)) rc = ESMF_SUCCESS
+      if (present(rc)) rc = timelib_SUCCESS
 
-      end subroutine ESMF_SetNullPointer
+      end subroutine timelib_SetNullPointer
 !------------------------------------------------------------------------- 
 !BOP 
-!  !IROUTINE:  ESMF_GetPointer - get an opaque value 
+!  !IROUTINE:  timelib_GetPointer - get an opaque value 
 !  
 ! !INTERFACE: 
-      function ESMF_GetPointer(ptype, rc) 
+      function timelib_GetPointer(ptype, rc) 
 !
 ! !RETURN VALUE:
-      integer*8 :: ESMF_GetPointer
+      integer*8 :: timelib_GetPointer
 
 ! !ARGUMENTS:
-      type(ESMF_Pointer), intent(in) :: ptype 
+      type(timelib_Pointer), intent(in) :: ptype 
       integer, intent(out), optional :: rc  
 
 !
@@ -1015,22 +1015,22 @@
 !
 !EOP
 ! !REQUIREMENTS:
-      ESMF_GetPointer = ptype%ptr
-      if (present(rc)) rc = ESMF_SUCCESS
+      timelib_GetPointer = ptype%ptr
+      if (present(rc)) rc = timelib_SUCCESS
 
-      end function ESMF_GetPointer
+      end function timelib_GetPointer
 
 !------------------------------------------------------------------------- 
 ! misc print routines
 !------------------------------------------------------------------------- 
 !BOP 
-!  !IROUTINE:  ESMF_StatusString - Return status as a string
+!  !IROUTINE:  timelib_StatusString - Return status as a string
 !  
 ! !INTERFACE: 
-      subroutine ESMF_StatusString(status, string, rc)
+      subroutine timelib_StatusString(status, string, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Status), intent(in) :: status
+      type(timelib_Status), intent(in) :: status
       character(len=*), intent(out) :: string
       integer, intent(out), optional :: rc  
 
@@ -1042,26 +1042,26 @@
 !EOP
 ! !REQUIREMENTS:
 
-      if (status .eq. ESMF_STATE_UNINIT) string = "Uninitialized"
-      if (status .eq. ESMF_STATE_READY) string = "Ready"
-      if (status .eq. ESMF_STATE_UNALLOCATED) string = "Unallocated"
-      if (status .eq. ESMF_STATE_ALLOCATED) string = "Allocated"
-      if (status .eq. ESMF_STATE_BUSY) string = "Busy"
-      if (status .eq. ESMF_STATE_INVALID) string = "Invalid"
+      if (status .eq. timelib_STATE_UNINIT) string = "Uninitialized"
+      if (status .eq. timelib_STATE_READY) string = "Ready"
+      if (status .eq. timelib_STATE_UNALLOCATED) string = "Unallocated"
+      if (status .eq. timelib_STATE_ALLOCATED) string = "Allocated"
+      if (status .eq. timelib_STATE_BUSY) string = "Busy"
+      if (status .eq. timelib_STATE_INVALID) string = "Invalid"
  
-      if (present(rc)) rc = ESMF_SUCCESS
+      if (present(rc)) rc = timelib_SUCCESS
 
-      end subroutine ESMF_StatusString
+      end subroutine timelib_StatusString
 
 !------------------------------------------------------------------------- 
 !BOP 
-!  !IROUTINE:  ESMF_DataTypeString - Return DataType as a string
+!  !IROUTINE:  timelib_DataTypeString - Return DataType as a string
 !  
 ! !INTERFACE: 
-      subroutine ESMF_DataTypeString(datatype, string, rc)
+      subroutine timelib_DataTypeString(datatype, string, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_DataType), intent(in) :: datatype
+      type(timelib_DataType), intent(in) :: datatype
       character(len=*), intent(out) :: string
       integer, intent(out), optional :: rc  
 
@@ -1073,14 +1073,14 @@
 !EOP
 ! !REQUIREMENTS:
 
-      if (datatype .eq. ESMF_DATA_INTEGER) string = "Integer"
-      if (datatype .eq. ESMF_DATA_REAL) string = "Real"
-      if (datatype .eq. ESMF_DATA_LOGICAL) string = "Logical"
-      if (datatype .eq. ESMF_DATA_CHARACTER) string = "Character"
+      if (datatype .eq. timelib_DATA_INTEGER) string = "Integer"
+      if (datatype .eq. timelib_DATA_REAL) string = "Real"
+      if (datatype .eq. timelib_DATA_LOGICAL) string = "Logical"
+      if (datatype .eq. timelib_DATA_CHARACTER) string = "Character"
  
-      if (present(rc)) rc = ESMF_SUCCESS
+      if (present(rc)) rc = timelib_SUCCESS
 
-      end subroutine ESMF_DataTypeString
+      end subroutine timelib_DataTypeString
 
 !-------------------------------------------------------------------------
 !
@@ -1089,4 +1089,4 @@
 !  overridden by higher level more specialized functions.
 !-------------------------------------------------------------------------
 
-      end module ESMF_BaseMod
+      end module timelib_BaseMod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_BaseTime.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_BaseTime.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_BaseTime.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_BaseTime.F90	2017-07-03 16:17:29.680683000 -0400
@@ -9,8 +9,8 @@
 !
 !==============================================================================
 !
-!     ESMF BaseTime Module
-      module ESMF_BaseTimeMod
+!     timelib BaseTime Module
+      module timelib_BaseTimeMod
 !
 !==============================================================================
 !
@@ -20,67 +20,67 @@
 !------------------------------------------------------------------------------
 ! INCLUDES
 
-#include <ESMF_TimeMgr.inc>
+#include <timelib_TimeMgr.inc>
 !
 !===============================================================================
 !BOPI
-! !MODULE: ESMF_BaseTimeMod - Base ESMF time definition 
+! !MODULE: timelib_BaseTimeMod - Base timelib time definition 
 !
 ! !DESCRIPTION:
 ! Part of Time Manager F90 API wrapper of C++ implemenation
 !
 ! This module serves only as the common Time definition inherited
-! by {\tt ESMF\_TimeInterval} and {\tt ESMF\_Time}
+! by {\tt timelib\_TimeInterval} and {\tt timelib\_Time}
 !
-! See {\tt ../include/ESMC\_BaseTime.h} for complete description
+! See {\tt ../include/timelibc\_BaseTime.h} for complete description
 !
 !------------------------------------------------------------------------------
 ! !USES:
-      use ESMF_BaseMod    ! ESMF Base class
+      use timelib_BaseMod    ! timelib Base class
       implicit none
 !
 !------------------------------------------------------------------------------
 ! !PRIVATE TYPES:
       private
 !------------------------------------------------------------------------------
-!     ! ESMF_BaseTime
+!     ! timelib_BaseTime
 !
 !     ! Base class type to match C++ BaseTime class in size only;
 !     !  all dereferencing within class is performed by C++ implementation
 
-      type ESMF_BaseTime
-        integer(ESMF_KIND_I8) :: S   ! whole seconds
-        integer(ESMF_KIND_I8) :: Sn  ! fractional seconds, numerator
-        integer(ESMF_KIND_I8) :: Sd  ! fractional seconds, denominator
+      type timelib_BaseTime
+        integer(timelib_KIND_I8) :: S   ! whole seconds
+        integer(timelib_KIND_I8) :: Sn  ! fractional seconds, numerator
+        integer(timelib_KIND_I8) :: Sd  ! fractional seconds, denominator
       end type
 
 !------------------------------------------------------------------------------
 ! !PUBLIC TYPES:
-      public ESMF_BaseTime
+      public timelib_BaseTime
 !------------------------------------------------------------------------------
 !
 ! !PUBLIC MEMBER FUNCTIONS:
 !
 ! overloaded operators
       public operator(+)
-      private ESMF_BaseTimeSum
+      private timelib_BaseTimeSum
       public operator(-)
-      private ESMF_BaseTimeDifference
+      private timelib_BaseTimeDifference
       public operator(/)
-      private ESMF_BaseTimeQuotI
-      private ESMF_BaseTimeQuotI8
+      private timelib_BaseTimeQuotI
+      private timelib_BaseTimeQuotI8
       public operator(.EQ.)
-      private ESMF_BaseTimeEQ
+      private timelib_BaseTimeEQ
       public operator(.NE.)
-      private ESMF_BaseTimeNE
+      private timelib_BaseTimeNE
       public operator(.LT.)
-      private ESMF_BaseTimeLT
+      private timelib_BaseTimeLT
       public operator(.GT.)
-      private ESMF_BaseTimeGT
+      private timelib_BaseTimeGT
       public operator(.LE.)
-      private ESMF_BaseTimeLE
+      private timelib_BaseTimeLE
       public operator(.GE.)
-      private ESMF_BaseTimeGE
+      private timelib_BaseTimeGE
 
 !==============================================================================
 !
@@ -88,31 +88,31 @@
 !
 !==============================================================================
       interface operator(+)
-        module procedure ESMF_BaseTimeSum
+        module procedure timelib_BaseTimeSum
       end interface
       interface operator(-)
-        module procedure ESMF_BaseTimeDifference
+        module procedure timelib_BaseTimeDifference
       end interface
       interface operator(/)
-        module procedure ESMF_BaseTimeQuotI,ESMF_BaseTimeQuotI8
+        module procedure timelib_BaseTimeQuotI,timelib_BaseTimeQuotI8
       end interface
       interface operator(.EQ.)
-        module procedure ESMF_BaseTimeEQ
+        module procedure timelib_BaseTimeEQ
       end interface
       interface operator(.NE.)
-        module procedure ESMF_BaseTimeNE
+        module procedure timelib_BaseTimeNE
       end interface
       interface operator(.LT.)
-        module procedure ESMF_BaseTimeLT
+        module procedure timelib_BaseTimeLT
       end interface
       interface operator(.GT.)
-        module procedure ESMF_BaseTimeGT
+        module procedure timelib_BaseTimeGT
       end interface
       interface operator(.LE.)
-        module procedure ESMF_BaseTimeLE
+        module procedure timelib_BaseTimeLE
       end interface
       interface operator(.GE.)
-        module procedure ESMF_BaseTimeGE
+        module procedure timelib_BaseTimeGE
       end interface
 
 
@@ -124,195 +124,195 @@
 
 
 ! Add two basetimes
-      FUNCTION ESMF_BaseTimeSum( basetime1, basetime2 )
-        TYPE(ESMF_BaseTime) :: ESMF_BaseTimeSum
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime1
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime2
+      FUNCTION timelib_BaseTimeSum( basetime1, basetime2 )
+        TYPE(timelib_BaseTime) :: timelib_BaseTimeSum
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime1
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime2
         ! locals
-        INTEGER (ESMF_KIND_I8) :: Sn1, Sd1, Sn2, Sd2, lcd
-!  PRINT *,'DEBUG:  BEGIN ESMF_BaseTimeSum()'
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  basetime1%S = ',basetime1%S
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  basetime1%Sn = ',basetime1%Sn
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  basetime1%Sd = ',basetime1%Sd
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  basetime2%S = ',basetime2%S
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  basetime2%Sn = ',basetime2%Sn
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  basetime2%Sd = ',basetime2%Sd
-        ESMF_BaseTimeSum   = basetime1
-        ESMF_BaseTimeSum%S = ESMF_BaseTimeSum%S + basetime2%S
+        INTEGER (timelib_KIND_I8) :: Sn1, Sd1, Sn2, Sd2, lcd
+!  PRINT *,'DEBUG:  BEGIN timelib_BaseTimeSum()'
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  basetime1%S = ',basetime1%S
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  basetime1%Sn = ',basetime1%Sn
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  basetime1%Sd = ',basetime1%Sd
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  basetime2%S = ',basetime2%S
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  basetime2%Sn = ',basetime2%Sn
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  basetime2%Sd = ',basetime2%Sd
+        timelib_BaseTimeSum   = basetime1
+        timelib_BaseTimeSum%S = timelib_BaseTimeSum%S + basetime2%S
         Sn1 = basetime1%Sn
         Sd1 = basetime1%Sd
         Sn2 = basetime2%Sn
         Sd2 = basetime2%Sd
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  Sn1 = ',Sn1
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  Sd1 = ',Sd1
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  Sn2 = ',Sn2
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  Sd2 = ',Sd2
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  Sn1 = ',Sn1
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  Sd1 = ',Sd1
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  Sn2 = ',Sn2
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  Sd2 = ',Sd2
         IF      ( ( Sd1 .EQ. 0 ) .AND. ( Sd2 .EQ. 0 ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  no fractions'
-          ESMF_BaseTimeSum%Sn = 0
-          ESMF_BaseTimeSum%Sd = 0
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  no fractions'
+          timelib_BaseTimeSum%Sn = 0
+          timelib_BaseTimeSum%Sd = 0
         ELSE IF ( ( Sd1 .NE. 0 ) .AND. ( Sd2 .EQ. 0 ) ) THEN
-          ESMF_BaseTimeSum%Sn = Sn1
-          ESMF_BaseTimeSum%Sd = Sd1
+          timelib_BaseTimeSum%Sn = Sn1
+          timelib_BaseTimeSum%Sd = Sd1
         ELSE IF ( ( Sd1 .EQ. 0 ) .AND. ( Sd2 .NE. 0 ) ) THEN
-          ESMF_BaseTimeSum%Sn = Sn2
-          ESMF_BaseTimeSum%Sd = Sd2
+          timelib_BaseTimeSum%Sn = Sn2
+          timelib_BaseTimeSum%Sd = Sd2
         ELSE IF ( ( Sd1 .NE. 0 ) .AND. ( Sd2 .NE. 0 ) ) THEN
           CALL compute_lcd( Sd1 , Sd2 , lcd )
-          ESMF_BaseTimeSum%Sd = lcd
-          ESMF_BaseTimeSum%Sn = (Sn1 * lcd / Sd1) + (Sn2 * lcd / Sd2)
+          timelib_BaseTimeSum%Sd = lcd
+          timelib_BaseTimeSum%Sn = (Sn1 * lcd / Sd1) + (Sn2 * lcd / Sd2)
         ENDIF
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  ESMF_BaseTimeSum%S = ',ESMF_BaseTimeSum%S
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  ESMF_BaseTimeSum%Sn = ',ESMF_BaseTimeSum%Sn
-!  PRINT *,'DEBUG:  ESMF_BaseTimeSum():  ESMF_BaseTimeSum%Sd = ',ESMF_BaseTimeSum%Sd
-        CALL normalize_basetime( ESMF_BaseTimeSum )
-!  PRINT *,'DEBUG:  END ESMF_BaseTimeSum()'
-      END FUNCTION ESMF_BaseTimeSum
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  timelib_BaseTimeSum%S = ',timelib_BaseTimeSum%S
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  timelib_BaseTimeSum%Sn = ',timelib_BaseTimeSum%Sn
+!  PRINT *,'DEBUG:  timelib_BaseTimeSum():  timelib_BaseTimeSum%Sd = ',timelib_BaseTimeSum%Sd
+        CALL normalize_basetime( timelib_BaseTimeSum )
+!  PRINT *,'DEBUG:  END timelib_BaseTimeSum()'
+      END FUNCTION timelib_BaseTimeSum
 
 
 ! Subtract two basetimes
-      FUNCTION ESMF_BaseTimeDifference( basetime1, basetime2 )
-        TYPE(ESMF_BaseTime) :: ESMF_BaseTimeDifference
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime1
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime2
+      FUNCTION timelib_BaseTimeDifference( basetime1, basetime2 )
+        TYPE(timelib_BaseTime) :: timelib_BaseTimeDifference
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime1
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime2
         ! locals
-        TYPE(ESMF_BaseTime) :: neg2
+        TYPE(timelib_BaseTime) :: neg2
 
         neg2%S  = -basetime2%S
         neg2%Sn = -basetime2%Sn
         neg2%Sd =  basetime2%Sd
 
-        ESMF_BaseTimeDifference = basetime1 + neg2
+        timelib_BaseTimeDifference = basetime1 + neg2
 
-      END FUNCTION ESMF_BaseTimeDifference
+      END FUNCTION timelib_BaseTimeDifference
 
 
 ! Divide basetime by 8-byte integer
-      FUNCTION ESMF_BaseTimeQuotI8( basetime, divisor )
-        TYPE(ESMF_BaseTime) :: ESMF_BaseTimeQuotI8
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime
-        INTEGER(ESMF_KIND_I8), INTENT(IN) :: divisor
+      FUNCTION timelib_BaseTimeQuotI8( basetime, divisor )
+        TYPE(timelib_BaseTime) :: timelib_BaseTimeQuotI8
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime
+        INTEGER(timelib_KIND_I8), INTENT(IN) :: divisor
         ! locals
-        INTEGER(ESMF_KIND_I8) :: d, n, dinit
+        INTEGER(timelib_KIND_I8) :: d, n, dinit
 
-!PRINT *,'DEBUG ESMF_BaseTimeQuotI8() A:  S,Sn,Sd = ', &
+!PRINT *,'DEBUG timelib_BaseTimeQuotI8() A:  S,Sn,Sd = ', &
 !  basetime%S,basetime%Sn,basetime%Sd
-!PRINT *,'DEBUG ESMF_BaseTimeQuotI8() A:  divisor = ', divisor
-        IF ( divisor == 0_ESMF_KIND_I8 ) THEN
-          CALL wrf_error_fatal( 'ESMF_BaseTimeQuotI8:  divide by zero' )
+!PRINT *,'DEBUG timelib_BaseTimeQuotI8() A:  divisor = ', divisor
+        IF ( divisor == 0_timelib_KIND_I8 ) THEN
+          CALL wrf_error_fatal( 'timelib_BaseTimeQuotI8:  divide by zero' )
         ENDIF
 
 !$$$ move to default constructor
-        ESMF_BaseTimeQuotI8%S  = 0
-        ESMF_BaseTimeQuotI8%Sn = 0
-        ESMF_BaseTimeQuotI8%Sd = 0
+        timelib_BaseTimeQuotI8%S  = 0
+        timelib_BaseTimeQuotI8%Sn = 0
+        timelib_BaseTimeQuotI8%Sd = 0
 
         ! convert to a fraction and divide by multipling the denonminator by 
         ! the divisor
         IF ( basetime%Sd == 0 ) THEN
-          dinit = 1_ESMF_KIND_I8
+          dinit = 1_timelib_KIND_I8
         ELSE
           dinit = basetime%Sd
         ENDIF
         n = basetime%S * dinit + basetime%Sn
         d = dinit * divisor
-!PRINT *,'DEBUG ESMF_BaseTimeQuotI8() B:  n,d = ',n,d
-        CALL simplify( n, d, ESMF_BaseTimeQuotI8%Sn, ESMF_BaseTimeQuotI8%Sd )
-!PRINT *,'DEBUG ESMF_BaseTimeQuotI8() C:  S,Sn,Sd = ', &
-!  ESMF_BaseTimeQuotI8%S,ESMF_BaseTimeQuotI8%Sn,ESMF_BaseTimeQuotI8%Sd
-        CALL normalize_basetime( ESMF_BaseTimeQuotI8 )
-!PRINT *,'DEBUG ESMF_BaseTimeQuotI8() D:  S,Sn,Sd = ', &
-!  ESMF_BaseTimeQuotI8%S,ESMF_BaseTimeQuotI8%Sn,ESMF_BaseTimeQuotI8%Sd
-      END FUNCTION ESMF_BaseTimeQuotI8
+!PRINT *,'DEBUG timelib_BaseTimeQuotI8() B:  n,d = ',n,d
+        CALL simplify( n, d, timelib_BaseTimeQuotI8%Sn, timelib_BaseTimeQuotI8%Sd )
+!PRINT *,'DEBUG timelib_BaseTimeQuotI8() C:  S,Sn,Sd = ', &
+!  timelib_BaseTimeQuotI8%S,timelib_BaseTimeQuotI8%Sn,timelib_BaseTimeQuotI8%Sd
+        CALL normalize_basetime( timelib_BaseTimeQuotI8 )
+!PRINT *,'DEBUG timelib_BaseTimeQuotI8() D:  S,Sn,Sd = ', &
+!  timelib_BaseTimeQuotI8%S,timelib_BaseTimeQuotI8%Sn,timelib_BaseTimeQuotI8%Sd
+      END FUNCTION timelib_BaseTimeQuotI8
 
 ! Divide basetime by integer
-      FUNCTION ESMF_BaseTimeQuotI( basetime, divisor )
-        TYPE(ESMF_BaseTime) :: ESMF_BaseTimeQuotI
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime
+      FUNCTION timelib_BaseTimeQuotI( basetime, divisor )
+        TYPE(timelib_BaseTime) :: timelib_BaseTimeQuotI
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime
         INTEGER, INTENT(IN) :: divisor
         IF ( divisor == 0 ) THEN
-          CALL wrf_error_fatal( 'ESMF_BaseTimeQuotI:  divide by zero' )
+          CALL wrf_error_fatal( 'timelib_BaseTimeQuotI:  divide by zero' )
         ENDIF
-        ESMF_BaseTimeQuotI = basetime / INT( divisor, ESMF_KIND_I8 )
-      END FUNCTION ESMF_BaseTimeQuotI
+        timelib_BaseTimeQuotI = basetime / INT( divisor, timelib_KIND_I8 )
+      END FUNCTION timelib_BaseTimeQuotI
 
 
 ! .EQ. for two basetimes
-      FUNCTION ESMF_BaseTimeEQ( basetime1, basetime2 )
-        LOGICAL :: ESMF_BaseTimeEQ
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime1
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime2
+      FUNCTION timelib_BaseTimeEQ( basetime1, basetime2 )
+        LOGICAL :: timelib_BaseTimeEQ
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime1
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime2
         INTEGER :: retval
         CALL seccmp( basetime1%S, basetime1%Sn, basetime1%Sd, &
                      basetime2%S, basetime2%Sn, basetime2%Sd, &
                      retval )
-        ESMF_BaseTimeEQ = ( retval .EQ. 0 )
-      END FUNCTION ESMF_BaseTimeEQ
+        timelib_BaseTimeEQ = ( retval .EQ. 0 )
+      END FUNCTION timelib_BaseTimeEQ
 
 
 ! .NE. for two basetimes
-      FUNCTION ESMF_BaseTimeNE( basetime1, basetime2 )
-        LOGICAL :: ESMF_BaseTimeNE
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime1
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime2
+      FUNCTION timelib_BaseTimeNE( basetime1, basetime2 )
+        LOGICAL :: timelib_BaseTimeNE
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime1
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime2
         INTEGER :: retval
         CALL seccmp( basetime1%S, basetime1%Sn, basetime1%Sd, &
                      basetime2%S, basetime2%Sn, basetime2%Sd, &
                      retval )
-        ESMF_BaseTimeNE = ( retval .NE. 0 )
-      END FUNCTION ESMF_BaseTimeNE
+        timelib_BaseTimeNE = ( retval .NE. 0 )
+      END FUNCTION timelib_BaseTimeNE
 
 
 ! .LT. for two basetimes
-      FUNCTION ESMF_BaseTimeLT( basetime1, basetime2 )
-        LOGICAL :: ESMF_BaseTimeLT
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime1
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime2
+      FUNCTION timelib_BaseTimeLT( basetime1, basetime2 )
+        LOGICAL :: timelib_BaseTimeLT
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime1
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime2
         INTEGER :: retval
         CALL seccmp( basetime1%S, basetime1%Sn, basetime1%Sd, &
                      basetime2%S, basetime2%Sn, basetime2%Sd, &
                      retval )
-        ESMF_BaseTimeLT = ( retval .LT. 0 )
-      END FUNCTION ESMF_BaseTimeLT
+        timelib_BaseTimeLT = ( retval .LT. 0 )
+      END FUNCTION timelib_BaseTimeLT
 
 
 ! .GT. for two basetimes
-      FUNCTION ESMF_BaseTimeGT( basetime1, basetime2 )
-        LOGICAL :: ESMF_BaseTimeGT
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime1
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime2
+      FUNCTION timelib_BaseTimeGT( basetime1, basetime2 )
+        LOGICAL :: timelib_BaseTimeGT
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime1
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime2
         INTEGER :: retval
         CALL seccmp( basetime1%S, basetime1%Sn, basetime1%Sd, &
                      basetime2%S, basetime2%Sn, basetime2%Sd, &
                      retval )
-        ESMF_BaseTimeGT = ( retval .GT. 0 )
-      END FUNCTION ESMF_BaseTimeGT
+        timelib_BaseTimeGT = ( retval .GT. 0 )
+      END FUNCTION timelib_BaseTimeGT
 
 
 ! .LE. for two basetimes
-      FUNCTION ESMF_BaseTimeLE( basetime1, basetime2 )
-        LOGICAL :: ESMF_BaseTimeLE
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime1
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime2
+      FUNCTION timelib_BaseTimeLE( basetime1, basetime2 )
+        LOGICAL :: timelib_BaseTimeLE
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime1
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime2
         INTEGER :: retval
         CALL seccmp( basetime1%S, basetime1%Sn, basetime1%Sd, &
                      basetime2%S, basetime2%Sn, basetime2%Sd, &
                      retval )
-        ESMF_BaseTimeLE = ( retval .LE. 0 )
-      END FUNCTION ESMF_BaseTimeLE
+        timelib_BaseTimeLE = ( retval .LE. 0 )
+      END FUNCTION timelib_BaseTimeLE
 
 
 ! .GE. for two basetimes
-      FUNCTION ESMF_BaseTimeGE( basetime1, basetime2 )
-        LOGICAL :: ESMF_BaseTimeGE
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime1
-        TYPE(ESMF_BaseTime), INTENT(IN) :: basetime2
+      FUNCTION timelib_BaseTimeGE( basetime1, basetime2 )
+        LOGICAL :: timelib_BaseTimeGE
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime1
+        TYPE(timelib_BaseTime), INTENT(IN) :: basetime2
         INTEGER :: retval
         CALL seccmp( basetime1%S, basetime1%Sn, basetime1%Sd, &
                      basetime2%S, basetime2%Sn, basetime2%Sd, &
                      retval )
-        ESMF_BaseTimeGE = ( retval .GE. 0 )
-      END FUNCTION ESMF_BaseTimeGE
+        timelib_BaseTimeGE = ( retval .GE. 0 )
+      END FUNCTION timelib_BaseTimeGE
 
 
-      end module ESMF_BaseTimeMod
+      end module timelib_BaseTimeMod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Calendar.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_Calendar.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_Calendar.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Calendar.F90	2017-07-03 16:17:29.681067000 -0400
@@ -9,8 +9,8 @@
 !
 !==============================================================================
 !
-!     ESMF Calendar Module
-      module ESMF_CalendarMod
+!     timelib Calendar Module
+      module timelib_CalendarMod
 !
 !==============================================================================
 !
@@ -19,27 +19,27 @@
 !
 !------------------------------------------------------------------------------
 ! INCLUDES
-#include <ESMF_TimeMgr.inc>
+#include <timelib_TimeMgr.inc>
 
 !==============================================================================
 !BOPI
-! !MODULE: ESMF_CalendarMod
+! !MODULE: timelib_CalendarMod
 !
 ! !DESCRIPTION:
 ! Part of Time Manager F90 API wrapper of C++ implemenation
 !
 ! Defines F90 wrapper entry points for corresponding
-! C++ class { \tt ESMC\_Calendar} implementation
+! C++ class { \tt timelibc\_Calendar} implementation
 !
-! See {\tt ../include/ESMC\_Calendar.h} for complete description
+! See {\tt ../include/timelibc\_Calendar.h} for complete description
 !
 !------------------------------------------------------------------------------
 ! !USES:
-      ! inherit from ESMF base class
-      use ESMF_BaseMod
+      ! inherit from timelib base class
+      use timelib_BaseMod
 
       ! inherit from base time class
-      use ESMF_BaseTimeMod
+      use timelib_BaseTimeMod
 
       implicit none
 !
@@ -59,43 +59,43 @@
       INTEGER, DIMENSION(366) :: daymleap
       INTEGER :: mdaycum(0:MONTHS_PER_YEAR)
       INTEGER :: mdayleapcum(0:MONTHS_PER_YEAR)
-      TYPE(ESMF_BaseTime), TARGET :: monthbdys(0:MONTHS_PER_YEAR)
-      TYPE(ESMF_BaseTime), TARGET :: monthbdysleap(0:MONTHS_PER_YEAR)
+      TYPE(timelib_BaseTime), TARGET :: monthbdys(0:MONTHS_PER_YEAR)
+      TYPE(timelib_BaseTime), TARGET :: monthbdysleap(0:MONTHS_PER_YEAR)
 
 
 !------------------------------------------------------------------------------
-!     ! ESMF_CalendarType
+!     ! timelib_CalendarType
 !
-!     ! F90 "enum" type to match C++ ESMC_CalendarType enum
+!     ! F90 "enum" type to match C++ timelibc_CalendarType enum
 
-      type ESMF_CalendarType
+      type timelib_CalendarType
       private
         integer :: caltype
       end type
 
-      type(ESMF_CalendarType), parameter :: &
-                               ESMF_CAL_GREGORIAN =  ESMF_CalendarType(1), &
-                               ESMF_CAL_JULIAN =     ESMF_CalendarType(2), &
+      type(timelib_CalendarType), parameter :: &
+                               timelib_CAL_GREGORIAN =  timelib_CalendarType(1), &
+                               timelib_CAL_JULIAN =     timelib_CalendarType(2), &
                            ! like Gregorian, except Feb always has 28 days
-                               ESMF_CAL_NOLEAP =     ESMF_CalendarType(3), & 
+                               timelib_CAL_NOLEAP =     timelib_CalendarType(3), & 
                            ! 12 months, 30 days each
-                               ESMF_CAL_360DAY =     ESMF_CalendarType(4), & 
+                               timelib_CAL_360DAY =     timelib_CalendarType(4), & 
                            ! user defined
-                               ESMF_CAL_GENERIC =    ESMF_CalendarType(5), &
+                               timelib_CAL_GENERIC =    timelib_CalendarType(5), &
                            ! track base time seconds only
-                               ESMF_CAL_NOCALENDAR = ESMF_CalendarType(6)
+                               timelib_CAL_NOCALENDAR = timelib_CalendarType(6)
 
 !------------------------------------------------------------------------------
-!     ! ESMF_Calendar
+!     ! timelib_Calendar
 !
 !     ! F90 class type to match C++ Calendar class in size only;
 !     !  all dereferencing within class is performed by C++ implementation
 !
 !------------------------------------------------------------------------------
 !
-!     ! ESMF_DaysPerYear
+!     ! timelib_DaysPerYear
 !
-      type ESMF_DaysPerYear
+      type timelib_DaysPerYear
       private
         integer :: D        ! whole days per year
 ! Fractional days-per-year are not yet used in this implementation.  
@@ -104,12 +104,12 @@
       end type              ! e.g. for Venus, D=0, Dn=926, Dd=1000
 !
 !------------------------------------------------------------------------------
-!     ! ESMF_Calendar
+!     ! timelib_Calendar
 !
 !
-      type ESMF_Calendar
+      type timelib_Calendar
       private
-        type(ESMF_CalendarType) :: Type
+        type(timelib_CalendarType) :: Type
 ! TBH:  When NO_DT_COMPONENT_INIT is set, code that uses F95 compile-time 
 ! TBH:  initialization of components of derived types is not included.  
 ! TBH:  Some older compilers, like PGI 5.x do not support this F95 feature.  
@@ -121,12 +121,12 @@
         integer, dimension(MONTHS_PER_YEAR) :: DaysPerMonth
         integer :: SecondsPerDay
         integer :: SecondsPerYear
-        type(ESMF_DaysPerYear) :: DaysPerYear
+        type(timelib_DaysPerYear) :: DaysPerYear
       end type
 
 !------------------------------------------------------------------------------
 ! !PUBLIC DATA:
-   TYPE(ESMF_Calendar), public, save, pointer :: defaultCal   ! Default Calendar
+   TYPE(timelib_Calendar), public, save, pointer :: defaultCal   ! Default Calendar
 
 
 !
@@ -141,22 +141,22 @@
       public daymleap
       public mdaycum
       public mdayleapcum
-      public ESMF_CalendarType
-      public ESMF_CAL_GREGORIAN, ESMF_CAL_NOLEAP, &
-             ESMF_CAL_360DAY, ESMF_CAL_NOCALENDAR
-!      public ESMF_CAL_JULIAN
-!      public ESMF_CAL_GENERIC
-      public ESMF_Calendar
+      public timelib_CalendarType
+      public timelib_CAL_GREGORIAN, timelib_CAL_NOLEAP, &
+             timelib_CAL_360DAY, timelib_CAL_NOCALENDAR
+!      public timelib_CAL_JULIAN
+!      public timelib_CAL_GENERIC
+      public timelib_Calendar
 
 !------------------------------------------------------------------------------
 !
 ! !PUBLIC MEMBER FUNCTIONS:
-      public ESMF_CalendarCreate
+      public timelib_CalendarCreate
 
-! Required inherited and overridden ESMF_Base class methods
+! Required inherited and overridden timelib_Base class methods
 
-      public ESMF_CalendarInitialized ! Only in this implementation, intended
-                                      ! to be private within ESMF methods
+      public timelib_CalendarInitialized ! Only in this implementation, intended
+                                      ! to be private within timelib methods
 !EOPI
 
 !==============================================================================
@@ -166,26 +166,26 @@
 
 !==============================================================================
 !BOP
-! !IROUTINE: ESMF_CalendarCreate - Create a new ESMF Calendar of built-in type
+! !IROUTINE: timelib_CalendarCreate - Create a new timelib Calendar of built-in type
 
 ! !INTERFACE:
-      ! Private name; call using ESMF_CalendarCreate()
-      function ESMF_CalendarCreate(name, calendartype, rc)
+      ! Private name; call using timelib_CalendarCreate()
+      function timelib_CalendarCreate(name, calendartype, rc)
 
 ! !RETURN VALUE:
-      type(ESMF_Calendar) :: ESMF_CalendarCreate
+      type(timelib_Calendar) :: timelib_CalendarCreate
 
 ! !ARGUMENTS:
       character (len=*),       intent(in),  optional :: name
-      type(ESMF_CalendarType), intent(in)            :: calendartype
+      type(timelib_CalendarType), intent(in)            :: calendartype
       integer,                 intent(out), optional :: rc
 
 ! !DESCRIPTION:
 !     Creates and sets a {\tt calendar} to the given built-in
-!     {\tt ESMF\_CalendarType}. 
+!     {\tt timelib\_CalendarType}. 
 !
 !     This is a private method; invoke via the public overloaded entry point
-!     {\tt ESMF\_CalendarCreate()}.
+!     {\tt timelib\_CalendarCreate()}.
 !
 !     The arguments are:
 !     \begin{description}
@@ -194,42 +194,42 @@
 !          default unique name will be generated: "CalendarNNN" where NNN
 !          is a unique sequence number from 001 to 999.
 !     \item[calendartype]
-!          The built-in {\tt ESMF\_CalendarType}.  Valid values are:
-!            {\tt ESMF\_CAL\_360DAY}, {\tt ESMF\_CAL\_GREGORIAN},
-!            {\tt ESMF\_CAL\_JULIANDAY}, {\tt ESMF\_CAL\_NOCALENDAR}, and
-!            {\tt ESMF\_CAL\_NOLEAP}.
+!          The built-in {\tt timelib\_CalendarType}.  Valid values are:
+!            {\tt timelib\_CAL\_360DAY}, {\tt timelib\_CAL\_GREGORIAN},
+!            {\tt timelib\_CAL\_JULIANDAY}, {\tt timelib\_CAL\_NOCALENDAR}, and
+!            {\tt timelib\_CAL\_NOLEAP}.
 !          See the "Time Manager Reference" document for a description of
 !          each calendar type.
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !    
 !EOP
 ! !REQUIREMENTS:
 !     TMGn.n.n
-      type(ESMF_DaysPerYear) :: dayspy
+      type(timelib_DaysPerYear) :: dayspy
 
-      if ( present(rc) ) rc = ESMF_FAILURE
-! Calendar type is hard-coded.  Use ESMF library if more flexibility is 
+      if ( present(rc) ) rc = timelib_FAILURE
+! Calendar type is hard-coded.  Use timelib library if more flexibility is 
 ! needed.  
 #ifdef NO_LEAP_CALENDAR
-      if ( calendartype%caltype  /= ESMF_CAL_NOLEAP%caltype ) then
+      if ( calendartype%caltype  /= timelib_CAL_NOLEAP%caltype ) then
          write(6,*) 'Not a valid calendar type for this implementation'
-         write(6,*) 'This implementation only allows ESMF_CAL_NOLEAP'
+         write(6,*) 'This implementation only allows timelib_CAL_NOLEAP'
          write(6,*) 'calender type set to     = ', calendartype%caltype
-         write(6,*) 'NO_LEAP calendar type is = ', ESMF_CAL_NOLEAP%caltype
+         write(6,*) 'NO_LEAP calendar type is = ', timelib_CAL_NOLEAP%caltype
          return
       end if
-      ESMF_CalendarCreate%Type = ESMF_CAL_NOLEAP
+      timelib_CalendarCreate%Type = timelib_CAL_NOLEAP
 #else
-      if ( calendartype%caltype  /= ESMF_CAL_GREGORIAN%caltype ) then
+      if ( calendartype%caltype  /= timelib_CAL_GREGORIAN%caltype ) then
          write(6,*) 'Not a valid calendar type for this implementation'
-         write(6,*) 'This implementation only allows ESMF_CAL_GREGORIAN'
+         write(6,*) 'This implementation only allows timelib_CAL_GREGORIAN'
          write(6,*) 'calender type set to     = ', calendartype%caltype
-         write(6,*) 'GREGORIAN calendar type is = ', ESMF_CAL_GREGORIAN%caltype
+         write(6,*) 'GREGORIAN calendar type is = ', timelib_CAL_GREGORIAN%caltype
          return
       end if
-      ESMF_CalendarCreate%Type = ESMF_CAL_GREGORIAN
+      timelib_CalendarCreate%Type = timelib_CAL_GREGORIAN
 #endif
 ! This is a bug on some systems -- need initial value set by compiler at 
 ! startup.  
@@ -237,35 +237,35 @@
 ! initialization of data members of Fortran derived data types.  For example, 
 ! PGI 5.x compilers do not support this F95 feature.  See 
 ! NO_DT_COMPONENT_INIT.  
-      ESMF_CalendarCreate%Set = .true.
-      ESMF_CalendarCreate%SecondsPerDay = SECONDS_PER_DAY
+      timelib_CalendarCreate%Set = .true.
+      timelib_CalendarCreate%SecondsPerDay = SECONDS_PER_DAY
 ! DaysPerYear and SecondsPerYear are incorrect for Gregorian calendars...  
       dayspy%D = size(daym)
 !TBH:  TODO:  Replace DaysPerYear and SecondsPerYear with methods 
 !TBH:  TODO:  since they only make sense for the NO_LEAP calendar!  
-      ESMF_CalendarCreate%DaysPerYear = dayspy
-      ESMF_CalendarCreate%SecondsPerYear = ESMF_CalendarCreate%SecondsPerDay &
+      timelib_CalendarCreate%DaysPerYear = dayspy
+      timelib_CalendarCreate%SecondsPerYear = timelib_CalendarCreate%SecondsPerDay &
                                        * dayspy%D
 !TBH:  TODO:  use mdayleap for leap-year calendar
-      ESMF_CalendarCreate%DaysPerMonth(:) = mday(:)
+      timelib_CalendarCreate%DaysPerMonth(:) = mday(:)
 
-      if ( present(rc) ) rc = ESMF_SUCCESS
+      if ( present(rc) ) rc = timelib_SUCCESS
 
-      end function ESMF_CalendarCreate
+      end function timelib_CalendarCreate
 
 
 !==============================================================================
 !BOP
-! !IROUTINE: ESMF_CalendarInitialized - check if calendar was created
+! !IROUTINE: timelib_CalendarInitialized - check if calendar was created
 
 ! !INTERFACE:
-      function ESMF_CalendarInitialized(calendar)
+      function timelib_CalendarInitialized(calendar)
 
 ! !RETURN VALUE:
-      logical ESMF_CalendarInitialized
+      logical timelib_CalendarInitialized
 
 ! !ARGUMENTS:
-      type(ESMF_Calendar), intent(in)            :: calendar
+      type(timelib_Calendar), intent(in)            :: calendar
 
 ! !DESCRIPTION:
 !EOP
@@ -277,8 +277,8 @@
 ! feature.  At the moment, the call to this fuction is #ifdefd out when the 
 ! leap-year calendar is used so this is not an issue for WRF (see 
 ! NO_DT_COMPONENT_INIT).  
-        ESMF_CalendarInitialized = calendar%set
+        timelib_CalendarInitialized = calendar%set
 
-     end function ESMF_CalendarInitialized
+     end function timelib_CalendarInitialized
 
-      end module ESMF_CalendarMod
+      end module timelib_CalendarMod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Clock.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_Clock.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_Clock.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Clock.F90	2017-07-03 16:17:29.681474000 -0400
@@ -9,8 +9,8 @@
 !
 !==============================================================================
 !
-!     ESMF Clock Module
-      module ESMF_ClockMod
+!     timelib Clock Module
+      module timelib_ClockMod
 !     
 !==============================================================================
 !     
@@ -18,30 +18,30 @@
 !     
 !------------------------------------------------------------------------------
 ! INCLUDES
-#include <ESMF_TimeMgr.inc> 
+#include <timelib_TimeMgr.inc> 
 
 !==============================================================================
 !BOPI
-! !MODULE: ESMF_ClockMod
+! !MODULE: timelib_ClockMod
 !     
 ! !DESCRIPTION:
 ! Part of Time Manager F90 API wrapper of C++ implemenation
 !
 ! Defines F90 wrapper entry points for corresponding
-! C++ class {\tt ESMC\_Time} implementation
+! C++ class {\tt timelibc\_Time} implementation
 !     
-! See {\tt ../include/ESMC\_Clock.h} for complete description
+! See {\tt ../include/timelibc\_Clock.h} for complete description
 !
 !------------------------------------------------------------------------------
 ! !USES:
-      ! inherit from ESMF base class
-      use ESMF_BaseMod
+      ! inherit from timelib base class
+      use timelib_BaseMod
 
       ! associated derived types
-      use ESMF_TimeIntervalMod   ! , only : ESMF_TimeInterval, &
-                                 !          ESMF_TimeIntervalIsPositive
-      use ESMF_TimeMod           ! , only : ESMF_Time
-      use ESMF_AlarmMod,        only : ESMF_Alarm
+      use timelib_TimeIntervalMod   ! , only : timelib_TimeInterval, &
+                                 !          timelib_TimeIntervalIsPositive
+      use timelib_TimeMod           ! , only : timelib_Time
+      use timelib_AlarmMod,        only : timelib_Alarm
 
       implicit none
 !
@@ -49,78 +49,78 @@
 ! !PRIVATE TYPES:
       private
 !------------------------------------------------------------------------------
-!     ! ESMF_Clock
+!     ! timelib_Clock
 !     
 !     ! F90 class type to match C++ Clock class in size only;
 !     !  all dereferencing within class is performed by C++ implementation
 
-! internals for ESMF_Clock
-      type ESMF_ClockInt
-        type(ESMF_TimeInterval) :: TimeStep
-        type(ESMF_Time)  :: StartTime
-        type(ESMF_Time)  :: StopTime
-        type(ESMF_Time)  :: RefTime
-        type(ESMF_Time)  :: CurrTime
-        type(ESMF_Time)  :: PrevTime
-        integer(ESMF_KIND_I8) :: AdvanceCount
+! internals for timelib_Clock
+      type timelib_ClockInt
+        type(timelib_TimeInterval) :: TimeStep
+        type(timelib_Time)  :: StartTime
+        type(timelib_Time)  :: StopTime
+        type(timelib_Time)  :: RefTime
+        type(timelib_Time)  :: CurrTime
+        type(timelib_Time)  :: PrevTime
+        integer(timelib_KIND_I8) :: AdvanceCount
         integer :: ClockMutex
         integer :: NumAlarms
-        ! Note:  to mimic ESMF 2.1.0+, AlarmList is maintained 
-        ! within ESMF_Clock even though copies of each alarm are 
-        ! returned from ESMF_AlarmCreate() at the same time they 
+        ! Note:  to mimic timelib 2.1.0+, AlarmList is maintained 
+        ! within timelib_Clock even though copies of each alarm are 
+        ! returned from timelib_AlarmCreate() at the same time they 
         ! are copied into the AlarmList!  This duplication is not 
-        ! as hideous as it might be because the ESMF_Alarm type 
+        ! as hideous as it might be because the timelib_Alarm type 
         ! has data members that are all POINTERs (thus the horrible 
         ! shallow-copy-masquerading-as-reference-copy hack works).  
-        type(ESMF_Alarm), pointer, dimension(:) :: AlarmList
+        type(timelib_Alarm), pointer, dimension(:) :: AlarmList
       end type
 
-! Actual public type:  this bit allows easy mimic of "deep" ESMF_ClockCreate 
-! in ESMF 2.1.0+
-! NOTE:  DO NOT ADD NON-POINTER STATE TO THIS DATA TYPE.  It emulates ESMF 
+! Actual public type:  this bit allows easy mimic of "deep" timelib_ClockCreate 
+! in timelib 2.1.0+
+! NOTE:  DO NOT ADD NON-POINTER STATE TO THIS DATA TYPE.  It emulates timelib 
 !        shallow-copy-masquerading-as-reference-copy.  
-      type ESMF_Clock
-        type(ESMF_ClockInt), pointer  :: clockint
+      type timelib_Clock
+        type(timelib_ClockInt), pointer  :: clockint
       end type
 
 !------------------------------------------------------------------------------
 ! !PUBLIC TYPES:
-      public ESMF_Clock
-      public ESMF_ClockInt   ! needed on AIX but not PGI
+      public timelib_Clock
+      public timelib_ClockInt   ! needed on AIX but not PGI
 !------------------------------------------------------------------------------
 !
 ! !PUBLIC MEMBER FUNCTIONS:
-      public ESMF_ClockCreate
-      public ESMF_ClockDestroy
-      public ESMF_ClockSet
-!      public ESMF_ClockSetOLD
-      public ESMF_ClockGet
-!      public ESMF_ClockGetAdvanceCount
-!      public ESMF_ClockGetTimeStep
-!      public ESMF_ClockSetTimeStep
-!      public ESMF_ClockGetCurrTime
-!      public ESMF_ClockSetCurrTime
-!      public ESMF_ClockGetStartTime
-!      public ESMF_ClockGetStopTime
-!      public ESMF_ClockGetRefTime
-!      public ESMF_ClockGetPrevTime
-!      public ESMF_ClockGetCurrSimTime
-!      public ESMF_ClockGetPrevSimTime
-! This must be public for ESMF_AlarmClockMod...  
-      public ESMF_ClockAddAlarm
-      public ESMF_ClockGetAlarmList
-!      public ESMF_ClockGetNumAlarms
-!      public ESMF_ClockSyncToWallClock
-      public ESMF_ClockAdvance
-      public ESMF_ClockIsStopTime
-      public ESMF_ClockStopTimeDisable
-
-! Required inherited and overridden ESMF_Base class methods
-
-!      public ESMF_ClockRead
-!      public ESMF_ClockWrite
-      public ESMF_ClockValidate
-      public ESMF_ClockPrint
+      public timelib_ClockCreate
+      public timelib_ClockDestroy
+      public timelib_ClockSet
+!      public timelib_ClockSetOLD
+      public timelib_ClockGet
+!      public timelib_ClockGetAdvanceCount
+!      public timelib_ClockGetTimeStep
+!      public timelib_ClockSetTimeStep
+!      public timelib_ClockGetCurrTime
+!      public timelib_ClockSetCurrTime
+!      public timelib_ClockGetStartTime
+!      public timelib_ClockGetStopTime
+!      public timelib_ClockGetRefTime
+!      public timelib_ClockGetPrevTime
+!      public timelib_ClockGetCurrSimTime
+!      public timelib_ClockGetPrevSimTime
+! This must be public for timelib_AlarmClockMod...  
+      public timelib_ClockAddAlarm
+      public timelib_ClockGetAlarmList
+!      public timelib_ClockGetNumAlarms
+!      public timelib_ClockSyncToWallClock
+      public timelib_ClockAdvance
+      public timelib_ClockIsStopTime
+      public timelib_ClockStopTimeDisable
+
+! Required inherited and overridden timelib_Base class methods
+
+!      public timelib_ClockRead
+!      public timelib_ClockWrite
+      public timelib_ClockValidate
+      public timelib_ClockPrint
 !EOPI
 
 !==============================================================================
@@ -133,39 +133,39 @@
 !
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockSetOLD - Initialize a clockint
+! !IROUTINE: timelib_ClockSetOLD - Initialize a clockint
 
 ! !INTERFACE:
-      subroutine ESMF_ClockSetOLD(clockint, TimeStep, StartTime, &
+      subroutine timelib_ClockSetOLD(clockint, TimeStep, StartTime, &
                                   StopTime, RefTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_ClockInt), intent(out) :: clockint
-      type(ESMF_TimeInterval), intent(in), optional :: TimeStep
-      type(ESMF_Time), intent(in) :: StartTime
-      type(ESMF_Time), intent(in) :: StopTime
-      type(ESMF_Time), intent(in), optional :: RefTime
+      type(timelib_ClockInt), intent(out) :: clockint
+      type(timelib_TimeInterval), intent(in), optional :: TimeStep
+      type(timelib_Time), intent(in) :: StartTime
+      type(timelib_Time), intent(in) :: StopTime
+      type(timelib_Time), intent(in), optional :: RefTime
       integer, intent(out), optional :: rc
 ! Local
       integer i
     
 ! !DESCRIPTION:
-!     Initialize an {\tt ESMF\_Clock}
+!     Initialize an {\tt timelib\_Clock}
 !     
 !     The arguments are:
 !     \begin{description}
 !     \item[clockint]
 !          The object instance to initialize
 !     \item[{[TimeStep]}]
-!          The {\tt ESMF\_Clock}'s time step interval
+!          The {\tt timelib\_Clock}'s time step interval
 !     \item[StartTime]
-!          The {\tt ESMF\_Clock}'s starting time
+!          The {\tt timelib\_Clock}'s starting time
 !     \item[StopTime]
-!          The {\tt ESMF\_Clock}'s stopping time
+!          The {\tt timelib\_Clock}'s stopping time
 !     \item[{[RefTime]}]
-!          The {\tt ESMF\_Clock}'s reference time
+!          The {\tt timelib\_Clock}'s reference time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !     
 ! !REQUIREMENTS:
@@ -183,130 +183,130 @@
       clockint%NumAlarms = 0
       clockint%AdvanceCount = 0
       ALLOCATE(clockint%AlarmList(MAX_ALARMS))
-      ! TBH:  This incredible hack can be removed once ESMF_*Validate() 
-      ! TBH:  can tell if a deep ESMF_* was created or not.  
+      ! TBH:  This incredible hack can be removed once timelib_*Validate() 
+      ! TBH:  can tell if a deep timelib_* was created or not.  
       DO i = 1, MAX_ALARMS
         NULLIFY( clockint%AlarmList( i )%alarmint )
       ENDDO
-      IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+      IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
     
-      end subroutine ESMF_ClockSetOLD
+      end subroutine timelib_ClockSetOLD
 
 
-! !IROUTINE: ESMF_ClockSet - Set clock properties -- for compatibility with ESMF 2.0.1
+! !IROUTINE: timelib_ClockSet - Set clock properties -- for compatibility with timelib 2.0.1
 
 ! !INTERFACE:
-      subroutine ESMF_ClockSet(clock, TimeStep, StartTime, StopTime, &
+      subroutine timelib_ClockSet(clock, TimeStep, StartTime, StopTime, &
                                RefTime, CurrTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(inout) :: clock
-      type(ESMF_TimeInterval), intent(in), optional :: TimeStep
-      type(ESMF_Time), intent(in), optional :: StartTime
-      type(ESMF_Time), intent(in), optional :: StopTime
-      type(ESMF_Time), intent(in), optional :: RefTime
-      type(ESMF_Time), intent(in), optional :: CurrTime
+      type(timelib_Clock), intent(inout) :: clock
+      type(timelib_TimeInterval), intent(in), optional :: TimeStep
+      type(timelib_Time), intent(in), optional :: StartTime
+      type(timelib_Time), intent(in), optional :: StopTime
+      type(timelib_Time), intent(in), optional :: RefTime
+      type(timelib_Time), intent(in), optional :: CurrTime
       integer, intent(out), optional :: rc
 ! Local
       integer ierr
     
 ! !DESCRIPTION:
-!     Initialize an {\tt ESMF\_Clock}
+!     Initialize an {\tt timelib\_Clock}
 !     
 !     The arguments are:
 !     \begin{description}
 !     \item[clock]
 !          The object instance to initialize
 !     \item[{[TimeStep]}]
-!          The {\tt ESMF\_Clock}'s time step interval
+!          The {\tt timelib\_Clock}'s time step interval
 !     \item[StartTime]
-!          The {\tt ESMF\_Clock}'s starting time
+!          The {\tt timelib\_Clock}'s starting time
 !     \item[StopTime]
-!          The {\tt ESMF\_Clock}'s stopping time
+!          The {\tt timelib\_Clock}'s stopping time
 !     \item[{[RefTime]}]
-!          The {\tt ESMF\_Clock}'s reference time
+!          The {\tt timelib\_Clock}'s reference time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !     
 ! !REQUIREMENTS:
 !     TMG3.1, TMG3.4.4
 !EOP
-      ierr = ESMF_SUCCESS
+      ierr = timelib_SUCCESS
       IF ( PRESENT(TimeStep) ) THEN
-        CALL ESMF_ClockSetTimeStep ( clock, TimeStep, rc=ierr )
+        CALL timelib_ClockSetTimeStep ( clock, TimeStep, rc=ierr )
       ENDIF
       IF ( PRESENT(RefTime) ) clock%clockint%RefTime = RefTime
       IF ( PRESENT(StartTime) ) clock%clockint%StartTime = StartTime
       IF ( PRESENT(StopTime) ) clock%clockint%StopTime = StopTime
       IF ( PRESENT(CurrTime) ) THEN
-        CALL ESMF_ClockSetCurrTime(clock, CurrTime, rc=ierr)
+        CALL timelib_ClockSetCurrTime(clock, CurrTime, rc=ierr)
       ENDIF
       IF ( PRESENT(rc) ) rc = ierr
 
-      end subroutine ESMF_ClockSet
+      end subroutine timelib_ClockSet
 
 
-! Create ESMF_Clock using ESMF 2.1.0+ semantics
-      FUNCTION ESMF_ClockCreate( name, TimeStep, StartTime, StopTime, &
+! Create timelib_Clock using timelib 2.1.0+ semantics
+      FUNCTION timelib_ClockCreate( name, TimeStep, StartTime, StopTime, &
                                  RefTime, rc )
         ! return value
-        type(ESMF_Clock) :: ESMF_ClockCreate
+        type(timelib_Clock) :: timelib_ClockCreate
         ! !ARGUMENTS:
         character (len=*),       intent(in),  optional :: name
-        type(ESMF_TimeInterval), intent(in), optional :: TimeStep
-        type(ESMF_Time), intent(in) :: StartTime
-        type(ESMF_Time), intent(in) :: StopTime
-        type(ESMF_Time), intent(in), optional :: RefTime
+        type(timelib_TimeInterval), intent(in), optional :: TimeStep
+        type(timelib_Time), intent(in) :: StartTime
+        type(timelib_Time), intent(in) :: StopTime
+        type(timelib_Time), intent(in), optional :: RefTime
         integer, intent(out), optional :: rc
         ! locals
-        type(ESMF_Clock) :: clocktmp
+        type(timelib_Clock) :: clocktmp
          ! TBH:  ignore allocate errors, for now
         ALLOCATE( clocktmp%clockint )
-        CALL ESMF_ClockSetOLD( clocktmp%clockint,   &
+        CALL timelib_ClockSetOLD( clocktmp%clockint,   &
                                TimeStep= TimeStep,  &
                                StartTime=StartTime, &
                                StopTime= StopTime,  &
                                RefTime=RefTime, rc=rc )
-        ESMF_ClockCreate = clocktmp
-      END FUNCTION ESMF_ClockCreate
+        timelib_ClockCreate = clocktmp
+      END FUNCTION timelib_ClockCreate
 
 
-! Deallocate memory for ESMF_Clock
-      SUBROUTINE ESMF_ClockDestroy( clock, rc )
-         TYPE(ESMF_Clock), INTENT(INOUT) :: clock
+! Deallocate memory for timelib_Clock
+      SUBROUTINE timelib_ClockDestroy( clock, rc )
+         TYPE(timelib_Clock), INTENT(INOUT) :: clock
          INTEGER,          INTENT(  OUT), OPTIONAL :: rc
          ! TBH:  ignore deallocate errors, for now
          DEALLOCATE( clock%clockint%AlarmList )
          DEALLOCATE( clock%clockint )
-         IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
-      END SUBROUTINE ESMF_ClockDestroy
+         IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
+      END SUBROUTINE timelib_ClockDestroy
 
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGet - Get clock properties -- for compatibility with ESMF 2.0.1 
+! !IROUTINE: timelib_ClockGet - Get clock properties -- for compatibility with timelib 2.0.1 
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGet(clock, StartTime, CurrTime,       &
+      subroutine timelib_ClockGet(clock, StartTime, CurrTime,       &
                                AdvanceCount, StopTime, TimeStep, &
                                PrevTime, RefTime, &
                                rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_Time), intent(out), optional :: StartTime
-      type(ESMF_Time), intent(out), optional :: CurrTime
-      type(ESMF_Time), intent(out), optional :: StopTime
-      type(ESMF_Time), intent(out), optional :: PrevTime
-      type(ESMF_Time), intent(out), optional :: RefTime
-      integer(ESMF_KIND_I8), intent(out), optional :: AdvanceCount
-      type(ESMF_TimeInterval), intent(out), optional :: TimeStep
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_Time), intent(out), optional :: StartTime
+      type(timelib_Time), intent(out), optional :: CurrTime
+      type(timelib_Time), intent(out), optional :: StopTime
+      type(timelib_Time), intent(out), optional :: PrevTime
+      type(timelib_Time), intent(out), optional :: RefTime
+      integer(timelib_KIND_I8), intent(out), optional :: AdvanceCount
+      type(timelib_TimeInterval), intent(out), optional :: TimeStep
       integer, intent(out), optional :: rc
       integer :: ierr
 
 ! !DESCRIPTION:
-!     Returns the number of times the {\tt ESMF\_Clock} has been advanced
+!     Returns the number of times the {\tt timelib\_Clock} has been advanced
 !     (time stepped)
 !
 !     The arguments are:
@@ -318,65 +318,65 @@
 !     \item[CurrTime]
 !          The current time
 !     \item[AdvanceCount]
-!          The number of times the {\tt ESMF\_Clock} has been advanced
+!          The number of times the {\tt timelib\_Clock} has been advanced
 !     \item[StopTime]
-!          The {\tt ESMF\_Clock}'s stopping time
+!          The {\tt timelib\_Clock}'s stopping time
 !     \item[{[TimeStep]}]
-!          The {\tt ESMF\_Clock}'s time step interval
+!          The {\tt timelib\_Clock}'s time step interval
 !     \item[{[PrevTime]}]
-!          The {\tt ESMF\_Clock}'s previous current time
+!          The {\tt timelib\_Clock}'s previous current time
 !     \item[{[PrevTime]}]
-!          The {\tt ESMF\_Clock}'s reference time
+!          The {\tt timelib\_Clock}'s reference time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
 !     TMG3.5.1
 !EOP
-      ierr = ESMF_SUCCESS
+      ierr = timelib_SUCCESS
 
       IF ( PRESENT (StartTime) ) THEN
-        CALL ESMF_ClockGetStartTime( clock, StartTime=StartTime, rc=ierr )
+        CALL timelib_ClockGetStartTime( clock, StartTime=StartTime, rc=ierr )
       ENDIF
       IF ( PRESENT (CurrTime) ) THEN
-        CALL ESMF_ClockGetCurrTime( clock , CurrTime, ierr )
+        CALL timelib_ClockGetCurrTime( clock , CurrTime, ierr )
       ENDIF
       IF ( PRESENT (StopTime) ) THEN
-        CALL ESMF_ClockGetStopTime( clock , StopTime, ierr )
+        CALL timelib_ClockGetStopTime( clock , StopTime, ierr )
       ENDIF
       IF ( PRESENT (AdvanceCount) ) THEN
-        CALL ESMF_ClockGetAdvanceCount(clock, AdvanceCount, ierr)
+        CALL timelib_ClockGetAdvanceCount(clock, AdvanceCount, ierr)
       ENDIF
       IF ( PRESENT (TimeStep) ) THEN
-        CALL ESMF_ClockGetTimeStep(clock, TimeStep, ierr)
+        CALL timelib_ClockGetTimeStep(clock, TimeStep, ierr)
       ENDIF
       IF ( PRESENT (PrevTime) ) THEN
-        CALL ESMF_ClockGetPrevTime(clock, PrevTime, ierr)
+        CALL timelib_ClockGetPrevTime(clock, PrevTime, ierr)
       ENDIF
       IF ( PRESENT (RefTime) ) THEN
-        CALL ESMF_ClockGetRefTime(clock, RefTime, ierr)
+        CALL timelib_ClockGetRefTime(clock, RefTime, ierr)
       ENDIF
 
       IF ( PRESENT (rc) ) THEN
         rc = ierr
       ENDIF
     
-      end subroutine ESMF_ClockGet
+      end subroutine timelib_ClockGet
 
 
-! !IROUTINE: ESMF_ClockGetAdvanceCount - Get the clock's advance count
+! !IROUTINE: timelib_ClockGetAdvanceCount - Get the clock's advance count
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetAdvanceCount(clock, AdvanceCount, rc)
+      subroutine timelib_ClockGetAdvanceCount(clock, AdvanceCount, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      integer(ESMF_KIND_I8), intent(out) :: AdvanceCount
+      type(timelib_Clock), intent(in) :: clock
+      integer(timelib_KIND_I8), intent(out) :: AdvanceCount
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Returns the number of times the {\tt ESMF\_Clock} has been advanced
+!     Returns the number of times the {\tt timelib\_Clock} has been advanced
 !     (time stepped)
 !
 !     The arguments are:
@@ -384,9 +384,9 @@
 !     \item[clock]
 !          The object instance to get the advance count from
 !     \item[AdvanceCount]
-!          The number of times the {\tt ESMF\_Clock} has been advanced
+!          The number of times the {\tt timelib\_Clock} has been advanced
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
@@ -395,24 +395,24 @@
 
       AdvanceCount = clock%clockint%AdvanceCount
 
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
     
-      end subroutine ESMF_ClockGetAdvanceCount
+      end subroutine timelib_ClockGetAdvanceCount
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetTimeStep - Get a clock's timestep interval
+! !IROUTINE: timelib_ClockGetTimeStep - Get a clock's timestep interval
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetTimeStep(clock, TimeStep, rc)
+      subroutine timelib_ClockGetTimeStep(clock, TimeStep, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_TimeInterval), intent(out) :: TimeStep
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_TimeInterval), intent(out) :: TimeStep
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s timestep interval
+!     Get an {\tt timelib\_Clock}'s timestep interval
 !
 !     The arguments are:
 !     \begin{description}
@@ -421,7 +421,7 @@
 !     \item[TimeStep]
 !          The time step
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -429,24 +429,24 @@
 !EOP
 
       TimeStep = clock%clockint%TimeStep
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
     
-      end subroutine ESMF_ClockGetTimeStep
+      end subroutine timelib_ClockGetTimeStep
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockSetTimeStep - Set a clock's timestep interval
+! !IROUTINE: timelib_ClockSetTimeStep - Set a clock's timestep interval
 
 ! !INTERFACE:
-      subroutine ESMF_ClockSetTimeStep(clock, TimeStep, rc)
+      subroutine timelib_ClockSetTimeStep(clock, TimeStep, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(inout) :: clock  ! really INTENT(OUT)
-      type(ESMF_TimeInterval), intent(in) :: TimeStep
+      type(timelib_Clock), intent(inout) :: clock  ! really INTENT(OUT)
+      type(timelib_TimeInterval), intent(in) :: TimeStep
       integer, intent(out), optional      :: rc
 
 ! !DESCRIPTION:
-!     Set an {\tt ESMF\_Clock}'s timestep interval
+!     Set an {\tt timelib\_Clock}'s timestep interval
 !
 !     The arguments are:
 !     \begin{description}
@@ -455,7 +455,7 @@
 !     \item[TimeStep]
 !          The time step
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -463,24 +463,24 @@
 !EOP
 
       clock%clockint%TimeStep = TimeStep
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
 
-      end subroutine ESMF_ClockSetTimeStep
+      end subroutine timelib_ClockSetTimeStep
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetCurrTime - Get a clock's current time
+! !IROUTINE: timelib_ClockGetCurrTime - Get a clock's current time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetCurrTime(clock, CurrTime, rc)
+      subroutine timelib_ClockGetCurrTime(clock, CurrTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_Time), intent(out) :: CurrTime
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_Time), intent(out) :: CurrTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s current time     
+!     Get an {\tt timelib\_Clock}'s current time     
 !
 !     The arguments are:
 !     \begin{description}
@@ -489,7 +489,7 @@
 !     \item[CurrTime]
 !          The current time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -497,23 +497,23 @@
 !EOP
 
       CurrTime = clock%clockint%CurrTime
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
-      end subroutine ESMF_ClockGetCurrTime
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
+      end subroutine timelib_ClockGetCurrTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockSetCurrTime - Set a clock's current time
+! !IROUTINE: timelib_ClockSetCurrTime - Set a clock's current time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockSetCurrTime(clock, CurrTime, rc)
+      subroutine timelib_ClockSetCurrTime(clock, CurrTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(inout) :: clock  ! really INTENT(OUT)
-      type(ESMF_Time), intent(in) :: CurrTime
+      type(timelib_Clock), intent(inout) :: clock  ! really INTENT(OUT)
+      type(timelib_Time), intent(in) :: CurrTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Set an {\tt ESMF\_Clock}'s current time
+!     Set an {\tt timelib\_Clock}'s current time
 !
 !     The arguments are:
 !     \begin{description}
@@ -522,7 +522,7 @@
 !     \item[CurrTime]
 !          The current time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -530,24 +530,24 @@
 !EOP
 
       clock%clockint%CurrTime = CurrTime
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
     
-      end subroutine ESMF_ClockSetCurrTime
+      end subroutine timelib_ClockSetCurrTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetStartTime - Get a clock's start time
+! !IROUTINE: timelib_ClockGetStartTime - Get a clock's start time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetStartTime(clock, StartTime, rc)
+      subroutine timelib_ClockGetStartTime(clock, StartTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_Time), intent(out) :: StartTime
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_Time), intent(out) :: StartTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s start time
+!     Get an {\tt timelib\_Clock}'s start time
 !
 !     The arguments are:
 !     \begin{description}
@@ -556,7 +556,7 @@
 !     \item[StartTime]
 !          The start time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -564,24 +564,24 @@
 !EOP
 
       StartTime = clock%clockint%StartTime
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
     
-      end subroutine ESMF_ClockGetStartTime
+      end subroutine timelib_ClockGetStartTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetStopTime - Get a clock's stop time
+! !IROUTINE: timelib_ClockGetStopTime - Get a clock's stop time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetStopTime(clock, StopTime, rc)
+      subroutine timelib_ClockGetStopTime(clock, StopTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_Time), intent(out) :: StopTime
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_Time), intent(out) :: StopTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s stop time
+!     Get an {\tt timelib\_Clock}'s stop time
 ! 
 !     The arguments are:
 !     \begin{description}
@@ -590,7 +590,7 @@
 !     \item[StopTime]
 !          The stop time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -598,24 +598,24 @@
 !EOP
 
       StopTime = clock%clockint%StopTime
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
     
-      end subroutine ESMF_ClockGetStopTime
+      end subroutine timelib_ClockGetStopTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetRefTime - Get a clock's reference time
+! !IROUTINE: timelib_ClockGetRefTime - Get a clock's reference time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetRefTime(clock, RefTime, rc)
+      subroutine timelib_ClockGetRefTime(clock, RefTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_Time), intent(out) :: RefTime
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_Time), intent(out) :: RefTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s reference time
+!     Get an {\tt timelib\_Clock}'s reference time
 !
 !     The arguments are:
 !     \begin{description}
@@ -624,30 +624,30 @@
 !     \item[RefTime]
 !          The reference time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG3.5.3
 !EOP
       refTime = clock%clockint%RefTime
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
-      end subroutine ESMF_ClockGetRefTime
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
+      end subroutine timelib_ClockGetRefTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetPrevTime - Get a clock's previous current time
+! !IROUTINE: timelib_ClockGetPrevTime - Get a clock's previous current time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetPrevTime(clock, PrevTime, rc)
+      subroutine timelib_ClockGetPrevTime(clock, PrevTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_Time), intent(out) :: PrevTime
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_Time), intent(out) :: PrevTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s previous current time
+!     Get an {\tt timelib\_Clock}'s previous current time
 !
 !     The arguments are:
 !     \begin{description}
@@ -656,7 +656,7 @@
 !     \item[PrevTime]
 !          The previous current time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -665,26 +665,26 @@
 
 ! hack for bug in PGI 5.1-x
 !      prevTime = Clock%clockint%CurrTime - Clock%clockint%TimeStep
-      prevTime = ESMF_TimeDec( Clock%clockint%CurrTime, &
+      prevTime = timelib_TimeDec( Clock%clockint%CurrTime, &
                                Clock%clockint%TimeStep )
 
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
-      end subroutine ESMF_ClockGetPrevTime
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
+      end subroutine timelib_ClockGetPrevTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetCurrSimTime - Get a clock's current simulation time
+! !IROUTINE: timelib_ClockGetCurrSimTime - Get a clock's current simulation time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetCurrSimTime(clock, CurrSimTime, rc)
+      subroutine timelib_ClockGetCurrSimTime(clock, CurrSimTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_TimeInterval), intent(out) :: CurrSimTime
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_TimeInterval), intent(out) :: CurrSimTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s current simulation time
+!     Get an {\tt timelib\_Clock}'s current simulation time
 ! 
 !     The arguments are:
 !     \begin{description}
@@ -693,29 +693,29 @@
 !     \item[CurrSimTime]
 !          The current simulation time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG3.5.5
 !EOP
-      CALL wrf_error_fatal( 'ESMF_ClockGetCurrSimTime not supported' )
-      end subroutine ESMF_ClockGetCurrSimTime
+      CALL wrf_error_fatal( 'timelib_ClockGetCurrSimTime not supported' )
+      end subroutine timelib_ClockGetCurrSimTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetPrevSimTime - Get a clock's previous simulation time
+! !IROUTINE: timelib_ClockGetPrevSimTime - Get a clock's previous simulation time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetPrevSimTime(clock, PrevSimTime, rc)
+      subroutine timelib_ClockGetPrevSimTime(clock, PrevSimTime, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_TimeInterval), intent(out) :: PrevSimTime
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_TimeInterval), intent(out) :: PrevSimTime
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s previous simulation time
+!     Get an {\tt timelib\_Clock}'s previous simulation time
 !
 !     The arguments are:
 !     \begin{description}
@@ -724,52 +724,52 @@
 !     \item[PrevSimTime]
 !          The previous simulation time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG3.5.5
 !EOP
-      CALL wrf_error_fatal( 'ESMF_ClockGetPrevSimTime not supported' )
-      end subroutine ESMF_ClockGetPrevSimTime
+      CALL wrf_error_fatal( 'timelib_ClockGetPrevSimTime not supported' )
+      end subroutine timelib_ClockGetPrevSimTime
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockAddAlarm - Add an alarm to a clock's alarm list
+! !IROUTINE: timelib_ClockAddAlarm - Add an alarm to a clock's alarm list
 
 ! !INTERFACE:
-      subroutine ESMF_ClockAddAlarm(clock, Alarm, rc)
+      subroutine timelib_ClockAddAlarm(clock, Alarm, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(inout) :: clock
-      type(ESMF_Alarm), intent(inout) :: Alarm
+      type(timelib_Clock), intent(inout) :: clock
+      type(timelib_Alarm), intent(inout) :: Alarm
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Add an {\tt ESMF\_Alarm} to an {\tt ESMF\_Clock}'s {\tt ESMF\_Alarm} list
+!     Add an {\tt timelib\_Alarm} to an {\tt timelib\_Clock}'s {\tt timelib\_Alarm} list
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[clock]
-!          The object instance to add an {\tt ESMF\_Alarm} to
+!          The object instance to add an {\tt timelib\_Alarm} to
 !     \item[Alarm]
-!          The {\tt ESMF\_Alarm} to add to the {\tt ESMF\_Clock}'s
-!          {\tt ESMF\_Alarm} list
+!          The {\tt timelib\_Alarm} to add to the {\tt timelib\_Clock}'s
+!          {\tt timelib\_Alarm} list
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !   
 ! !REQUIREMENTS:
 !     TMG4.1, TMG4.2
 !EOP
     
-      IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+      IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
       clock%clockint%NumAlarms = clock%clockint%NumAlarms + 1
       IF ( clock%clockint%NumAlarms > SIZE (clock%clockint%AlarmList) ) THEN
-        CALL wrf_error_fatal ( 'ESMF_ClockAddAlarm:  too many alarms' )
+        CALL wrf_error_fatal ( 'timelib_ClockAddAlarm:  too many alarms' )
       ELSE IF ( .NOT. ASSOCIATED( Alarm%alarmint ) ) THEN
         CALL wrf_error_fatal ( &
-               'ESMF_ClockAddAlarm:  alarm not created' )
+               'timelib_ClockAddAlarm:  alarm not created' )
       ELSE
         IF ( Alarm%alarmint%RingTimeSet ) THEN
            Alarm%alarmint%PrevRingTime = Alarm%alarmint%RingTime
@@ -783,35 +783,35 @@
         Alarm%alarmint%Ringing = .FALSE.
 
         ! finally, load the alarm into the list
-! write(0,*)'ESMF_ClockAddAlarm ',clock%clockint%NumAlarms
+! write(0,*)'timelib_ClockAddAlarm ',clock%clockint%NumAlarms
         clock%clockint%AlarmList(clock%clockint%NumAlarms) = Alarm
       ENDIF
     
-      end subroutine ESMF_ClockAddAlarm
+      end subroutine timelib_ClockAddAlarm
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetAlarmList - Get a clock's alarm list
+! !IROUTINE: timelib_ClockGetAlarmList - Get a clock's alarm list
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetAlarmList(clock, AlarmList, rc)
+      subroutine timelib_ClockGetAlarmList(clock, AlarmList, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_Alarm), pointer :: AlarmList(:)
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_Alarm), pointer :: AlarmList(:)
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get an {\tt ESMF\_Clock}'s {\tt ESMF\_Alarm} list     
+!     Get an {\tt timelib\_Clock}'s {\tt timelib\_Alarm} list     
 !   
 !     The arguments are:
 !     \begin{description}
 !     \item[clock]
-!          The object instance to get the {\tt ESMF\_Alarm} list from
+!          The object instance to get the {\tt timelib\_Alarm} list from
 !     \item[AlarmList]
-!          The {\tt ESMF\_Clock}'s {\tt ESMF\_Alarm} list
+!          The {\tt timelib\_Clock}'s {\tt timelib\_Alarm} list
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !   
 ! !REQUIREMENTS:
@@ -819,35 +819,35 @@
 !EOP
 
       AlarmList => clock%clockint%AlarmList
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
 
-      end subroutine ESMF_ClockGetAlarmList
+      end subroutine timelib_ClockGetAlarmList
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockGetNumAlarms - Get the number of alarms in a clock's alarm list
+! !IROUTINE: timelib_ClockGetNumAlarms - Get the number of alarms in a clock's alarm list
 
 ! !INTERFACE:
-      subroutine ESMF_ClockGetNumAlarms(clock, NumAlarms, rc)
+      subroutine timelib_ClockGetNumAlarms(clock, NumAlarms, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
+      type(timelib_Clock), intent(in) :: clock
       integer, intent(out) :: NumAlarms
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Get the number of {\tt ESMF\_Alarm}s in an {\tt ESMF\_Clock}'s
-!       {\tt ESMF\_Alarm} list     
+!     Get the number of {\tt timelib\_Alarm}s in an {\tt timelib\_Clock}'s
+!       {\tt timelib\_Alarm} list     
 !   
 !     The arguments are:
 !     \begin{description}
 !     \item[clock]
-!          The object instance to get the number of {\tt ESMF\_Alarm}s from
+!          The object instance to get the number of {\tt timelib\_Alarm}s from
 !     \item[NumAlarms]
-!          The number of {\tt ESMF\_Alarm}s in the {\tt ESMF\_Clock}'s
-!            {\tt ESMF\_Alarm} list
+!          The number of {\tt timelib\_Alarm}s in the {\tt timelib\_Clock}'s
+!            {\tt timelib\_Alarm} list
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !   
 ! !REQUIREMENTS:
@@ -855,62 +855,62 @@
 !EOP
 
       NumAlarms = clock%clockint%NumAlarms
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
     
-      end subroutine ESMF_ClockGetNumAlarms
+      end subroutine timelib_ClockGetNumAlarms
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockSyncToWallClock - Set clock's current time to wall clock time
+! !IROUTINE: timelib_ClockSyncToWallClock - Set clock's current time to wall clock time
 
 ! !INTERFACE:
-      subroutine ESMF_ClockSyncToWallClock(clock, rc)
+      subroutine timelib_ClockSyncToWallClock(clock, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(inout) :: clock
+      type(timelib_Clock), intent(inout) :: clock
       integer, intent(out), optional :: rc
     
 ! !DESCRIPTION:
-!     Set an {\tt ESMF\_Clock}'s current time to wall clock time     
+!     Set an {\tt timelib\_Clock}'s current time to wall clock time     
 !   
 !     The arguments are:
 !     \begin{description}
 !     \item[clock]
 !          The object instance to synchronize to wall clock time
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !   
 ! !REQUIREMENTS:
 !     TMG3.4.5
 !EOP
-      CALL wrf_error_fatal( 'ESMF_ClockSyncToWallClock not supported' )
-      end subroutine ESMF_ClockSyncToWallClock
+      CALL wrf_error_fatal( 'timelib_ClockSyncToWallClock not supported' )
+      end subroutine timelib_ClockSyncToWallClock
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockAdvance - Advance a clock's current time by one time step
+! !IROUTINE: timelib_ClockAdvance - Advance a clock's current time by one time step
 
 ! !INTERFACE:
-      subroutine ESMF_ClockAdvance(clock, RingingAlarmList, &
+      subroutine timelib_ClockAdvance(clock, RingingAlarmList, &
                                    NumRingingAlarms, rc)
 
-use esmf_timemod
+use timelib_timemod
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(inout) :: clock
-      type(ESMF_Alarm), dimension(MAX_ALARMS), intent(out), optional :: &
+      type(timelib_Clock), intent(inout) :: clock
+      type(timelib_Alarm), dimension(MAX_ALARMS), intent(out), optional :: &
                                         RingingAlarmList
       integer, intent(out), optional :: NumRingingAlarms
       integer, intent(out), optional :: rc
 ! Local
       logical pred1, pred2, pred3
       integer i, n
-      type(ESMF_Alarm) :: alarm
+      type(timelib_Alarm) :: alarm
       logical :: positive_timestep
 !   
 ! !DESCRIPTION:
-!     Advance an {\tt ESMF\_Clock}'s current time by one time step
+!     Advance an {\tt timelib\_Clock}'s current time by one time step
 !  
 !     The arguments are:
 !     \begin{description}
@@ -921,7 +921,7 @@
 !     \item[{[NumRingingAlarms]}]
 !          The number of ringing alarms returned
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !  
 ! !REQUIREMENTS:
@@ -930,9 +930,9 @@
 ! hack for bug in PGI 5.1-x
 !      clock%clockint%CurrTime = clock%clockint%CurrTime + &
 !                                clock%clockint%TimeStep
-      clock%clockint%CurrTime = ESMF_TimeInc( clock%clockint%CurrTime, &
+      clock%clockint%CurrTime = timelib_TimeInc( clock%clockint%CurrTime, &
                                               clock%clockint%TimeStep )
-      positive_timestep = ESMF_TimeIntervalIsPositive( clock%clockint%TimeStep )
+      positive_timestep = timelib_TimeIntervalIsPositive( clock%clockint%TimeStep )
 
       IF ( Present(NumRingingAlarms) ) NumRingingAlarms = 0
       clock%clockint%AdvanceCount = clock%clockint%AdvanceCount + 1
@@ -951,13 +951,13 @@
                 IF ( positive_timestep ) THEN
 ! hack for bug in PGI 5.1-x
 !                  PRED1 = clock%clockint%CurrTime > alarm%alarmint%StopTime
-                  PRED1 = ESMF_TimeGT( clock%clockint%CurrTime, &
+                  PRED1 = timelib_TimeGT( clock%clockint%CurrTime, &
                                        alarm%alarmint%StopTime )
                 ELSE
                   ! in this case time step is negative and stop time is 
                   ! less than start time
 !                  PRED1 = clock%clockint%CurrTime < alarm%alarmint%StopTime
-                  PRED1 = ESMF_TimeLT( clock%clockint%CurrTime, &
+                  PRED1 = timelib_TimeLT( clock%clockint%CurrTime, &
                                        alarm%alarmint%StopTime )
                 ENDIF
               ENDIF
@@ -972,10 +972,10 @@
 !                   PRED2 = ( alarm%alarmint%RingTime <= clock%clockint%CurrTime     &
 !                          .AND. clock%clockint%CurrTime < alarm%alarmint%RingTime + &
 !                                clock%clockint%TimeStep )
-                   PRED2 = ( ESMF_TimeLE( alarm%alarmint%RingTime,       &
+                   PRED2 = ( timelib_TimeLE( alarm%alarmint%RingTime,       &
                                           clock%clockint%CurrTime )      &
-                             .AND. ESMF_TimeLT( clock%clockint%CurrTime, &
-                               ESMF_TimeInc( alarm%alarmint%RingTime,    &
+                             .AND. timelib_TimeLT( clock%clockint%CurrTime, &
+                               timelib_TimeInc( alarm%alarmint%RingTime,    &
                                              clock%clockint%TimeStep ) ) )
                 ELSE
                   ! in this case time step is negative and stop time is 
@@ -984,10 +984,10 @@
 !                   PRED2 = ( alarm%alarmint%RingTime >= clock%clockint%CurrTime     &
 !                          .AND. clock%clockint%CurrTime > alarm%alarmint%RingTime + &
 !                                clock%clockint%TimeStep )
-                   PRED2 = ( ESMF_TimeGE( alarm%alarmint%RingTime,       &
+                   PRED2 = ( timelib_TimeGE( alarm%alarmint%RingTime,       &
                                           clock%clockint%CurrTime )      &
-                             .AND. ESMF_TimeGT( clock%clockint%CurrTime, &
-                               ESMF_TimeInc( alarm%alarmint%RingTime,    &
+                             .AND. timelib_TimeGT( clock%clockint%CurrTime, &
+                               timelib_TimeInc( alarm%alarmint%RingTime,    &
                                              clock%clockint%TimeStep ) ) )
                 ENDIF
               ENDIF
@@ -998,7 +998,7 @@
 !                   PRED3 = ( alarm%alarmint%PrevRingTime + alarm%alarmint%RingInterval <= &
 !                             clock%clockint%CurrTime )
 
-                   PRED3 = ( ESMF_TimeLE( ESMF_TimeInc(                  &
+                   PRED3 = ( timelib_TimeLE( timelib_TimeInc(                  &
                                           alarm%alarmint%PrevRingTime,   &
                                           alarm%alarmint%RingInterval ), &
                              clock%clockint%CurrTime ) )
@@ -1010,7 +1010,7 @@
 !                   PRED3 = ( alarm%alarmint%PrevRingTime - alarm%alarmint%RingInterval >= &
 !                             clock%clockint%CurrTime )
 
-                   PRED3 = ( ESMF_TimeGE( ESMF_TimeDec(                  &
+                   PRED3 = ( timelib_TimeGE( timelib_TimeDec(                  &
                                           alarm%alarmint%PrevRingTime,   &
                                           alarm%alarmint%RingInterval ), &
                              clock%clockint%CurrTime ) )
@@ -1033,7 +1033,7 @@
 !                                                    alarm%alarmint%RingInterval
                    IF ( PRED3 )                                   &
                      alarm%alarmint%PrevRingTime =                &
-                       ESMF_TimeInc( alarm%alarmint%PrevRingTime, &
+                       timelib_TimeInc( alarm%alarmint%PrevRingTime, &
                                      alarm%alarmint%RingInterval )
                  ELSE
                    ! in this case time step is negative and stop time is
@@ -1044,7 +1044,7 @@
 !                                                    alarm%alarmint%RingInterval
                    IF ( PRED3 )                                   &
                      alarm%alarmint%PrevRingTime =                &
-                       ESMF_TimeDec( alarm%alarmint%PrevRingTime, &
+                       timelib_TimeDec( alarm%alarmint%PrevRingTime, &
                                      alarm%alarmint%RingInterval )
                  ENDIF
                  IF ( PRESENT( RingingAlarmList ) .AND. &
@@ -1061,7 +1061,7 @@
               IF ( positive_timestep ) THEN
 ! hack for bug in PGI 5.1-x
 !                IF ( alarm%alarmint%RingTime <= clock%clockint%CurrTime ) THEN
-                IF ( ESMF_TimeLE( alarm%alarmint%RingTime, &
+                IF ( timelib_TimeLE( alarm%alarmint%RingTime, &
                                   clock%clockint%CurrTime ) ) THEN
                    alarm%alarmint%RingTimeSet = .FALSE.  !it is a one time alarm, it rang, now let it resort to interval
                    alarm%alarmint%Ringing = .TRUE.
@@ -1077,7 +1077,7 @@
                 ! less than start time
 ! hack for bug in PGI 5.1-x
 !                IF ( alarm%alarmint%RingTime >= clock%clockint%CurrTime ) THEN
-                IF ( ESMF_TimeGE( alarm%alarmint%RingTime, &
+                IF ( timelib_TimeGE( alarm%alarmint%RingTime, &
                                   clock%clockint%CurrTime ) ) THEN
                    alarm%alarmint%RingTimeSet = .FALSE.  !it is a one time alarm, it rang, now let it resort to interval
                    alarm%alarmint%Ringing = .TRUE.
@@ -1097,42 +1097,42 @@
         ENDIF
         clock%clockint%AlarmList(i) = alarm
       ENDDO
-      IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+      IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
     
-      end subroutine ESMF_ClockAdvance
+      end subroutine timelib_ClockAdvance
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockStopTimeDisable - NOOP for compatibility with ESMF 2.1.0+
+! !IROUTINE: timelib_ClockStopTimeDisable - NOOP for compatibility with timelib 2.1.0+
 
 ! !INTERFACE:
-      subroutine ESMF_ClockStopTimeDisable(clock, rc)
+      subroutine timelib_ClockStopTimeDisable(clock, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
+      type(timelib_Clock), intent(in) :: clock
       integer, intent(out), optional :: rc
 
-      rc = ESMF_SUCCESS
+      rc = timelib_SUCCESS
 
-      end subroutine ESMF_ClockStopTimeDisable
+      end subroutine timelib_ClockStopTimeDisable
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockIsStopTime - Has the clock reached its stop time ?
+! !IROUTINE: timelib_ClockIsStopTime - Has the clock reached its stop time ?
 
 ! !INTERFACE:
-      function ESMF_ClockIsStopTime(clock, rc)
+      function timelib_ClockIsStopTime(clock, rc)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_ClockIsStopTime
+      logical :: timelib_ClockIsStopTime
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
+      type(timelib_Clock), intent(in) :: clock
       integer, intent(out), optional :: rc
       logical :: positive_timestep
 
 ! !DESCRIPTION:
-!     Return true if {\tt ESMF\_Clock} has reached its stop time, false 
+!     Return true if {\tt timelib\_Clock} has reached its stop time, false 
 !     otherwise     
 !
 !     The arguments are:
@@ -1140,211 +1140,211 @@
 !     \item[clock]
 !          The object instance to check
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 
 ! !REQUIREMENTS:
 !     TMG3.5.6
 !EOP
 
-      positive_timestep = ESMF_TimeIntervalIsPositive( clock%clockint%TimeStep )
+      positive_timestep = timelib_TimeIntervalIsPositive( clock%clockint%TimeStep )
       IF ( positive_timestep ) THEN
 ! hack for bug in PGI 5.1-x
 !        if ( clock%clockint%CurrTime .GE. clock%clockint%StopTime ) THEN
-        if ( ESMF_TimeGE( clock%clockint%CurrTime, &
+        if ( timelib_TimeGE( clock%clockint%CurrTime, &
                           clock%clockint%StopTime ) ) THEN
-          ESMF_ClockIsStopTime = .TRUE.
+          timelib_ClockIsStopTime = .TRUE.
         else
-          ESMF_ClockIsStopTime = .FALSE.
+          timelib_ClockIsStopTime = .FALSE.
         endif
       ELSE
 ! hack for bug in PGI 5.1-x
 !        if ( clock%clockint%CurrTime .LE. clock%clockint%StopTime ) THEN
-        if ( ESMF_TimeLE( clock%clockint%CurrTime, &
+        if ( timelib_TimeLE( clock%clockint%CurrTime, &
                           clock%clockint%StopTime ) ) THEN
-          ESMF_ClockIsStopTime = .TRUE.
+          timelib_ClockIsStopTime = .TRUE.
         else
-          ESMF_ClockIsStopTime = .FALSE.
+          timelib_ClockIsStopTime = .FALSE.
         endif
       ENDIF
-      IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+      IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
     
-      end function ESMF_ClockIsStopTime
+      end function timelib_ClockIsStopTime
 
 !------------------------------------------------------------------------------
 !
 ! This section defines the overridden Read, Write, Validate and Print methods
-! from the ESMF_Base class
+! from the timelib_Base class
 !
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockRead - Restores a clock
+! !IROUTINE: timelib_ClockRead - Restores a clock
 
 ! !INTERFACE:
-      subroutine ESMF_ClockRead(clock, TimeStep, StartTime, StopTime, &
+      subroutine timelib_ClockRead(clock, TimeStep, StartTime, StopTime, &
                                 RefTime, CurrTime, PrevTime, AdvanceCount, &
                                 AlarmList, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(out) :: clock
-      type(ESMF_TimeInterval), intent(in) :: TimeStep
-      type(ESMF_Time), intent(in) :: StartTime
-      type(ESMF_Time), intent(in) :: StopTime
-      type(ESMF_Time), intent(in) :: RefTime
-      type(ESMF_Time), intent(in) :: CurrTime
-      type(ESMF_Time), intent(in) :: PrevTime
-      integer(ESMF_KIND_I8), intent(in) :: AdvanceCount
-      type(ESMF_Alarm), dimension(MAX_ALARMS), intent(in) :: AlarmList
+      type(timelib_Clock), intent(out) :: clock
+      type(timelib_TimeInterval), intent(in) :: TimeStep
+      type(timelib_Time), intent(in) :: StartTime
+      type(timelib_Time), intent(in) :: StopTime
+      type(timelib_Time), intent(in) :: RefTime
+      type(timelib_Time), intent(in) :: CurrTime
+      type(timelib_Time), intent(in) :: PrevTime
+      integer(timelib_KIND_I8), intent(in) :: AdvanceCount
+      type(timelib_Alarm), dimension(MAX_ALARMS), intent(in) :: AlarmList
       integer, intent(out), optional :: rc
     
 ! !DESCRIPTION:
-!     Restore an {\tt ESMF\_Clock}
+!     Restore an {\tt timelib\_Clock}
 !     
 !     The arguments are:
 !     \begin{description}
 !     \item[clock]
 !          The object instance to restore
 !     \item[TimeStep]
-!          The {\tt ESMF\_Clock}'s time step interval
+!          The {\tt timelib\_Clock}'s time step interval
 !     \item[StartTime]
-!          The {\tt ESMF\_Clock}'s starting time
+!          The {\tt timelib\_Clock}'s starting time
 !     \item[StopTime]
-!          The {\tt ESMF\_Clock}'s stopping time
+!          The {\tt timelib\_Clock}'s stopping time
 !     \item[RefTime]
-!          The {\tt ESMF\_Clock}'s reference time
+!          The {\tt timelib\_Clock}'s reference time
 !     \item[CurrTime]
-!          The {\tt ESMF\_Clock}'s current time
+!          The {\tt timelib\_Clock}'s current time
 !     \item[PrevTime]
-!          The {\tt ESMF\_Clock}'s previous time
+!          The {\tt timelib\_Clock}'s previous time
 !     \item[AdvanceCount]
-!          The number of times the {\tt ESMF\_Clock} has been advanced
+!          The number of times the {\tt timelib\_Clock} has been advanced
 !     \item[AlarmList]
-!          The {\tt ESMF\_Clock}'s {\tt ESMF\_Alarm} list
+!          The {\tt timelib\_Clock}'s {\tt timelib\_Alarm} list
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !     
 ! !REQUIREMENTS:
 !EOP
-      CALL wrf_error_fatal( 'ESMF_ClockRead not supported' )
-      end subroutine ESMF_ClockRead
+      CALL wrf_error_fatal( 'timelib_ClockRead not supported' )
+      end subroutine timelib_ClockRead
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_ClockWrite - Saves a clock
+! !IROUTINE: timelib_ClockWrite - Saves a clock
 
 ! !INTERFACE:
-      subroutine ESMF_ClockWrite(clock, TimeStep, StartTime, StopTime, &
+      subroutine timelib_ClockWrite(clock, TimeStep, StartTime, StopTime, &
                             RefTime, CurrTime, PrevTime, AdvanceCount, &
                             AlarmList, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
-      type(ESMF_TimeInterval), intent(out) :: TimeStep
-      type(ESMF_Time), intent(out) :: StartTime
-      type(ESMF_Time), intent(out) :: StopTime
-      type(ESMF_Time), intent(out) :: RefTime
-      type(ESMF_Time), intent(out) :: CurrTime
-      type(ESMF_Time), intent(out) :: PrevTime
-      integer(ESMF_KIND_I8), intent(out) :: AdvanceCount
-      type(ESMF_Alarm), dimension(MAX_ALARMS), intent(out) :: AlarmList
+      type(timelib_Clock), intent(in) :: clock
+      type(timelib_TimeInterval), intent(out) :: TimeStep
+      type(timelib_Time), intent(out) :: StartTime
+      type(timelib_Time), intent(out) :: StopTime
+      type(timelib_Time), intent(out) :: RefTime
+      type(timelib_Time), intent(out) :: CurrTime
+      type(timelib_Time), intent(out) :: PrevTime
+      integer(timelib_KIND_I8), intent(out) :: AdvanceCount
+      type(timelib_Alarm), dimension(MAX_ALARMS), intent(out) :: AlarmList
       integer, intent(out), optional :: rc
     
 ! !DESCRIPTION:
-!     Save an {\tt ESMF\_Clock}
+!     Save an {\tt timelib\_Clock}
 !     
 !     The arguments are:
 !     \begin{description}
 !     \item[clock]
 !          The object instance to save
 !     \item[TimeStep]
-!          The {\tt ESMF\_Clock}'s time step interval
+!          The {\tt timelib\_Clock}'s time step interval
 !     \item[StartTime]
-!          The {\tt ESMF\_Clock}'s starting time
+!          The {\tt timelib\_Clock}'s starting time
 !     \item[StopTime]
-!          The {\tt ESMF\_Clock}'s stopping time
+!          The {\tt timelib\_Clock}'s stopping time
 !     \item[RefTime]
-!          The {\tt ESMF\_Clock}'s reference time
+!          The {\tt timelib\_Clock}'s reference time
 !     \item[CurrTime]
-!          The {\tt ESMF\_Clock}'s current time
+!          The {\tt timelib\_Clock}'s current time
 !     \item[PrevTime]
-!          The {\tt ESMF\_Clock}'s previous time
+!          The {\tt timelib\_Clock}'s previous time
 !     \item[AdvanceCount]
-!          The number of times the {\tt ESMF\_Clock} has been advanced
+!          The number of times the {\tt timelib\_Clock} has been advanced
 !     \item[AlarmList]
-!          The {\tt ESMF\_Clock}'s {\tt ESMF\_Alarm} list
+!          The {\tt timelib\_Clock}'s {\tt timelib\_Alarm} list
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !     
 ! !REQUIREMENTS:
 !EOP
-      CALL wrf_error_fatal( 'ESMF_ClockWrite not supported' )
-      end subroutine ESMF_ClockWrite
+      CALL wrf_error_fatal( 'timelib_ClockWrite not supported' )
+      end subroutine timelib_ClockWrite
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_ClockValidate - Validate a Clock's properties
+! !IROUTINE:  timelib_ClockValidate - Validate a Clock's properties
 
 ! !INTERFACE:
-      subroutine ESMF_ClockValidate(clock, opts, rc)
+      subroutine timelib_ClockValidate(clock, opts, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
+      type(timelib_Clock), intent(in) :: clock
       character (len=*), intent(in), optional :: opts
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     Perform a validation check on an {\tt ESMF\_Clock}'s properties
+!     Perform a validation check on an {\tt timelib\_Clock}'s properties
 !
 !     The arguments are:  
 !     \begin{description}
 !     \item[clock]
-!          {\tt ESMF\_Clock} to validate
+!          {\tt timelib\_Clock} to validate
 !     \item[{[opts]}]
 !          Validate options
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description} 
 !
 ! !REQUIREMENTS:
 !     TMGn.n.n
 !EOP
-      CALL wrf_error_fatal( 'ESMF_ClockValidate not supported' )
-      end subroutine ESMF_ClockValidate
+      CALL wrf_error_fatal( 'timelib_ClockValidate not supported' )
+      end subroutine timelib_ClockValidate
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_ClockPrint - Print out a Clock's properties
+! !IROUTINE:  timelib_ClockPrint - Print out a Clock's properties
 
 ! !INTERFACE:
-      subroutine ESMF_ClockPrint(clock, opts, rc)
+      subroutine timelib_ClockPrint(clock, opts, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Clock), intent(in) :: clock
+      type(timelib_Clock), intent(in) :: clock
       character (len=*), intent(in), optional :: opts
       integer, intent(out), optional :: rc
 
 ! !DESCRIPTION:
-!     To support testing/debugging, print out an {\tt ESMF\_Clock}'s
+!     To support testing/debugging, print out an {\tt timelib\_Clock}'s
 !     properties.
 ! 
 !     The arguments are:
 !     \begin{description}
 !     \item[clock]
-!          {\tt ESMF\_Clock} to print out
+!          {\tt timelib\_Clock} to print out
 !     \item[{[opts]}]
 !          Print options
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMGn.n.n
 !EOP
-      CALL wrf_error_fatal( 'ESMF_ClockPrint not supported' )
-      end subroutine ESMF_ClockPrint
+      CALL wrf_error_fatal( 'timelib_ClockPrint not supported' )
+      end subroutine timelib_ClockPrint
 
 !------------------------------------------------------------------------------
 
-      end module ESMF_ClockMod
+      end module timelib_ClockMod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Fraction.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_Fraction.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_Fraction.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Fraction.F90	2017-07-03 16:17:29.681895000 -0400
@@ -7,12 +7,12 @@
 ! NASA Goddard Space Flight Center.
 ! Licensed under the University of Illinois-NCSA license.
 !
-! ESMF Fraction Module
+! timelib Fraction Module
 !
 !==============================================================================
 !
-!     ESMF Fraction Module
-      module ESMF_FractionMod
+!     timelib Fraction Module
+      module timelib_FractionMod
 !
 !==============================================================================
 !
@@ -25,15 +25,15 @@
 !===============================================================================
 !BOPI
 !
-! !MODULE: ESMF_FractionMod
+! !MODULE: timelib_FractionMod
 !
 ! !DESCRIPTION:
-! Part of ESMF F90 API wrapper of C++ implemenation
+! Part of timelib F90 API wrapper of C++ implemenation
 !
 ! Defines F90 wrapper entry points for corresponding
-! C++ implementaion of class {\tt ESMC\_Fraction}
+! C++ implementaion of class {\tt timelibc\_Fraction}
 !
-! See {\tt ../include/ESMC\_Fraction.h} for complete description
+! See {\tt ../include/timelibc\_Fraction.h} for complete description
 !
 !------------------------------------------------------------------------------
 ! !USES:
@@ -44,9 +44,9 @@
 ! !PRIVATE TYPES:
       private
 !------------------------------------------------------------------------------
-!     ! ESMF_Fraction
+!     ! timelib_Fraction
 !
-      type ESMF_Fraction
+      type timelib_Fraction
       private
         integer :: n    ! Integer fraction (exact) n/d; numerator
         integer :: d    ! Integer fraction (exact) n/d; denominator
@@ -54,7 +54,7 @@
 !
 !------------------------------------------------------------------------------
 ! !PUBLIC TYPES:
-      public ESMF_Fraction
+      public timelib_Fraction
 !------------------------------------------------------------------------------
 !
 ! !PUBLIC MEMBER FUNCTIONS:
@@ -76,4 +76,4 @@
 
 !------------------------------------------------------------------------------
 
-      end module ESMF_FractionMod
+      end module timelib_FractionMod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Macros.inc WRFV3.9.patch/external/esmf_time_f90/ESMF_Macros.inc
--- WRFV3.9/external/esmf_time_f90/ESMF_Macros.inc	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Macros.inc	1969-12-31 19:00:00.000000000 -0500
@@ -1,35 +0,0 @@
-#if 0
-
-Earth System Modeling Framework
-Copyright 2002-2003, University Corporation for Atmospheric Research,
-Massachusetts Institute of Technology, Geophysical Fluid Dynamics
-Laboratory, University of Michigan, National Centers for Environmental
-Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
-NASA Goddard Space Flight Center.
-Licensed under the University of Illinois-NCSA license.
-
-Do not have C++ or F90 style comments in here because this file is processed
-by both C++ and F90 compilers.
-
-These lines prevent this file from being read more than once if it
-ends up being included multiple times.
-#endif
-
-#ifndef ESMF_MACROS_INC
-#define ESMF_MACROS_INC
-
-#if 0
-
-former file contents moved to ESMF_BaseMod
-so user code can be compiled without requiring
-the preprocessor.
-
-#endif 
-
-#if 0
-i left the following macro here in case it is needed for our internal use.
-#endif
-
-#define ESMF_SRCLINE __FILE__, __LINE__
-
-#endif 
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Mod.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_Mod.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_Mod.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Mod.F90	2017-07-03 16:17:29.682266000 -0400
@@ -1,17 +1,17 @@
-! TBH:  This version is for use with the ESMF library embedded in the WRF 
+! TBH:  This version is for use with the timelib library embedded in the WRF 
 ! TBH:  distribution.  
-MODULE ESMF_Mod
-   USE esmf_alarmmod
-   USE esmf_basemod
-   USE esmf_basetimemod
-   USE esmf_calendarmod
-   USE esmf_clockmod
-   USE esmf_fractionmod
-   USE esmf_timeintervalmod
-   USE esmf_timemod
-   USE esmf_alarmclockmod
-   USE esmf_stubs   ! add new dummy interfaces and typedefs here as needed
-#include <ESMF_TimeMgr.inc>
-   INTEGER, PARAMETER :: ESMF_MAX_ALARMS=MAX_ALARMS
+MODULE timelib_Mod
+   USE timelib_alarmmod
+   USE timelib_basemod
+   USE timelib_basetimemod
+   USE timelib_calendarmod
+   USE timelib_clockmod
+   USE timelib_fractionmod
+   USE timelib_timeintervalmod
+   USE timelib_timemod
+   USE timelib_alarmclockmod
+   USE timelib_stubs   ! add new dummy interfaces and typedefs here as needed
+#include <timelib_TimeMgr.inc>
+   INTEGER, PARAMETER :: timelib_MAX_ALARMS=MAX_ALARMS
 !
-END MODULE ESMF_Mod
+END MODULE timelib_Mod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Stubs.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_Stubs.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_Stubs.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Stubs.F90	2017-07-03 16:17:29.682633000 -0400
@@ -1,96 +1,96 @@
 ! Various dummy type definitions and routines for the sole purpose of 
-! mimicking newer ESMF interface features without necessarily implementing 
+! mimicking newer timelib interface features without necessarily implementing 
 ! them.  
 
-MODULE ESMF_Stubs
+MODULE timelib_Stubs
 
    IMPLICIT NONE
 
    PRIVATE
 
 ! Bogus typedefs
-   TYPE ESMF_Grid
+   TYPE timelib_Grid
       INTEGER :: dummy
    END TYPE
 
-   TYPE ESMF_GridComp
+   TYPE timelib_GridComp
       INTEGER :: dummy
    END TYPE
 
-   TYPE ESMF_State
+   TYPE timelib_State
       INTEGER :: dummy
    END TYPE
 
-   TYPE ESMF_VM
+   TYPE timelib_VM
       INTEGER :: dummy
    END TYPE
 
-   TYPE ESMF_MsgType
+   TYPE timelib_MsgType
       INTEGER :: mtype
    END TYPE
-   TYPE(ESMF_MsgType), PARAMETER  ::      &
-      ESMF_LOG_INFO  =   ESMF_MsgType(1), &
-      ESMF_LOG_WARNING = ESMF_MsgType(2), &
-      ESMF_LOG_ERROR =   ESMF_MsgType(3)
+   TYPE(timelib_MsgType), PARAMETER  ::      &
+      timelib_LOG_INFO  =   timelib_MsgType(1), &
+      timelib_LOG_WARNING = timelib_MsgType(2), &
+      timelib_LOG_ERROR =   timelib_MsgType(3)
 
-   TYPE ESMF_LOG
+   TYPE timelib_LOG
       INTEGER :: dummy
    END TYPE
 
    LOGICAL, private, save :: initialized = .false.
 
-   PUBLIC ESMF_Grid, ESMF_GridComp, ESMF_State, ESMF_VM
-   PUBLIC ESMF_Initialize, ESMF_Finalize, ESMF_IsInitialized
-   PUBLIC ESMF_LogWrite, ESMF_LOG, ESMF_MsgType
-   PUBLIC ESMF_LOG_INFO, ESMF_LOG_WARNING, ESMF_LOG_ERROR
+   PUBLIC timelib_Grid, timelib_GridComp, timelib_State, timelib_VM
+   PUBLIC timelib_Initialize, timelib_Finalize, timelib_IsInitialized
+   PUBLIC timelib_LogWrite, timelib_LOG, timelib_MsgType
+   PUBLIC timelib_LOG_INFO, timelib_LOG_WARNING, timelib_LOG_ERROR
 
 CONTAINS
 
 
 ! NOOP
-   SUBROUTINE ESMF_Initialize( vm, defaultcalkind, rc )
-      USE esmf_basemod
-      USE esmf_calendarmod
-      TYPE(ESMF_VM),           INTENT(IN   ), OPTIONAL :: vm
-      TYPE(ESMF_CalendarType), INTENT(IN   ), OPTIONAL :: defaultcalkind
+   SUBROUTINE timelib_Initialize( vm, defaultcalkind, rc )
+      USE timelib_basemod
+      USE timelib_calendarmod
+      TYPE(timelib_VM),           INTENT(IN   ), OPTIONAL :: vm
+      TYPE(timelib_CalendarType), INTENT(IN   ), OPTIONAL :: defaultcalkind
       INTEGER,                 INTENT(  OUT), OPTIONAL :: rc
 
-      TYPE(ESMF_CalendarType) :: defaultCalType
+      TYPE(timelib_CalendarType) :: defaultCalType
       INTEGER :: status
 
-      IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+      IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       ! Initialize the default time manager calendar
       IF ( PRESENT(defaultcalkind) )THEN
          defaultCalType = defaultcalkind
       ELSE
-         defaultCalType = ESMF_CAL_NOLEAP
+         defaultCalType = timelib_CAL_NOLEAP
       END IF
       allocate( defaultCal )
-      defaultCal = ESMF_CalendarCreate( calendarType=defaultCalType, &
+      defaultCal = timelib_CalendarCreate( calendarType=defaultCalType, &
                         rc=status)
 
       ! initialize tables in time manager
       CALL initdaym
 
-      IF (status .ne. ESMF_SUCCESS) THEN
+      IF (status .ne. timelib_SUCCESS) THEN
           PRINT *, "Error initializing the default time manager calendar"
           RETURN
       END IF
       initialized = .true.
 
-      IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
-   END SUBROUTINE ESMF_Initialize
+      IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
+   END SUBROUTINE timelib_Initialize
 
 
-   FUNCTION ESMF_IsInitialized()
-      LOGICAL ESMF_IsInitialized
-      ESMF_IsInitialized = initialized
-   END FUNCTION ESMF_IsInitialized
+   FUNCTION timelib_IsInitialized()
+      LOGICAL timelib_IsInitialized
+      timelib_IsInitialized = initialized
+   END FUNCTION timelib_IsInitialized
 
 
 ! NOOP
-   SUBROUTINE ESMF_Finalize( rc )
-      USE esmf_basemod
+   SUBROUTINE timelib_Finalize( rc )
+      USE timelib_basemod
       INTEGER, INTENT(  OUT), OPTIONAL :: rc
 #if (defined SPMD) || (defined COUP_CSM)
 #include <mpif.h>
@@ -98,35 +98,35 @@
       LOGICAL :: flag
       INTEGER :: ier
 
-      IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
+      IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
 #if (defined SPMD) || (defined COUP_CSM)
       CALL MPI_Finalized( flag, ier )
       IF ( ier .ne. mpi_success )THEN
-        IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+        IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       END IF
       IF ( .NOT. flag ) THEN
         CALL MPI_Finalize( ier ) 
         IF ( ier .ne. mpi_success )THEN
-          IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+          IF ( PRESENT( rc ) ) rc = timelib_FAILURE
         END IF
       END IF
 #endif
-   END SUBROUTINE ESMF_Finalize
+   END SUBROUTINE timelib_Finalize
 
 ! NOOP
-   SUBROUTINE ESMF_LogWrite( msg, MsgType, line, file, method, log, rc )
-      USE esmf_basemod
+   SUBROUTINE timelib_LogWrite( msg, MsgType, line, file, method, log, rc )
+      USE timelib_basemod
       CHARACTER(LEN=*), INTENT(IN) :: msg
-      TYPE(ESMF_MsgType), INTENT(IN) :: msgtype
+      TYPE(timelib_MsgType), INTENT(IN) :: msgtype
       INTEGER, INTENT(IN), OPTIONAL :: line
       CHARACTER(LEN=*), INTENT(IN), OPTIONAL :: file
       CHARACTER(LEN=*), INTENT(IN), OPTIONAL :: method
-      TYPE(ESMF_LOG),TARGET,OPTIONAL :: log
+      TYPE(timelib_LOG),TARGET,OPTIONAL :: log
       INTEGER, INTENT(OUT),OPTIONAL :: rc
-      IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
-   END SUBROUTINE ESMF_LogWrite
+      IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
+   END SUBROUTINE timelib_LogWrite
 
 
-END MODULE ESMF_Stubs
+END MODULE timelib_Stubs
 
 
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_Time.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_Time.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_Time.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_Time.F90	2017-07-03 16:17:29.683023000 -0400
@@ -9,8 +9,8 @@
 !
 !==============================================================================
 !
-!     ESMF Time Module
-      module ESMF_TimeMod
+!     timelib Time Module
+      module timelib_TimeMod
 !
 !==============================================================================
 !
@@ -18,32 +18,32 @@
 !
 !------------------------------------------------------------------------------
 ! INCLUDES
-#include <ESMF_TimeMgr.inc>
+#include <timelib_TimeMgr.inc>
 
 !==============================================================================
 !BOPI
-! !MODULE: ESMF_TimeMod
+! !MODULE: timelib_TimeMod
 !
 ! !DESCRIPTION:
 ! Part of Time Manager F90 API wrapper of C++ implemenation
 !
 ! Defines F90 wrapper entry points for corresponding
-! C++ class {\tt ESMC\_Time} implementation
+! C++ class {\tt timelibc\_Time} implementation
 !
-! See {\tt ../include/ESMC\_Time.h} for complete description
+! See {\tt ../include/timelibc\_Time.h} for complete description
 !
 !------------------------------------------------------------------------------
 ! !USES:
-      ! inherit from ESMF base class
-      use ESMF_BaseMod
+      ! inherit from timelib base class
+      use timelib_BaseMod
 
       ! inherit from base time class
-      use ESMF_BaseTimeMod
+      use timelib_BaseTimeMod
 
       ! associated derived types
-      use ESMF_TimeIntervalMod
-      use ESMF_CalendarMod
-      use ESMF_Stubs
+      use timelib_TimeIntervalMod
+      use timelib_CalendarMod
+      use timelib_Stubs
 
       implicit none
 !
@@ -51,68 +51,68 @@
 ! !PRIVATE TYPES:
       private
 !------------------------------------------------------------------------------
-!     ! ESMF_Time
+!     ! timelib_Time
 !
 !     ! F90 class type to match C++ Time class in size only;
 !     !  all dereferencing within class is performed by C++ implementation
 
-     type ESMF_Time
-       type(ESMF_BaseTime) :: basetime           ! inherit base class
+     type timelib_Time
+       type(timelib_BaseTime) :: basetime           ! inherit base class
        ! time instant is expressed as year + basetime
        integer :: YR
-       type(ESMF_Calendar), pointer :: calendar  ! associated calendar
+       type(timelib_Calendar), pointer :: calendar  ! associated calendar
      end type
 
 !------------------------------------------------------------------------------
 ! !PUBLIC TYPES:
-      public ESMF_Time
+      public timelib_Time
 !------------------------------------------------------------------------------
 !
 ! !PUBLIC MEMBER FUNCTIONS:
-      public ESMF_TimeGet
-      public ESMF_TimeSet
+      public timelib_TimeGet
+      public timelib_TimeSet
 
-! Required inherited and overridden ESMF_Base class methods
+! Required inherited and overridden timelib_Base class methods
 
-      public ESMF_TimeCopy
+      public timelib_TimeCopy
 
 ! !PRIVATE MEMBER FUNCTIONS:
 
-      private ESMF_TimeGetDayOfYear
-      private ESMF_TimeGetDayOfYearInteger
+      private timelib_TimeGetDayOfYear
+      private timelib_TimeGetDayOfYearInteger
 
-! Inherited and overloaded from ESMF_BaseTime
+! Inherited and overloaded from timelib_BaseTime
 
-      ! NOTE:  ESMF_TimeInc, ESMF_TimeDec, ESMF_TimeDiff, ESMF_TimeEQ, 
-      !        ESMF_TimeNE, ESMF_TimeLT, ESMF_TimeGT, ESMF_TimeLE, and 
-      !        ESMF_TimeGE are PUBLIC only to work around bugs in the 
+      ! NOTE:  timelib_TimeInc, timelib_TimeDec, timelib_TimeDiff, timelib_TimeEQ, 
+      !        timelib_TimeNE, timelib_TimeLT, timelib_TimeGT, timelib_TimeLE, and 
+      !        timelib_TimeGE are PUBLIC only to work around bugs in the 
       !        PGI 5.1-x compilers.  They should all be PRIVATE.  
 
       public operator(+)
-      public ESMF_TimeInc
+      public timelib_TimeInc
 
       public operator(-)
-      public ESMF_TimeDec
-      public ESMF_TimeDec2
-      public ESMF_TimeDiff
+      public timelib_TimeDec
+      public timelib_TimeDec2
+      public timelib_TimeDiff
 
       public operator(.EQ.)
-      public ESMF_TimeEQ
+      public timelib_TimeEQ
 
       public operator(.NE.)
-      public ESMF_TimeNE
+      public timelib_TimeNE
 
       public operator(.LT.)
-      public ESMF_TimeLT
+      public timelib_TimeLT
 
       public operator(.GT.)
-      public ESMF_TimeGT
+      public timelib_TimeGT
 
       public operator(.LE.)
-      public ESMF_TimeLE
+      public timelib_TimeLE
 
       public operator(.GE.)
-      public ESMF_TimeGE
+      public timelib_TimeGE
 
 !EOPI
 
@@ -123,14 +123,14 @@
 !==============================================================================
 !BOP
 ! !INTERFACE:
-      interface ESMF_TimeGetDayOfYear
+      interface timelib_TimeGetDayOfYear
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeGetDayOfYearInteger
+      module procedure timelib_TimeGetDayOfYearInteger
 
 ! !DESCRIPTION:
-!     This interface overloads the {\tt ESMF\_GetDayOfYear} method
-!     for the {\tt ESMF\_Time} class
+!     This interface overloads the {\tt timelib\_GetDayOfYear} method
+!     for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -141,10 +141,10 @@
       interface operator(+)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeInc, ESMF_TimeInc2
+      module procedure timelib_TimeInc, timelib_TimeInc2
 
 ! !DESCRIPTION:
-!     This interface overloads the + operator for the {\tt ESMF\_Time} class
+!     This interface overloads the + operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -155,10 +155,10 @@
       interface assignment (=)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeCopy
+      module procedure timelib_TimeCopy
 
 ! !DESCRIPTION:
-!     This interface overloads the = operator for the {\tt ESMF\_Time} class
+!     This interface overloads the = operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -169,10 +169,10 @@
       interface operator(-)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeDec, ESMF_TimeDec2
+      module procedure timelib_TimeDec, timelib_TimeDec2
 
 ! !DESCRIPTION:
-!     This interface overloads the - operator for the {\tt ESMF\_Time} class
+!     This interface overloads the - operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -183,10 +183,10 @@
       interface operator(-)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeDiff
+      module procedure timelib_TimeDiff
 
 ! !DESCRIPTION:
-!     This interface overloads the - operator for the {\tt ESMF\_Time} class
+!     This interface overloads the - operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -197,10 +197,10 @@
       interface operator(.EQ.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeEQ
+      module procedure timelib_TimeEQ
 
 ! !DESCRIPTION:
-!     This interface overloads the .EQ. operator for the {\tt ESMF\_Time} class
+!     This interface overloads the .EQ. operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -211,10 +211,10 @@
       interface operator(.NE.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeNE
+      module procedure timelib_TimeNE
 
 ! !DESCRIPTION:
-!     This interface overloads the .NE. operator for the {\tt ESMF\_Time} class
+!     This interface overloads the .NE. operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -225,10 +225,10 @@
       interface operator(.LT.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeLT
+      module procedure timelib_TimeLT
 
 ! !DESCRIPTION:
-!     This interface overloads the .LT. operator for the {\tt ESMF\_Time} class
+!     This interface overloads the .LT. operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -239,10 +239,10 @@
       interface operator(.GT.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeGT
+      module procedure timelib_TimeGT
 
 ! !DESCRIPTION:
-!     This interface overloads the .GT. operator for the {\tt ESMF\_Time} class
+!     This interface overloads the .GT. operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -253,10 +253,10 @@
       interface operator(.LE.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeLE
+      module procedure timelib_TimeLE
 
 ! !DESCRIPTION:
-!     This interface overloads the .LE. operator for the {\tt ESMF\_Time} class
+!     This interface overloads the .LE. operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -267,10 +267,10 @@
       interface operator(.GE.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeGE
+      module procedure timelib_TimeGE
 
 ! !DESCRIPTION:
-!     This interface overloads the .GE. operator for the {\tt ESMF\_Time} class
+!     This interface overloads the .GE. operator for the {\tt timelib\_Time} class
 !
 !EOP
       end interface
@@ -287,26 +287,26 @@
 !
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeGet - Get value in user-specified units
+! !IROUTINE: timelib_TimeGet - Get value in user-specified units
 
 ! !INTERFACE:
-      subroutine ESMF_TimeGet(time, YY, YRl, MM, DD, D, Dl, H, M, S, Sl, MS, &
+      subroutine timelib_TimeGet(time, YY, YRl, MM, DD, D, Dl, H, M, S, Sl, MS, &
                               US, NS, d_, h_, m_, s_, ms_, us_, ns_, Sn, Sd, &
                               dayOfYear, dayOfYear_r8, dayOfYear_intvl,      &
                               timeString, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time
+      type(timelib_Time), intent(in) :: time
       integer, intent(out), optional :: YY
-      integer(ESMF_KIND_I8), intent(out), optional :: YRl
+      integer(timelib_KIND_I8), intent(out), optional :: YRl
       integer, intent(out), optional :: MM
       integer, intent(out), optional :: DD
       integer, intent(out), optional :: D
-      integer(ESMF_KIND_I8), intent(out), optional :: Dl
+      integer(timelib_KIND_I8), intent(out), optional :: Dl
       integer, intent(out), optional :: H
       integer, intent(out), optional :: M
       integer, intent(out), optional :: S
-      integer(ESMF_KIND_I8), intent(out), optional :: Sl
+      integer(timelib_KIND_I8), intent(out), optional :: Sl
       integer, intent(out), optional :: MS
       integer, intent(out), optional :: US
       integer, intent(out), optional :: NS
@@ -322,23 +322,23 @@
       integer, intent(out), optional :: dayOfYear
       ! dayOfYear_r8 = 1.0 at 0Z on 1 January, 1.5 at 12Z on
       ! 1 January, etc.
-      real(ESMF_KIND_R8), intent(out), optional :: dayOfYear_r8
+      real(timelib_KIND_R8), intent(out), optional :: dayOfYear_r8
       character (len=*), intent(out), optional :: timeString
-      type(ESMF_TimeInterval), intent(out), optional :: dayOfYear_intvl
+      type(timelib_TimeInterval), intent(out), optional :: dayOfYear_intvl
       integer, intent(out), optional :: rc
 
-      type(ESMF_TimeInterval) :: day_step
+      type(timelib_TimeInterval) :: day_step
       integer :: ierr
 
 ! !DESCRIPTION:
-!     Get the value of the {\tt ESMF\_Time} in units specified by the user
+!     Get the value of the {\tt timelib\_Time} in units specified by the user
 !     via F90 optional arguments.
 !
 !     Time manager represents and manipulates time internally with integers
 !     to maintain precision. Hence, user-specified floating point values are
 !     converted internally from integers.
 !
-!     See {\tt ../include/ESMC\_BaseTime.h and ../include/ESMC\_Time.h} for
+!     See {\tt ../include/timelibc\_BaseTime.h and ../include/timelibc\_Time.h} for
 !     complete description.
 !     
 !     The arguments are:
@@ -390,17 +390,17 @@
 !     \item[{[Sd]}]
 !          Integer fractional seconds - denominator
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG2.1, TMG2.5.1, TMG2.5.6
 !EOP
-      TYPE(ESMF_Time) :: begofyear
+      TYPE(timelib_Time) :: begofyear
       INTEGER :: year, month, dayofmonth, hour, minute, second
-      REAL(ESMF_KIND_R8) :: rsec
+      REAL(timelib_KIND_R8) :: rsec
 
-      ierr = ESMF_SUCCESS
+      ierr = timelib_SUCCESS
 
       IF ( PRESENT( YY ) ) THEN
         YY = time%YR
@@ -412,8 +412,8 @@
         CALL timegetdayofmonth( time, DD )
       ENDIF
 !
-!$$$ Push HMS down into ESMF_BaseTime from EVERYWHERE
-!$$$ and THEN add ESMF scaling behavior when other args are present...  
+!$$$ Push HMS down into timelib_BaseTime from EVERYWHERE
+!$$$ and THEN add timelib scaling behavior when other args are present...  
       IF ( PRESENT( H ) ) THEN
         H = mod( time%basetime%S, SECONDS_PER_DAY ) / SECONDS_PER_HOUR
       ENDIF
@@ -423,7 +423,7 @@
       IF ( PRESENT( S ) ) THEN
         S = mod( time%basetime%S, SECONDS_PER_MINUTE )
       ENDIF
-      ! TBH:  HACK to allow DD and S to behave as in ESMF 2.1.0+ when 
+      ! TBH:  HACK to allow DD and S to behave as in timelib 2.1.0+ when 
       ! TBH:  both are present and H and M are not.  
       IF ( PRESENT( S ) .AND. PRESENT( DD ) ) THEN
         IF ( ( .NOT. PRESENT( H ) ) .AND. ( .NOT. PRESENT( M ) ) ) THEN
@@ -442,19 +442,19 @@
         Sn = time%basetime%Sn
       ENDIF
       IF ( PRESENT( dayOfYear ) ) THEN
-        CALL ESMF_TimeGetDayOfYear( time, dayOfYear, rc=ierr )
+        CALL timelib_TimeGetDayOfYear( time, dayOfYear, rc=ierr )
       ENDIF
       IF ( PRESENT( dayOfYear_r8 ) ) THEN
         ! 64-bit IEEE 754 has 52-bit mantisssa -- only need 25 bits to hold 
         ! number of seconds in a year...  
-        rsec = REAL( time%basetime%S, ESMF_KIND_R8 )
+        rsec = REAL( time%basetime%S, timelib_KIND_R8 )
         IF ( time%basetime%Sd /= 0 ) THEN
-          rsec = rsec + ( REAL( time%basetime%Sn, ESMF_KIND_R8 ) / &
-                          REAL( time%basetime%Sd, ESMF_KIND_R8 ) )
+          rsec = rsec + ( REAL( time%basetime%Sn, timelib_KIND_R8 ) / &
+                          REAL( time%basetime%Sd, timelib_KIND_R8 ) )
         ENDIF
-        dayOfYear_r8 = rsec / REAL( SECONDS_PER_DAY, ESMF_KIND_R8 )
+        dayOfYear_r8 = rsec / REAL( SECONDS_PER_DAY, timelib_KIND_R8 )
         ! start at 1
-        dayOfYear_r8 = dayOfYear_r8 + 1.0_ESMF_KIND_R8
+        dayOfYear_r8 = dayOfYear_r8 + 1.0_timelib_KIND_R8
       ENDIF
       IF ( PRESENT( timeString ) ) THEN
         ! This duplication for YMD is an optimization that avoids calling 
@@ -462,22 +462,22 @@
         year = time%YR
         CALL timegetmonth( time, month )
         CALL timegetdayofmonth( time, dayofmonth )
-!$$$ push HMS down into ESMF_BaseTime
+!$$$ push HMS down into timelib_BaseTime
         hour = mod( time%basetime%S, SECONDS_PER_DAY ) / SECONDS_PER_HOUR
         minute = mod( time%basetime%S, SECONDS_PER_HOUR) / SECONDS_PER_MINUTE
         second = mod( time%basetime%S, SECONDS_PER_MINUTE )
-        CALL ESMFold_TimeGetString( year, month, dayofmonth, &
+        CALL timelibold_TimeGetString( year, month, dayofmonth, &
                                     hour, minute, second, timeString )
       ENDIF
       IF ( PRESENT( dayOfYear_intvl ) ) THEN
         year = time%YR
-        CALL ESMF_TimeSet( begofyear, yy=year, mm=1, dd=1, s=0, &
+        CALL timelib_TimeSet( begofyear, yy=year, mm=1, dd=1, s=0, &
                            calendar=time%calendar, rc=ierr )
-        IF ( ierr == ESMF_FAILURE)THEN
+        IF ( ierr == timelib_FAILURE)THEN
            rc = ierr
            RETURN
         END IF
-        CALL ESMF_TimeIntervalSet( day_step, d=1, s=0, rc=ierr )
+        CALL timelib_TimeIntervalSet( day_step, d=1, s=0, rc=ierr )
         dayOfYear_intvl = time - begofyear + day_step
       ENDIF
 
@@ -485,29 +485,29 @@
         rc = ierr
       ENDIF
 
-      end subroutine ESMF_TimeGet
+      end subroutine timelib_TimeGet
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeSet - Initialize via user-specified unit set
+! !IROUTINE: timelib_TimeSet - Initialize via user-specified unit set
 
 ! !INTERFACE:
-      subroutine ESMF_TimeSet(time, YY, YRl, MM, DD, D, Dl, H, M, S, Sl, &
+      subroutine timelib_TimeSet(time, YY, YRl, MM, DD, D, Dl, H, M, S, Sl, &
                               MS, US, NS, d_, h_, m_, s_, ms_, us_, ns_, &
                               Sn, Sd, calendar, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(inout) :: time
+      type(timelib_Time), intent(inout) :: time
       integer, intent(in), optional :: YY
-      integer(ESMF_KIND_I8), intent(in), optional :: YRl
+      integer(timelib_KIND_I8), intent(in), optional :: YRl
       integer, intent(in), optional :: MM
       integer, intent(in), optional :: DD
       integer, intent(in), optional :: D
-      integer(ESMF_KIND_I8), intent(in), optional :: Dl
+      integer(timelib_KIND_I8), intent(in), optional :: Dl
       integer, intent(in), optional :: H
       integer, intent(in), optional :: M
       integer, intent(in), optional :: S
-      integer(ESMF_KIND_I8), intent(in), optional :: Sl
+      integer(timelib_KIND_I8), intent(in), optional :: Sl
       integer, intent(in), optional :: MS
       integer, intent(in), optional :: US
       integer, intent(in), optional :: NS
@@ -520,20 +520,20 @@
       double precision, intent(in), optional :: ns_
       integer, intent(in), optional :: Sn
       integer, intent(in), optional :: Sd
-      type(ESMF_Calendar), intent(in), target, optional :: calendar
+      type(timelib_Calendar), intent(in), target, optional :: calendar
       integer, intent(out), optional :: rc
       ! locals
       INTEGER :: ierr
 
 ! !DESCRIPTION:
-!     Initializes a {\tt ESMF\_Time} with a set of user-specified units
+!     Initializes a {\tt timelib\_Time} with a set of user-specified units
 !     via F90 optional arguments.
 !
 !     Time manager represents and manipulates time internally with integers
 !     to maintain precision. Hence, user-specified floating point values are
 !     converted internally to integers.
 !
-!     See {\tt ../include/ESMC\_BaseTime.h and ../include/ESMC\_Time.h} for
+!     See {\tt ../include/timelibc\_BaseTime.h and ../include/timelibc\_Time.h} for
 !     complete description.
 !
 !     The arguments are:
@@ -589,129 +589,129 @@
 !     \item[{[tz]}]
 !          Associated timezone (hours offset from GMT, e.g. EST = -5)
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMGn.n.n
 !EOP
-!  PRINT *,'DEBUG:  BEGIN ESMF_TimeSet()'
-!$$$ push this down into ESMF_BaseTime constructor
+!  PRINT *,'DEBUG:  BEGIN timelib_TimeSet()'
+!$$$ push this down into timelib_BaseTime constructor
       time%basetime%S  = 0
       time%basetime%Sn = 0
       time%basetime%Sd = 0
 
-      IF ( PRESENT( rc ) ) rc = ESMF_FAILURE
+      IF ( PRESENT( rc ) ) rc = timelib_FAILURE
       time%YR = 0
       IF ( PRESENT( YY ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  YY = ',YY
+!  PRINT *,'DEBUG:  timelib_TimeSet():  YY = ',YY
         time%YR = YY
       ENDIF
       IF ( PRESENT( MM ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  MM = ',MM
+!  PRINT *,'DEBUG:  timelib_TimeSet():  MM = ',MM
         CALL timeaddmonths( time, MM, ierr )
-        IF ( ierr == ESMF_FAILURE ) THEN
+        IF ( ierr == timelib_FAILURE ) THEN
           IF ( PRESENT( rc ) ) THEN
-            rc = ESMF_FAILURE
+            rc = timelib_FAILURE
             RETURN
           ENDIF
         ENDIF
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  back from timeaddmonths'
+!  PRINT *,'DEBUG:  timelib_TimeSet():  back from timeaddmonths'
       ENDIF
       IF ( PRESENT( DD ) ) THEN
 !$$$ no check for DD in range of days of month MM yet
 !$$$ Must separate D and DD for correct interface!
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  DD = ',DD
+!  PRINT *,'DEBUG:  timelib_TimeSet():  DD = ',DD
         time%basetime%S = time%basetime%S + &
-          ( SECONDS_PER_DAY * INT( (DD-1), ESMF_KIND_I8 ) )
+          ( SECONDS_PER_DAY * INT( (DD-1), timelib_KIND_I8 ) )
       ENDIF
-!$$$ push H,M,S,Sn,Sd,MS down into ESMF_BaseTime constructor
+!$$$ push H,M,S,Sn,Sd,MS down into timelib_BaseTime constructor
       IF ( PRESENT( H ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  H = ',H
+!  PRINT *,'DEBUG:  timelib_TimeSet():  H = ',H
         time%basetime%S = time%basetime%S + &
-          ( SECONDS_PER_HOUR * INT( H, ESMF_KIND_I8 ) )
+          ( SECONDS_PER_HOUR * INT( H, timelib_KIND_I8 ) )
       ENDIF
       IF ( PRESENT( M ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  M = ',M
+!  PRINT *,'DEBUG:  timelib_TimeSet():  M = ',M
         time%basetime%S = time%basetime%S + &
-          ( SECONDS_PER_MINUTE * INT( M, ESMF_KIND_I8 ) )
+          ( SECONDS_PER_MINUTE * INT( M, timelib_KIND_I8 ) )
       ENDIF
       IF ( PRESENT( S ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  S = ',S
+!  PRINT *,'DEBUG:  timelib_TimeSet():  S = ',S
         time%basetime%S = time%basetime%S + &
-          INT( S, ESMF_KIND_I8 )
+          INT( S, timelib_KIND_I8 )
       ENDIF
       IF ( PRESENT( Sn ) .AND. ( .NOT. PRESENT( Sd ) ) ) THEN
         CALL wrf_error_fatal( &
-          "ESMF_TimeSet:  Must specify Sd if Sn is specified")
+          "timelib_TimeSet:  Must specify Sd if Sn is specified")
       ENDIF
       IF ( PRESENT( Sd ) .AND. PRESENT( MS ) ) THEN
         CALL wrf_error_fatal( &
-          "ESMF_TimeSet:  Must not specify both Sd and MS")
+          "timelib_TimeSet:  Must not specify both Sd and MS")
       ENDIF
       time%basetime%Sn = 0
       time%basetime%Sd = 0
       IF ( PRESENT( MS ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  MS = ',MS
+!  PRINT *,'DEBUG:  timelib_TimeSet():  MS = ',MS
         time%basetime%Sn = MS
-        time%basetime%Sd = 1000_ESMF_KIND_I8
+        time%basetime%Sd = 1000_timelib_KIND_I8
       ELSE IF ( PRESENT( Sd ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  Sd = ',Sd
+!  PRINT *,'DEBUG:  timelib_TimeSet():  Sd = ',Sd
         time%basetime%Sd = Sd
         IF ( PRESENT( Sn ) ) THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  Sn = ',Sn
+!  PRINT *,'DEBUG:  timelib_TimeSet():  Sn = ',Sn
           time%basetime%Sn = Sn
         ENDIF
       ENDIF
       IF ( PRESENT(calendar) )THEN
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  using passed-in calendar'
-! Note that the ugly hack of wrapping the call to ESMF_CalendarInitialized() 
+!  PRINT *,'DEBUG:  timelib_TimeSet():  using passed-in calendar'
+! Note that the ugly hack of wrapping the call to timelib_CalendarInitialized() 
 ! inside this #ifdef is due to lack of support for compile-time initialization 
 ! of components of Fortran derived types.  Some older compilers like PGI 5.1-x 
 ! do not support this F95 feature.  In this case we only lose a safety check.  
 #ifndef NO_DT_COMPONENT_INIT
-        IF ( .not. ESMF_CalendarInitialized( calendar ) )THEN
-           call wrf_error_fatal( "Error:: ESMF_CalendarCreate not "// &
+        IF ( .not. timelib_CalendarInitialized( calendar ) )THEN
+           call wrf_error_fatal( "Error:: timelib_CalendarCreate not "// &
                                  "called on input Calendar")
         END IF
 #endif
         time%Calendar => calendar
       ELSE
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  using default calendar'
-        IF ( .not. ESMF_IsInitialized() )THEN
-           call wrf_error_fatal( "Error:: ESMF_Initialize not called")
+!  PRINT *,'DEBUG:  timelib_TimeSet():  using default calendar'
+        IF ( .not. timelib_IsInitialized() )THEN
+           call wrf_error_fatal( "Error:: timelib_Initialize not called")
         END IF
         time%Calendar => defaultCal
       END IF
 
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  calling normalize_time()'
+!  PRINT *,'DEBUG:  timelib_TimeSet():  calling normalize_time()'
 !$$$DEBUG
 !IF ( time%basetime%Sd > 0 ) THEN
-!  PRINT *,'DEBUG ESMF_TimeSet() before normalize:  S,Sn,Sd = ', &
+!  PRINT *,'DEBUG timelib_TimeSet() before normalize:  S,Sn,Sd = ', &
 !    time%basetime%S, time%basetime%Sn, time%basetime%Sd
 !ENDIF
 !$$$END DEBUG
       CALL normalize_time( time )
 !$$$DEBUG
 !IF ( time%basetime%Sd > 0 ) THEN
-!  PRINT *,'DEBUG ESMF_TimeSet() after normalize:  S,Sn,Sd = ', &
+!  PRINT *,'DEBUG timelib_TimeSet() after normalize:  S,Sn,Sd = ', &
 !    time%basetime%S, time%basetime%Sn, time%basetime%Sd
 !ENDIF
 !$$$END DEBUG
 
-!  PRINT *,'DEBUG:  ESMF_TimeSet():  back from normalize_time()'
+!  PRINT *,'DEBUG:  timelib_TimeSet():  back from normalize_time()'
       IF ( PRESENT( rc ) ) THEN
-        rc = ESMF_SUCCESS
+        rc = timelib_SUCCESS
       ENDIF
 
-      end subroutine ESMF_TimeSet
+      end subroutine timelib_TimeSet
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMFold_TimeGetString - Get time instant value in string format
+! !IROUTINE:  timelibold_TimeGetString - Get time instant value in string format
 
 ! !INTERFACE:
-      subroutine ESMFold_TimeGetString( year, month, dayofmonth, &
+      subroutine timelibold_TimeGetString( year, month, dayofmonth, &
                                         hour, minute, second, TimeString )
 
 ! !ARGUMENTS:
@@ -723,7 +723,7 @@
       integer, intent(in) :: second
       character*(*), intent(out) :: TimeString
 ! !DESCRIPTION:
-!     Convert {\tt ESMF\_Time}'s value into ISO 8601 format YYYY-MM-DDThh:mm:ss
+!     Convert {\tt timelib\_Time}'s value into ISO 8601 format YYYY-MM-DDThh:mm:ss
 !
 !     The arguments are:
 !     \begin{description}
@@ -732,19 +732,19 @@
 !     \item[TimeString]
 !          The string to return
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG2.4.7
 !EOP
 
-!PRINT *,'DEBUG:  ESMF_TimePrint():  YR,S,Sn,Sd = ',time%YR,time%basetime%S,time%basetime%Sn,time%basetime%Sd
-!PRINT *,'DEBUG:  ESMF_TimePrint():  year = ',year
-!PRINT *,'DEBUG:  ESMF_TimePrint():  month, dayofmonth = ',month,dayofmonth
-!PRINT *,'DEBUG:  ESMF_TimePrint():  hour = ',hour
-!PRINT *,'DEBUG:  ESMF_TimePrint():  minute = ',minute
-!PRINT *,'DEBUG:  ESMF_TimePrint():  second = ',second
+!PRINT *,'DEBUG:  timelib_TimePrint():  YR,S,Sn,Sd = ',time%YR,time%basetime%S,time%basetime%Sn,time%basetime%Sd
+!PRINT *,'DEBUG:  timelib_TimePrint():  year = ',year
+!PRINT *,'DEBUG:  timelib_TimePrint():  month, dayofmonth = ',month,dayofmonth
+!PRINT *,'DEBUG:  timelib_TimePrint():  hour = ',hour
+!PRINT *,'DEBUG:  timelib_TimePrint():  minute = ',minute
+!PRINT *,'DEBUG:  timelib_TimePrint():  second = ',second
 
 !$$$here...  add negative sign for YR<0
 !$$$here...  add Sn, Sd ??
@@ -756,22 +756,22 @@
              year,month,dayofmonth,hour,minute,second
 #endif
 
-      end subroutine ESMFold_TimeGetString
+      end subroutine timelibold_TimeGetString
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeGetDayOfYearInteger - Get time instant's day of the year as an integer value
+! !IROUTINE: timelib_TimeGetDayOfYearInteger - Get time instant's day of the year as an integer value
 !
 ! !INTERFACE:
-      subroutine ESMF_TimeGetDayOfYearInteger(time, DayOfYear, rc)
+      subroutine timelib_TimeGetDayOfYearInteger(time, DayOfYear, rc)
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time
+      type(timelib_Time), intent(in) :: time
       integer, intent(out) :: DayOfYear
       integer, intent(out), optional :: rc
 !
 ! !DESCRIPTION:
-!     Get the day of the year the given {\tt ESMF\_Time} instant falls on
+!     Get the day of the year the given {\tt timelib\_Time} instant falls on
 !     (1-365).  Returned as an integer value
 !
 !     The arguments are:
@@ -779,9 +779,9 @@
 !     \item[time]
 !          The object instance to query
 !     \item[DayOfYear]
-!          The {\tt ESMF\_Time} instant's day of the year (1-365)
+!          The {\tt timelib\_Time} instant's day of the year (1-365)
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -790,175 +790,175 @@
 !$$$ bug when Sn>0?  test
 !$$$ add tests
       DayOfYear = ( time%basetime%S / SECONDS_PER_DAY ) + 1
-      IF ( PRESENT( rc ) ) rc = ESMF_SUCCESS
-      end subroutine ESMF_TimeGetDayOfYearInteger
+      IF ( PRESENT( rc ) ) rc = timelib_SUCCESS
+      end subroutine timelib_TimeGetDayOfYearInteger
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeInc - Increment time instant with a time interval
+! !IROUTINE: timelib_TimeInc - Increment time instant with a time interval
 !
 ! !INTERFACE:
-      function ESMF_TimeInc(time, timeinterval)
+      function timelib_TimeInc(time, timeinterval)
 !
 ! !RETURN VALUE:
-      type(ESMF_Time) :: ESMF_TimeInc
+      type(timelib_Time) :: timelib_TimeInc
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_Time), intent(in) :: time
+      type(timelib_TimeInterval), intent(in) :: timeinterval
 ! !LOCAL:
       integer   :: rc
 !
 ! !DESCRIPTION:
-!     Increment {\tt ESMF\_Time} instant with a {\tt ESMF\_TimeInterval},
-!     return resulting {\tt ESMF\_Time} instant
+!     Increment {\tt timelib\_Time} instant with a {\tt timelib\_TimeInterval},
+!     return resulting {\tt timelib\_Time} instant
 !
 !     Maps overloaded (+) operator interface function to
-!     {\tt ESMF\_BaseTime} base class
+!     {\tt timelib\_BaseTime} base class
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[time]
-!          The given {\tt ESMF\_Time} to increment
+!          The given {\tt timelib\_Time} to increment
 !     \item[timeinterval]
-!          The {\tt ESMF\_TimeInterval} to add to the given {\tt ESMF\_Time}
+!          The {\tt timelib\_TimeInterval} to add to the given {\tt timelib\_Time}
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG1.5.4, TMG2.4.4, TMG2.4.5, TMG2.4.6, TMG5.1, TMG5.2, TMG7.2
 !EOP
 
-      ! copy ESMF_Time specific properties (e.g. calendar, timezone) 
-      ESMF_TimeInc = time
+      ! copy timelib_Time specific properties (e.g. calendar, timezone) 
+      timelib_TimeInc = time
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeSum(time, timeinterval, ESMF_TimeInc)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeSum(time, timeinterval, timelib_TimeInc)
 
-      end function ESMF_TimeInc
+      end function timelib_TimeInc
 !
 ! this is added for certain compilers that don't deal with commutativity
 !
-      function ESMF_TimeInc2(timeinterval, time)
-      type(ESMF_Time) :: ESMF_TimeInc2
-      type(ESMF_Time), intent(in) :: time
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
-      ESMF_TimeInc2 = ESMF_TimeInc( time, timeinterval )
-      end function ESMF_TimeInc2
+      function timelib_TimeInc2(timeinterval, time)
+      type(timelib_Time) :: timelib_TimeInc2
+      type(timelib_Time), intent(in) :: time
+      type(timelib_TimeInterval), intent(in) :: timeinterval
+      timelib_TimeInc2 = timelib_TimeInc( time, timeinterval )
+      end function timelib_TimeInc2
 !
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeDec - Decrement time instant with a time interval
+! !IROUTINE: timelib_TimeDec - Decrement time instant with a time interval
 !
 ! !INTERFACE:
-      function ESMF_TimeDec(time, timeinterval)
+      function timelib_TimeDec(time, timeinterval)
 !
 ! !RETURN VALUE:
-      type(ESMF_Time) :: ESMF_TimeDec
+      type(timelib_Time) :: timelib_TimeDec
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_Time), intent(in) :: time
+      type(timelib_TimeInterval), intent(in) :: timeinterval
 ! !LOCAL:
       integer   :: rc
 !
 ! !DESCRIPTION:
-!     Decrement {\tt ESMF\_Time} instant with a {\tt ESMF\_TimeInterval},
-!     return resulting {\tt ESMF\_Time} instant
+!     Decrement {\tt timelib\_Time} instant with a {\tt timelib\_TimeInterval},
+!     return resulting {\tt timelib\_Time} instant
 !
 !     Maps overloaded (-) operator interface function to
-!     {\tt ESMF\_BaseTime} base class
+!     {\tt timelib\_BaseTime} base class
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[time]
-!          The given {\tt ESMF\_Time} to decrement
+!          The given {\tt timelib\_Time} to decrement
 !     \item[timeinterval]
-!          The {\tt ESMF\_TimeInterval} to subtract from the given
-!          {\tt ESMF\_Time}
+!          The {\tt timelib\_TimeInterval} to subtract from the given
+!          {\tt timelib\_Time}
 !     \end{description}
 !     
 ! !REQUIREMENTS:
 !     TMG1.5.4, TMG2.4.4, TMG2.4.5, TMG2.4.6, TMG5.1, TMG5.2, TMG7.2
 !EOP
 
-      ! copy ESMF_Time specific properties (e.g. calendar, timezone) 
-      ESMF_TimeDec = time
+      ! copy timelib_Time specific properties (e.g. calendar, timezone) 
+      timelib_TimeDec = time
 
-      ! call ESMC_BaseTime base class function
-       call c_ESMC_BaseTimeDec(time, timeinterval, ESMF_TimeDec)
+      ! call timelibc_BaseTime base class function
+       call c_timelibc_BaseTimeDec(time, timeinterval, timelib_TimeDec)
 
-      end function ESMF_TimeDec
+      end function timelib_TimeDec
 
 !
 ! this is added for certain compilers that don't deal with commutativity
 !
-      function ESMF_TimeDec2(timeinterval, time)
-      type(ESMF_Time) :: ESMF_TimeDec2
-      type(ESMF_Time), intent(in) :: time
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
-      ESMF_TimeDec2 = ESMF_TimeDec( time, timeinterval )
-      end function ESMF_TimeDec2
+      function timelib_TimeDec2(timeinterval, time)
+      type(timelib_Time) :: timelib_TimeDec2
+      type(timelib_Time), intent(in) :: time
+      type(timelib_TimeInterval), intent(in) :: timeinterval
+      timelib_TimeDec2 = timelib_TimeDec( time, timeinterval )
+      end function timelib_TimeDec2
 !
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeDiff - Return the difference between two time instants
+! !IROUTINE:  timelib_TimeDiff - Return the difference between two time instants
 !
 ! !INTERFACE:
-      function ESMF_TimeDiff(time1, time2)
+      function timelib_TimeDiff(time1, time2)
 !
 ! !RETURN VALUE:
-      type(ESMF_TimeInterval) :: ESMF_TimeDiff
+      type(timelib_TimeInterval) :: timelib_TimeDiff
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
 ! !LOCAL:
       integer :: rc
 
 ! !DESCRIPTION:
-!     Return the {\tt ESMF\_TimeInterval} difference between two
-!     {\tt ESMF\_Time} instants
+!     Return the {\tt timelib\_TimeInterval} difference between two
+!     {\tt timelib\_Time} instants
 !
 !     Maps overloaded (-) operator interface function to
-!     {\tt ESMF\_BaseTime} base class
+!     {\tt timelib\_BaseTime} base class
 !
 !     The arguments are:
 !     \begin{description}
 !     \item[time1]
-!          The first {\tt ESMF\_Time} instant
+!          The first {\tt timelib\_Time} instant
 !     \item[time2]
-!          The second {\tt ESMF\_Time} instant
+!          The second {\tt timelib\_Time} instant
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMG1.5.4, TMG2.4.4, TMG2.4.5, TMG2.4.6, TMG5.1, TMG5.2, TMG7.2
 !EOP
 
-      ! call ESMC_BaseTime base class function
-      CALL ESMF_TimeIntervalSet( ESMF_TimeDiff, rc=rc )
-      call c_ESMC_BaseTimeDiff(time1, time2, ESMF_TimeDiff)
+      ! call timelibc_BaseTime base class function
+      CALL timelib_TimeIntervalSet( timelib_TimeDiff, rc=rc )
+      call c_timelibc_BaseTimeDiff(time1, time2, timelib_TimeDiff)
 
-      end function ESMF_TimeDiff
+      end function timelib_TimeDiff
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeEQ - Compare two times for equality
+! !IROUTINE: timelib_TimeEQ - Compare two times for equality
 !
 ! !INTERFACE:
-      function ESMF_TimeEQ(time1, time2)
+      function timelib_TimeEQ(time1, time2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeEQ
+      logical :: timelib_TimeEQ
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
 !
 ! !DESCRIPTION:
-!     Return true if both given {\tt ESMF\_Time} instants are equal, false
+!     Return true if both given {\tt timelib\_Time} instants are equal, false
 !     otherwise.  Maps overloaded (==) operator interface function to
-!     {\tt ESMF\_BaseTime} base class.
+!     {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -972,29 +972,29 @@
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
 
-      ! invoke C to C++ entry point for ESMF_BaseTime base class function
-      call c_ESMC_BaseTimeEQ(time1, time2, ESMF_TimeEQ)
+      ! invoke C to C++ entry point for timelib_BaseTime base class function
+      call c_timelibc_BaseTimeEQ(time1, time2, timelib_TimeEQ)
 
-      end function ESMF_TimeEQ
+      end function timelib_TimeEQ
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeNE - Compare two times for non-equality
+! !IROUTINE: timelib_TimeNE - Compare two times for non-equality
 !
 ! !INTERFACE:
-      function ESMF_TimeNE(time1, time2)
+      function timelib_TimeNE(time1, time2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeNE
+      logical :: timelib_TimeNE
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
 
 ! !DESCRIPTION:
-!     Return true if both given {\tt ESMF\_Time} instants are not equal, false
+!     Return true if both given {\tt timelib\_Time} instants are not equal, false
 !     otherwise.  Maps overloaded (/=) operator interface function to
-!     {\tt ESMF\_BaseTime} base class.
+!     {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -1008,29 +1008,29 @@
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeNE(time1, time2, ESMF_TimeNE)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeNE(time1, time2, timelib_TimeNE)
 
-      end function ESMF_TimeNE
+      end function timelib_TimeNE
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeLT - Time instant 1 less than time instant 2 ?
+! !IROUTINE: timelib_TimeLT - Time instant 1 less than time instant 2 ?
 !
 ! !INTERFACE:
-      function ESMF_TimeLT(time1, time2)
+      function timelib_TimeLT(time1, time2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeLT
+      logical :: timelib_TimeLT
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
 !
 ! !DESCRIPTION:
-!     Return true if first {\tt ESMF\_Time} instant is less than second
-!     {\tt ESMF\_Time} instant, false otherwise.  Maps overloaded (<)
-!     operator interface function to {\tt ESMF\_BaseTime} base class.
+!     Return true if first {\tt timelib\_Time} instant is less than second
+!     {\tt timelib\_Time} instant, false otherwise.  Maps overloaded (<)
+!     operator interface function to {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -1044,29 +1044,29 @@
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeLT(time1, time2, ESMF_TimeLT)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeLT(time1, time2, timelib_TimeLT)
 
-      end function ESMF_TimeLT
+      end function timelib_TimeLT
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeGT - Time instant 1 greater than time instant 2 ?
+! !IROUTINE: timelib_TimeGT - Time instant 1 greater than time instant 2 ?
 !
 ! !INTERFACE:
-      function ESMF_TimeGT(time1, time2)
+      function timelib_TimeGT(time1, time2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeGT
+      logical :: timelib_TimeGT
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
 !
 ! !DESCRIPTION:
-!     Return true if first {\tt ESMF\_Time} instant is greater than second
-!     {\tt ESMF\_Time} instant, false otherwise.  Maps overloaded (>) operator
-!     interface function to {\tt ESMF\_BaseTime} base class.
+!     Return true if first {\tt timelib\_Time} instant is greater than second
+!     {\tt timelib\_Time} instant, false otherwise.  Maps overloaded (>) operator
+!     interface function to {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -1080,29 +1080,29 @@
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeGT(time1, time2, ESMF_TimeGT)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeGT(time1, time2, timelib_TimeGT)
 
-      end function ESMF_TimeGT
+      end function timelib_TimeGT
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeLE - Time instant 1 less than or equal to time instant 2 ?
+! !IROUTINE: timelib_TimeLE - Time instant 1 less than or equal to time instant 2 ?
 !
 ! !INTERFACE:
-      function ESMF_TimeLE(time1, time2)
+      function timelib_TimeLE(time1, time2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeLE
+      logical :: timelib_TimeLE
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
 !
 ! !DESCRIPTION:
-!     Return true if first {\tt ESMF\_Time} instant is less than or equal to
-!     second {\tt ESMF\_Time} instant, false otherwise.  Maps overloaded (<=)
-!     operator interface function to {\tt ESMF\_BaseTime} base class.
+!     Return true if first {\tt timelib\_Time} instant is less than or equal to
+!     second {\tt timelib\_Time} instant, false otherwise.  Maps overloaded (<=)
+!     operator interface function to {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -1116,29 +1116,29 @@
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeLE(time1, time2, ESMF_TimeLE)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeLE(time1, time2, timelib_TimeLE)
 
-      end function ESMF_TimeLE
+      end function timelib_TimeLE
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeGE - Time instant 1 greater than or equal to time instant 2 ?
+! !IROUTINE: timelib_TimeGE - Time instant 1 greater than or equal to time instant 2 ?
 !
 ! !INTERFACE:
-      function ESMF_TimeGE(time1, time2)
+      function timelib_TimeGE(time1, time2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeGE
+      logical :: timelib_TimeGE
 !
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
 !
 ! !DESCRIPTION:
-!     Return true if first {\tt ESMF\_Time} instant is greater than or equal to
-!     second {\tt ESMF\_Time} instant, false otherwise.  Maps overloaded (>=)
-!     operator interface function to {\tt ESMF\_BaseTime} base class.
+!     Return true if first {\tt timelib\_Time} instant is greater than or equal to
+!     second {\tt timelib\_Time} instant, false otherwise.  Maps overloaded (>=)
+!     operator interface function to {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -1152,27 +1152,27 @@
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeGE(time1, time2, ESMF_TimeGE)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeGE(time1, time2, timelib_TimeGE)
 
-      end function ESMF_TimeGE
+      end function timelib_TimeGE
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeCopy - Copy a time-instance
+! !IROUTINE:  timelib_TimeCopy - Copy a time-instance
 
 ! !INTERFACE:
-      subroutine ESMF_TimeCopy(timeout, timein)
+      subroutine timelib_TimeCopy(timeout, timein)
 
 ! !ARGUMENTS:
-      type(ESMF_Time), intent(out) :: timeout
-      type(ESMF_Time), intent(in) :: timein
+      type(timelib_Time), intent(out) :: timeout
+      type(timelib_Time), intent(in) :: timein
 
 ! !DESCRIPTION:
 !     Copy a time-instance to a new instance.
 !
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -1183,6 +1183,6 @@
       timeout%YR       = timein%YR
       timeout%Calendar => timein%Calendar
 
-      end subroutine ESMF_TimeCopy
+      end subroutine timelib_TimeCopy
 
-      end module ESMF_TimeMod
+      end module timelib_TimeMod
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_TimeInterval.F90 WRFV3.9.patch/external/esmf_time_f90/ESMF_TimeInterval.F90
--- WRFV3.9/external/esmf_time_f90/ESMF_TimeInterval.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_TimeInterval.F90	2017-07-03 16:17:29.683926000 -0400
@@ -9,8 +9,8 @@
 !
 !==============================================================================
 !
-!     ESMF TimeInterval Module
-      module ESMF_TimeIntervalMod
+!     timelib TimeInterval Module
+      module timelib_TimeIntervalMod
 !
 !==============================================================================
 !
@@ -19,31 +19,31 @@
 !
 !------------------------------------------------------------------------------
 ! INCLUDES
-#include <ESMF_TimeMgr.inc>
+#include <timelib_TimeMgr.inc>
 !
 !===============================================================================
 !BOPI
-! !MODULE: ESMF_TimeIntervalMod
+! !MODULE: timelib_TimeIntervalMod
 !
 ! !DESCRIPTION:
 ! Part of Time Manager F90 API wrapper of C++ implemenation
 !
 ! Defines F90 wrapper entry points for corresponding
-! C++ implementaion of class {\tt ESMC\_TimeInterval}
+! C++ implementaion of class {\tt timelibc\_TimeInterval}
 !
-! See {\tt ../include/ESMC\_TimeInterval.h} for complete description
+! See {\tt ../include/timelibc\_TimeInterval.h} for complete description
 !
 !------------------------------------------------------------------------------
 ! !USES:
-      ! inherit from ESMF base class
-      use ESMF_BaseMod
+      ! inherit from timelib base class
+      use timelib_BaseMod
 
       ! inherit from base time class
-      use ESMF_BaseTimeMod
+      use timelib_BaseTimeMod
 
       ! associated derived types
-      use ESMF_FractionMod, only : ESMF_Fraction
-      use ESMF_CalendarMod
+      use timelib_FractionMod, only : timelib_Fraction
+      use timelib_CalendarMod
 
       implicit none
 !
@@ -51,14 +51,14 @@
 ! !PRIVATE TYPES:
       private
 !------------------------------------------------------------------------------
-!     ! ESMF_TimeInterval
+!     ! timelib_TimeInterval
 !
 !     ! F90 class type to match C++ TimeInterval class in size only;
 !     !  all dereferencing within class is performed by C++ implementation
 
-      type ESMF_TimeInterval
+      type timelib_TimeInterval
         ! time interval is expressed as basetime
-        type(ESMF_BaseTime) :: basetime  ! inherit base class
+        type(timelib_BaseTime) :: basetime  ! inherit base class
         ! Relative year and month fields support monthly or yearly time 
         ! intervals.  Many operations are undefined when these fields are 
         ! non-zero!  
@@ -69,26 +69,26 @@
 
 !------------------------------------------------------------------------------
 ! !PUBLIC TYPES:
-      public ESMF_TimeInterval
+      public timelib_TimeInterval
 !------------------------------------------------------------------------------
 !
 ! !PUBLIC MEMBER FUNCTIONS:
-      public ESMF_TimeIntervalGet
-      public ESMF_TimeIntervalSet
-      public ESMFold_TimeIntervalGetString
-      public ESMF_TimeIntervalAbsValue
-      public ESMF_TimeIntervalNegAbsValue
+      public timelib_TimeIntervalGet
+      public timelib_TimeIntervalSet
+      public timelibold_TimeIntervalGetString
+      public timelib_TimeIntervalAbsValue
+      public timelib_TimeIntervalNegAbsValue
 
-! Required inherited and overridden ESMF_Base class methods
+! Required inherited and overridden timelib_Base class methods
 
 !!!!!!!!! added 20051012, JM
 !      public WRFADDITION_TimeIntervalDIVQuot 
 !!!!!!!!! renamed to simplify testing 20060320, TH
-      public ESMF_TimeIntervalDIVQuot 
+      public timelib_TimeIntervalDIVQuot 
 
       ! This convenience routine is only used by other modules in 
-      ! esmf_time_f90.  
-      public ESMF_TimeIntervalIsPositive
+      ! timelib_time_f90.  
+      public timelib_TimeIntervalIsPositive
 
 
 ! !PRIVATE MEMBER FUNCTIONS:
@@ -96,36 +96,36 @@
 ! overloaded operator functions
  
       public operator(/)
-      private ESMF_TimeIntervalQuotI
+      private timelib_TimeIntervalQuotI
 
       public operator(*)
-      private ESMF_TimeIntervalProdI
+      private timelib_TimeIntervalProdI
 
-! Inherited and overloaded from ESMF_BaseTime
+! Inherited and overloaded from timelib_BaseTime
 
       public operator(+)
-      private ESMF_TimeIntervalSum
+      private timelib_TimeIntervalSum
 
       public operator(-)
-      private ESMF_TimeIntervalDiff
+      private timelib_TimeIntervalDiff
 
       public operator(.EQ.)
-      private ESMF_TimeIntervalEQ
+      private timelib_TimeIntervalEQ
 
       public operator(.NE.)
-      private ESMF_TimeIntervalNE
+      private timelib_TimeIntervalNE
 
       public operator(.LT.)
-      private ESMF_TimeIntervalLT
+      private timelib_TimeIntervalLT
 
       public operator(.GT.)
-      private ESMF_TimeIntervalGT
+      private timelib_TimeIntervalGT
 
       public operator(.LE.)
-      private ESMF_TimeIntervalLE
+      private timelib_TimeIntervalLE
 
       public operator(.GE.)
-      private ESMF_TimeIntervalGE
+      private timelib_TimeIntervalGE
 !EOPI
 
 !==============================================================================
@@ -138,10 +138,10 @@
       interface operator(*)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalProdI
+      module procedure timelib_TimeIntervalProdI
 
 ! !DESCRIPTION:
-!     This interface overloads the * operator for the {\tt ESMF\_TimeInterval}
+!     This interface overloads the * operator for the {\tt timelib\_TimeInterval}
 !     class
 !
 !EOP
@@ -153,11 +153,11 @@
       interface operator(/)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalQuotI
+      module procedure timelib_TimeIntervalQuotI
 
 ! !DESCRIPTION:
 !     This interface overloads the / operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -168,11 +168,11 @@
       interface operator(+)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalSum
+      module procedure timelib_TimeIntervalSum
 
 ! !DESCRIPTION:
 !     This interface overloads the + operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -183,11 +183,11 @@
       interface operator(-)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalDiff
+      module procedure timelib_TimeIntervalDiff
 
 ! !DESCRIPTION:
 !     This interface overloads the - operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -198,11 +198,11 @@
       interface operator(.EQ.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalEQ
+      module procedure timelib_TimeIntervalEQ
 
 ! !DESCRIPTION:
 !     This interface overloads the .EQ. operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -213,11 +213,11 @@
       interface operator(.NE.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalNE
+      module procedure timelib_TimeIntervalNE
 
 ! !DESCRIPTION:
 !     This interface overloads the .NE. operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -228,11 +228,11 @@
       interface operator(.LT.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalLT
+      module procedure timelib_TimeIntervalLT
 
 ! !DESCRIPTION:
 !     This interface overloads the .LT. operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -243,11 +243,11 @@
       interface operator(.GT.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalGT
+      module procedure timelib_TimeIntervalGT
 
 ! !DESCRIPTION:
 !     This interface overloads the .GT. operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -258,11 +258,11 @@
       interface operator(.LE.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalLE
+      module procedure timelib_TimeIntervalLE
 
 ! !DESCRIPTION:
 !     This interface overloads the .LE. operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -273,11 +273,11 @@
       interface operator(.GE.)
 
 ! !PRIVATE MEMBER FUNCTIONS:
-      module procedure ESMF_TimeIntervalGE
+      module procedure timelib_TimeIntervalGE
 
 ! !DESCRIPTION:
 !     This interface overloads the .GE. operator for the
-!     {\tt ESMF\_TimeInterval} class
+!     {\tt timelib\_TimeInterval} class
 !
 !EOP
       end interface
@@ -294,17 +294,17 @@
 !
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeIntervalGet - Get value in user-specified units
+! !IROUTINE: timelib_TimeIntervalGet - Get value in user-specified units
 
 ! !INTERFACE:
-      subroutine ESMF_TimeIntervalGet(timeinterval, D, d_r8, S, S_i8, Sn, Sd, &
+      subroutine timelib_TimeIntervalGet(timeinterval, D, d_r8, S, S_i8, Sn, Sd, &
                                       TimeString, rc )
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_TimeInterval), intent(in) :: timeinterval
       integer, intent(out), optional :: D
-      real(ESMF_KIND_R8),     intent(out), optional :: d_r8
-      integer(ESMF_KIND_I8),  intent(out), optional :: S_i8
+      real(timelib_KIND_R8),     intent(out), optional :: d_r8
+      integer(timelib_KIND_I8),  intent(out), optional :: S_i8
       integer, intent(out), optional :: S
       integer, intent(out), optional :: Sn
       integer, intent(out), optional :: Sd
@@ -313,15 +313,15 @@
 
 
 ! !DESCRIPTION:
-!     Get the value of the {\tt ESMF\_TimeInterval} in units specified by the
+!     Get the value of the {\tt timelib\_TimeInterval} in units specified by the
 !     user via F90 optional arguments.
 !
 !     Time manager represents and manipulates time internally with integers 
 !     to maintain precision.  Hence, user-specified floating point values are
 !     converted internally from integers.
 !
-!     See {\tt ../include/ESMC\_BaseTime.h} and
-!     {\tt ../include/ESMC\_TimeInterval.h} for complete description.
+!     See {\tt ../include/timelibc\_BaseTime.h} and
+!     {\tt ../include/timelibc\_TimeInterval.h} for complete description.
 !     
 !     The arguments are:
 !     \begin{description}
@@ -372,7 +372,7 @@
 !     \item[{[Sd]}]
 !          Integer fractional seconds - denominator
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -382,10 +382,10 @@
 ! William.Gustafson@pnl.gov; 9-May-2008
 !
 !EOP
-      INTEGER(ESMF_KIND_I8) :: seconds
+      INTEGER(timelib_KIND_I8) :: seconds
       INTEGER :: ierr
 
-      ierr = ESMF_SUCCESS
+      ierr = timelib_SUCCESS
       seconds = timeinterval%basetime%S
       ! note that S is overwritten below (if present) if other args are also 
       ! present
@@ -397,8 +397,8 @@
         IF ( PRESENT(S_i8) ) S_i8 = MOD( seconds, SECONDS_PER_DAY )
       ENDIF
       IF ( PRESENT( d_r8 ) ) THEN
-        D_r8 = REAL( seconds, ESMF_KIND_R8 ) / &
-               REAL( SECONDS_PER_DAY, ESMF_KIND_R8 )
+        D_r8 = REAL( seconds, timelib_KIND_R8 ) / &
+               REAL( SECONDS_PER_DAY, timelib_KIND_R8 )
         IF ( PRESENT(S) )    S    = MOD( seconds, SECONDS_PER_DAY )
         IF ( PRESENT(S_i8) ) S_i8 = MOD( seconds, SECONDS_PER_DAY )
       ENDIF
@@ -409,34 +409,34 @@
         Sd = timeinterval%basetime%Sd
       ENDIF
       IF ( PRESENT( timeString ) ) THEN
-        CALL ESMFold_TimeIntervalGetString( timeinterval, timeString, rc=ierr )
+        CALL timelibold_TimeIntervalGetString( timeinterval, timeString, rc=ierr )
       ENDIF
       IF ( PRESENT(rc) ) rc = ierr
     
-      end subroutine ESMF_TimeIntervalGet
+      end subroutine timelib_TimeIntervalGet
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeIntervalSet - Initialize via user-specified unit set
+! !IROUTINE: timelib_TimeIntervalSet - Initialize via user-specified unit set
 
 ! !INTERFACE:
-      subroutine ESMF_TimeIntervalSet(timeinterval, YY, YYl, MM, MOl, D, Dl, &
+      subroutine timelib_TimeIntervalSet(timeinterval, YY, YYl, MM, MOl, D, Dl, &
                                       H, M, S, Sl, MS, US, NS, &
                                       d_, h_, m_, s_, ms_, us_, ns_, &
                                       Sn, Sd, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(out) :: timeinterval
+      type(timelib_TimeInterval), intent(out) :: timeinterval
       integer, intent(in), optional :: YY
-      integer(ESMF_KIND_I8), intent(in), optional :: YYl
+      integer(timelib_KIND_I8), intent(in), optional :: YYl
       integer, intent(in), optional :: MM
-      integer(ESMF_KIND_I8), intent(in), optional :: MOl
+      integer(timelib_KIND_I8), intent(in), optional :: MOl
       integer, intent(in), optional :: D
-      integer(ESMF_KIND_I8), intent(in), optional :: Dl
+      integer(timelib_KIND_I8), intent(in), optional :: Dl
       integer, intent(in), optional :: H
       integer, intent(in), optional :: M
       integer, intent(in), optional :: S
-      integer(ESMF_KIND_I8), intent(in), optional :: Sl
+      integer(timelib_KIND_I8), intent(in), optional :: Sl
       integer, intent(in), optional :: MS
       integer, intent(in), optional :: US
       integer, intent(in), optional :: NS
@@ -454,15 +454,15 @@
       INTEGER :: nfeb
 
 ! !DESCRIPTION:
-!     Set the value of the {\tt ESMF\_TimeInterval} in units specified by
+!     Set the value of the {\tt timelib\_TimeInterval} in units specified by
 !     the user via F90 optional arguments
 !
 !     Time manager represents and manipulates time internally with integers 
 !     to maintain precision.  Hence, user-specified floating point values are
 !     converted internally to integers.
 !
-!     See {\tt ../include/ESMC\_BaseTime.h} and
-!     {\tt ../include/ESMC\_TimeInterval.h} for complete description.
+!     See {\tt ../include/timelibc\_BaseTime.h} and
+!     {\tt ../include/timelibc\_TimeInterval.h} for complete description.
 !
 !     The arguments are:
 !     \begin{description}
@@ -513,14 +513,14 @@
 !     \item[{[Sd]}]
 !          Integer fractional seconds - denominator
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
 !     TMGn.n.n
 !EOP
 
-      IF ( PRESENT(rc) ) rc = ESMF_FAILURE
+      IF ( PRESENT(rc) ) rc = timelib_FAILURE
       ! note that YR and MM are relative
       timeinterval%YR = 0
       IF ( PRESENT( YY ) ) THEN
@@ -542,41 +542,41 @@
 !$$$ replace this hack with something saner...
       IF ( nfeb( 2004 ) == 28 ) THEN
         timeinterval%basetime%S = timeinterval%basetime%S + &
-          ( 365_ESMF_KIND_I8 * &
-            INT( timeinterval%YR, ESMF_KIND_I8 ) * SECONDS_PER_DAY )
+          ( 365_timelib_KIND_I8 * &
+            INT( timeinterval%YR, timelib_KIND_I8 ) * SECONDS_PER_DAY )
         timeinterval%YR = 0
       ENDIF
       IF ( PRESENT( D ) ) THEN
         timeinterval%basetime%S = timeinterval%basetime%S + &
-          ( SECONDS_PER_DAY * INT( D, ESMF_KIND_I8 ) )
+          ( SECONDS_PER_DAY * INT( D, timelib_KIND_I8 ) )
       ENDIF
 !$$$ Push H,M,S,Sn,Sd,MS down into BaseTime constructor from EVERYWHERE
-!$$$ and THEN add ESMF scaling behavior when other args are present...  
+!$$$ and THEN add timelib scaling behavior when other args are present...  
       IF ( PRESENT( H ) ) THEN
         timeinterval%basetime%S = timeinterval%basetime%S + &
-          ( SECONDS_PER_HOUR * INT( H, ESMF_KIND_I8 ) )
+          ( SECONDS_PER_HOUR * INT( H, timelib_KIND_I8 ) )
       ENDIF
       IF ( PRESENT( M ) ) THEN
         timeinterval%basetime%S = timeinterval%basetime%S + &
-          ( SECONDS_PER_MINUTE * INT( M, ESMF_KIND_I8 ) )
+          ( SECONDS_PER_MINUTE * INT( M, timelib_KIND_I8 ) )
       ENDIF
       IF ( PRESENT( S ) ) THEN
         timeinterval%basetime%S = timeinterval%basetime%S + &
-          INT( S, ESMF_KIND_I8 )
+          INT( S, timelib_KIND_I8 )
       ENDIF
       IF ( PRESENT( Sn ) .AND. ( .NOT. PRESENT( Sd ) ) ) THEN
         CALL wrf_error_fatal( &
-          "ESMF_TimeIntervalSet:  Must specify Sd if Sn is specified")
+          "timelib_TimeIntervalSet:  Must specify Sd if Sn is specified")
       ENDIF
       IF ( PRESENT( Sd ) .AND. PRESENT( MS ) ) THEN
         CALL wrf_error_fatal( &
-          "ESMF_TimeIntervalSet:  Must not specify both Sd and MS")
+          "timelib_TimeIntervalSet:  Must not specify both Sd and MS")
       ENDIF
       timeinterval%basetime%Sn = 0
       timeinterval%basetime%Sd = 0
       IF ( PRESENT( MS ) ) THEN
         timeinterval%basetime%Sn = MS
-        timeinterval%basetime%Sd = 1000_ESMF_KIND_I8
+        timeinterval%basetime%Sd = 1000_timelib_KIND_I8
       ELSE IF ( PRESENT( Sd ) ) THEN
         timeinterval%basetime%Sd = Sd
         IF ( PRESENT( Sn ) ) THEN
@@ -585,29 +585,29 @@
       ENDIF
       CALL normalize_timeint( timeinterval )
 
-      IF ( PRESENT(rc) ) rc = ESMF_SUCCESS
+      IF ( PRESENT(rc) ) rc = timelib_SUCCESS
 
-      end subroutine ESMF_TimeIntervalSet
+      end subroutine timelib_TimeIntervalSet
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMFold_TimeIntervalGetString - Get time interval value in string format
+! !IROUTINE:  timelibold_TimeIntervalGetString - Get time interval value in string format
 
 ! !INTERFACE:
-      subroutine ESMFold_TimeIntervalGetString(timeinterval, TimeString, rc)
+      subroutine timelibold_TimeIntervalGetString(timeinterval, TimeString, rc)
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_TimeInterval), intent(in) :: timeinterval
       character*(*),  intent(out) :: TimeString
       integer, intent(out), optional :: rc
       ! locals
       integer :: signnormtimeint
       LOGICAL :: negative
-      INTEGER(ESMF_KIND_I8) :: iS, iSn, iSd, H, M, S
+      INTEGER(timelib_KIND_I8) :: iS, iSn, iSd, H, M, S
       character (len=1) :: signstr
 
 ! !DESCRIPTION:
-!     Convert {\tt ESMF\_TimeInterval}'s value into string format
+!     Convert {\tt timelib\_TimeInterval}'s value into string format
 !
 !     The arguments are:
 !     \begin{description}
@@ -616,7 +616,7 @@
 !     \item[TimeString]
 !          The string to return
 !     \item[{[rc]}]
-!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
+!          Return code; equals {\tt timelib\_SUCCESS} if there are no errors.
 !     \end{description}
 !
 ! !REQUIREMENTS:
@@ -624,7 +624,7 @@
 !EOP
 
 ! NOTE:  YR, MM, Sn, and Sd are not yet included in the returned string...  
-!PRINT *,'DEBUG ESMFold_TimeIntervalGetString():  YR,MM,S,Sn,Sd = ', &
+!PRINT *,'DEBUG timelibold_TimeIntervalGetString():  YR,MM,S,Sn,Sd = ', &
 !        timeinterval%YR, &
 !        timeinterval%MM, &
 !        timeinterval%basetime%S, &
@@ -654,27 +654,27 @@
 
 !write(0,*)'TimeIntervalGetString Sn ',timeinterval%basetime%Sn,' Sd ',timeinterval%basetime%Sd
 
-      rc = ESMF_SUCCESS
+      rc = timelib_SUCCESS
 
-      end subroutine ESMFold_TimeIntervalGetString
+      end subroutine timelibold_TimeIntervalGetString
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalAbsValue - Get the absolute value of a time interval
+! !IROUTINE:  timelib_TimeIntervalAbsValue - Get the absolute value of a time interval
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalAbsValue(timeinterval)
+      function timelib_TimeIntervalAbsValue(timeinterval)
 
 ! !RETURN VALUE:
-      type(ESMF_TimeInterval) :: ESMF_TimeIntervalAbsValue
+      type(timelib_TimeInterval) :: timelib_TimeIntervalAbsValue
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_TimeInterval), intent(in) :: timeinterval
 ! !LOCAL:
       integer    :: rc
 
 ! !DESCRIPTION:
-!     Return a {\tt ESMF\_TimeInterval}'s absolute value.
+!     Return a {\tt timelib\_TimeInterval}'s absolute value.
 !
 !     The arguments are:
 !     \begin{description}
@@ -686,33 +686,33 @@
 ! !REQUIREMENTS:
 !     TMG1.5.8
 !EOP
-      CALL timeintchecknormalized( timeinterval, 'ESMF_TimeIntervalAbsValue arg1' )
-      ESMF_TimeIntervalAbsValue = timeinterval
+      CALL timeintchecknormalized( timeinterval, 'timelib_TimeIntervalAbsValue arg1' )
+      timelib_TimeIntervalAbsValue = timeinterval
 !$$$here...  move implementation into BaseTime
-      ESMF_TimeIntervalAbsValue%basetime%S  = &
-        abs(ESMF_TimeIntervalAbsValue%basetime%S)
-      ESMF_TimeIntervalAbsValue%basetime%Sn = &
-        abs(ESMF_TimeIntervalAbsValue%basetime%Sn )
+      timelib_TimeIntervalAbsValue%basetime%S  = &
+        abs(timelib_TimeIntervalAbsValue%basetime%S)
+      timelib_TimeIntervalAbsValue%basetime%Sn = &
+        abs(timelib_TimeIntervalAbsValue%basetime%Sn )
 
-      end function ESMF_TimeIntervalAbsValue
+      end function timelib_TimeIntervalAbsValue
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalNegAbsValue - Get the negative absolute value of a time interval
+! !IROUTINE:  timelib_TimeIntervalNegAbsValue - Get the negative absolute value of a time interval
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalNegAbsValue(timeinterval)
+      function timelib_TimeIntervalNegAbsValue(timeinterval)
 
 ! !RETURN VALUE:
-      type(ESMF_TimeInterval) :: ESMF_TimeIntervalNegAbsValue
+      type(timelib_TimeInterval) :: timelib_TimeIntervalNegAbsValue
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_TimeInterval), intent(in) :: timeinterval
 ! !LOCAL:
       integer    :: rc
 
 ! !DESCRIPTION:
-!     Return a {\tt ESMF\_TimeInterval}'s negative absolute value.
+!     Return a {\tt timelib\_TimeInterval}'s negative absolute value.
 !
 !     The arguments are:
 !     \begin{description}
@@ -724,16 +724,16 @@
 ! !REQUIREMENTS:
 !     TMG1.5.8
 !EOP
-      CALL timeintchecknormalized( timeinterval, 'ESMF_TimeIntervalNegAbsValue arg1' )
+      CALL timeintchecknormalized( timeinterval, 'timelib_TimeIntervalNegAbsValue arg1' )
     
-      ESMF_TimeIntervalNegAbsValue = timeinterval
+      timelib_TimeIntervalNegAbsValue = timeinterval
 !$$$here...  move implementation into BaseTime
-      ESMF_TimeIntervalNegAbsValue%basetime%S  = &
-        -abs(ESMF_TimeIntervalNegAbsValue%basetime%S)
-      ESMF_TimeIntervalNegAbsValue%basetime%Sn = &
-        -abs(ESMF_TimeIntervalNegAbsValue%basetime%Sn )
+      timelib_TimeIntervalNegAbsValue%basetime%S  = &
+        -abs(timelib_TimeIntervalNegAbsValue%basetime%S)
+      timelib_TimeIntervalNegAbsValue%basetime%Sn = &
+        -abs(timelib_TimeIntervalNegAbsValue%basetime%Sn )
 
-      end function ESMF_TimeIntervalNegAbsValue
+      end function timelib_TimeIntervalNegAbsValue
 
 !------------------------------------------------------------------------------
 !
@@ -746,18 +746,18 @@
 
 !!!!!!!!!!!!!!!!!! added jm 20051012
 ! new WRF-specific function, Divide two time intervals and return the whole integer, without remainder
-      function ESMF_TimeIntervalDIVQuot(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalDIVQuot(timeinterval1, timeinterval2)
 
 ! !RETURN VALUE:
-      INTEGER :: ESMF_TimeIntervalDIVQuot 
+      INTEGER :: timelib_TimeIntervalDIVQuot 
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 
 ! !LOCAL
       INTEGER :: retval, isgn, rc
-      type(ESMF_TimeInterval) :: zero, i1,i2
+      type(timelib_TimeInterval) :: zero, i1,i2
 
 ! !DESCRIPTION:
 !     Returns timeinterval1 divided by timeinterval2 as a fraction quotient.
@@ -774,19 +774,19 @@
 !     TMG1.5.5
 !EOP
 
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalDIVQuot arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalDIVQuot arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalDIVQuot arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalDIVQuot arg2' )
 
-      call ESMF_TimeIntervalSet( zero, rc=rc )
+      call timelib_TimeIntervalSet( zero, rc=rc )
       i1 = timeinterval1
       i2 = timeinterval2
       isgn = 1
       if ( i1 .LT. zero ) then
-        i1 = ESMF_TimeIntervalProdI(i1, -1)
+        i1 = timelib_TimeIntervalProdI(i1, -1)
         isgn = -isgn
       endif
       if ( i2 .LT. zero ) then
-        i2 = ESMF_TimeIntervalProdI(i2, -1)
+        i2 = timelib_TimeIntervalProdI(i2, -1)
         isgn = -isgn
       endif
 ! repeated subtraction
@@ -797,30 +797,30 @@
       ENDDO
       retval = retval * isgn
 
-      ESMF_TimeIntervalDIVQuot = retval
+      timelib_TimeIntervalDIVQuot = retval
 
-      end function ESMF_TimeIntervalDIVQuot
+      end function timelib_TimeIntervalDIVQuot
 !!!!!!!!!!!!!!!!!!
 
 
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalQuotI - Divide time interval by an integer, return time interval result 
+! !IROUTINE:  timelib_TimeIntervalQuotI - Divide time interval by an integer, return time interval result 
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalQuotI(timeinterval, divisor)
+      function timelib_TimeIntervalQuotI(timeinterval, divisor)
 
 ! !RETURN VALUE:
-      type(ESMF_TimeInterval) :: ESMF_TimeIntervalQuotI
+      type(timelib_TimeInterval) :: timelib_TimeIntervalQuotI
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_TimeInterval), intent(in) :: timeinterval
       integer, intent(in) :: divisor
 
 ! !DESCRIPTION:
-!     Divides a {\tt ESMF\_TimeInterval} by an integer divisor, returns
-!     quotient as a {\tt ESMF\_TimeInterval}
+!     Divides a {\tt timelib\_TimeInterval} by an integer divisor, returns
+!     quotient as a {\tt timelib\_TimeInterval}
 !
 !     The arguments are:
 !     \begin{description}
@@ -834,48 +834,48 @@
 !     TMG1.5.6, TMG5.3, TMG7.2
 !EOP
 
-!PRINT *,'DEBUG ESMF_TimeIntervalQuotI() A:  S,Sn,Sd = ', &
+!PRINT *,'DEBUG timelib_TimeIntervalQuotI() A:  S,Sn,Sd = ', &
 !  timeinterval%basetime%S,timeinterval%basetime%Sn,timeinterval%basetime%Sd
-!PRINT *,'DEBUG ESMF_TimeIntervalQuotI() A:  divisor = ', divisor
+!PRINT *,'DEBUG timelib_TimeIntervalQuotI() A:  divisor = ', divisor
 
-      CALL timeintchecknormalized( timeinterval, 'ESMF_TimeIntervalQuotI arg1' )
+      CALL timeintchecknormalized( timeinterval, 'timelib_TimeIntervalQuotI arg1' )
 
       IF ( divisor == 0 ) THEN
-        CALL wrf_error_fatal( 'ESMF_TimeIntervalQuotI:  divide by zero' )
+        CALL wrf_error_fatal( 'timelib_TimeIntervalQuotI:  divide by zero' )
       ENDIF
-      ESMF_TimeIntervalQuotI = timeinterval
-!PRINT *,'DEBUG ESMF_TimeIntervalQuotI() B:  S,Sn,Sd = ', &
-!  ESMF_TimeIntervalQuotI%basetime%S,ESMF_TimeIntervalQuotI%basetime%Sn,ESMF_TimeIntervalQuotI%basetime%Sd
-      ESMF_TimeIntervalQuotI%basetime = &
+      timelib_TimeIntervalQuotI = timeinterval
+!PRINT *,'DEBUG timelib_TimeIntervalQuotI() B:  S,Sn,Sd = ', &
+!  timelib_TimeIntervalQuotI%basetime%S,timelib_TimeIntervalQuotI%basetime%Sn,timelib_TimeIntervalQuotI%basetime%Sd
+      timelib_TimeIntervalQuotI%basetime = &
         timeinterval%basetime / divisor
-!PRINT *,'DEBUG ESMF_TimeIntervalQuotI() C:  S,Sn,Sd = ', &
-!  ESMF_TimeIntervalQuotI%basetime%S,ESMF_TimeIntervalQuotI%basetime%Sn,ESMF_TimeIntervalQuotI%basetime%Sd
+!PRINT *,'DEBUG timelib_TimeIntervalQuotI() C:  S,Sn,Sd = ', &
+!  timelib_TimeIntervalQuotI%basetime%S,timelib_TimeIntervalQuotI%basetime%Sn,timelib_TimeIntervalQuotI%basetime%Sd
 
-      CALL normalize_timeint( ESMF_TimeIntervalQuotI )
-!PRINT *,'DEBUG ESMF_TimeIntervalQuotI() D:  S,Sn,Sd = ', &
-!  ESMF_TimeIntervalQuotI%basetime%S,ESMF_TimeIntervalQuotI%basetime%Sn,ESMF_TimeIntervalQuotI%basetime%Sd
+      CALL normalize_timeint( timelib_TimeIntervalQuotI )
+!PRINT *,'DEBUG timelib_TimeIntervalQuotI() D:  S,Sn,Sd = ', &
+!  timelib_TimeIntervalQuotI%basetime%S,timelib_TimeIntervalQuotI%basetime%Sn,timelib_TimeIntervalQuotI%basetime%Sd
 
-      end function ESMF_TimeIntervalQuotI
+      end function timelib_TimeIntervalQuotI
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:   ESMF_TimeIntervalProdI - Multiply a time interval by an integer
+! !IROUTINE:   timelib_TimeIntervalProdI - Multiply a time interval by an integer
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalProdI(timeinterval, multiplier)
+      function timelib_TimeIntervalProdI(timeinterval, multiplier)
 
 ! !RETURN VALUE:
-      type(ESMF_TimeInterval) :: ESMF_TimeIntervalProdI
+      type(timelib_TimeInterval) :: timelib_TimeIntervalProdI
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_TimeInterval), intent(in) :: timeinterval
       integer, intent(in) :: multiplier
 ! !LOCAL:
       integer    :: rc
 
 ! !DESCRIPTION:
-!     Multiply a {\tt ESMF\_TimeInterval} by an integer, return product as a
-!     {\tt ESMF\_TimeInterval}
+!     Multiply a {\tt timelib\_TimeInterval} by an integer, return product as a
+!     {\tt timelib\_TimeInterval}
 !
 !     The arguments are:
 !     \begin{description}
@@ -888,43 +888,43 @@
 ! !REQUIREMENTS:
 !     TMG1.5.7, TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval, 'ESMF_TimeIntervalProdI arg1' )
+      CALL timeintchecknormalized( timeinterval, 'timelib_TimeIntervalProdI arg1' )
 
-      CALL ESMF_TimeIntervalSet( ESMF_TimeIntervalProdI, rc=rc )
+      CALL timelib_TimeIntervalSet( timelib_TimeIntervalProdI, rc=rc )
 !$$$move this into overloaded operator(*) in BaseTime
-      ESMF_TimeIntervalProdI%basetime%S  = &
-        timeinterval%basetime%S * INT( multiplier, ESMF_KIND_I8 )
-      ESMF_TimeIntervalProdI%basetime%Sn = &
-        timeinterval%basetime%Sn * INT( multiplier, ESMF_KIND_I8 )
+      timelib_TimeIntervalProdI%basetime%S  = &
+        timeinterval%basetime%S * INT( multiplier, timelib_KIND_I8 )
+      timelib_TimeIntervalProdI%basetime%Sn = &
+        timeinterval%basetime%Sn * INT( multiplier, timelib_KIND_I8 )
       ! Don't multiply Sd
-      ESMF_TimeIntervalProdI%basetime%Sd = timeinterval%basetime%Sd
-      CALL normalize_timeint( ESMF_TimeIntervalProdI )
+      timelib_TimeIntervalProdI%basetime%Sd = timeinterval%basetime%Sd
+      CALL normalize_timeint( timelib_TimeIntervalProdI )
 
-      end function ESMF_TimeIntervalProdI
+      end function timelib_TimeIntervalProdI
 
 !------------------------------------------------------------------------------
 !
-! This section includes the inherited ESMF_BaseTime class overloaded operators
+! This section includes the inherited timelib_BaseTime class overloaded operators
 !
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalSum - Add two time intervals together
+! !IROUTINE:  timelib_TimeIntervalSum - Add two time intervals together
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalSum(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalSum(timeinterval1, timeinterval2)
 
 ! !RETURN VALUE:
-      type(ESMF_TimeInterval) :: ESMF_TimeIntervalSum
+      type(timelib_TimeInterval) :: timelib_TimeIntervalSum
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 ! !LOCAL:
       integer                             :: rc
 ! !DESCRIPTION:
-!     Add two {\tt ESMF\_TimeIntervals}, return sum as a
-!     {\tt ESMF\_TimeInterval}.  Maps overloaded (+) operator interface
-!     function to {\tt ESMF\_BaseTime} base class.
+!     Add two {\tt timelib\_TimeIntervals}, return sum as a
+!     {\tt timelib\_TimeInterval}.  Maps overloaded (+) operator interface
+!     function to {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -938,36 +938,36 @@
 !     TMG1.5.4, TMG2.4.4, TMG2.4.5, TMG2.4.6, TMG5.1, TMG5.2, 
 !                 TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalSum arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalSum arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalSum arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalSum arg2' )
 
-      ESMF_TimeIntervalSum = timeinterval1
-      ESMF_TimeIntervalSum%basetime = ESMF_TimeIntervalSum%basetime + &
+      timelib_TimeIntervalSum = timeinterval1
+      timelib_TimeIntervalSum%basetime = timelib_TimeIntervalSum%basetime + &
                                       timeinterval2%basetime
 
-      CALL normalize_timeint( ESMF_TimeIntervalSum )
+      CALL normalize_timeint( timelib_TimeIntervalSum )
 
-      end function ESMF_TimeIntervalSum
+      end function timelib_TimeIntervalSum
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalDiff - Subtract one time interval from another
+! !IROUTINE:  timelib_TimeIntervalDiff - Subtract one time interval from another
    
 ! !INTERFACE:
-      function ESMF_TimeIntervalDiff(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalDiff(timeinterval1, timeinterval2)
 
 ! !RETURN VALUE:
-      type(ESMF_TimeInterval) :: ESMF_TimeIntervalDiff
+      type(timelib_TimeInterval) :: timelib_TimeIntervalDiff
 
 ! !ARGUMENTS: 
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 ! !LOCAL:
       integer                             :: rc
 ! !DESCRIPTION:
 !     Subtract timeinterval2 from timeinterval1, return remainder as a 
-!     {\tt ESMF\_TimeInterval}.
-!     Map overloaded (-) operator interface function to {\tt ESMF\_BaseTime}
+!     {\tt timelib\_TimeInterval}.
+!     Map overloaded (-) operator interface function to {\tt timelib\_BaseTime}
 !     base class.
 !
 !     The arguments are:
@@ -981,33 +981,33 @@
 ! !REQUIREMENTS:
 !     TMG1.5.4, TMG2.4.4, TMG2.4.5, TMG2.4.6, TMG5.1, TMG5.2, TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalDiff arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalDiff arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalDiff arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalDiff arg2' )
 
-      ESMF_TimeIntervalDiff = timeinterval1
-      ESMF_TimeIntervalDiff%basetime = ESMF_TimeIntervalDiff%basetime - &
+      timelib_TimeIntervalDiff = timeinterval1
+      timelib_TimeIntervalDiff%basetime = timelib_TimeIntervalDiff%basetime - &
                                        timeinterval2%basetime
-      CALL normalize_timeint( ESMF_TimeIntervalDiff )
+      CALL normalize_timeint( timelib_TimeIntervalDiff )
 
-      end function ESMF_TimeIntervalDiff
+      end function timelib_TimeIntervalDiff
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE: ESMF_TimeIntervalEQ - Compare two time intervals for equality
+! !IROUTINE: timelib_TimeIntervalEQ - Compare two time intervals for equality
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalEQ(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalEQ(timeinterval1, timeinterval2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeIntervalEQ
+      logical :: timelib_TimeIntervalEQ
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 
 !DESCRIPTION:
 !     Return true if both given time intervals are equal, false otherwise.
-!     Maps overloaded (==) operator interface function to {\tt ESMF\_BaseTime}
+!     Maps overloaded (==) operator interface function to {\tt timelib\_BaseTime}
 !     base class.
 !
 !     The arguments are:
@@ -1021,32 +1021,32 @@
 ! !REQUIREMENTS:
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalEQ arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalEQ arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalEQ arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalEQ arg2' )
 
 !$$$here...  move all this out of Meat.F90 ?  
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeIntEQ(timeinterval1, timeinterval2, ESMF_TimeIntervalEQ)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeIntEQ(timeinterval1, timeinterval2, timelib_TimeIntervalEQ)
 
-      end function ESMF_TimeIntervalEQ
+      end function timelib_TimeIntervalEQ
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalNE - Compare two time intervals for inequality
+! !IROUTINE:  timelib_TimeIntervalNE - Compare two time intervals for inequality
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalNE(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalNE(timeinterval1, timeinterval2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeIntervalNE
+      logical :: timelib_TimeIntervalNE
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 
 ! !DESCRIPTION:
 !     Return true if both given time intervals are not equal, false otherwise.
-!     Maps overloaded (/=) operator interface function to {\tt ESMF\_BaseTime}
+!     Maps overloaded (/=) operator interface function to {\tt timelib\_BaseTime}
 !     base class.
 !
 !     The arguments are:
@@ -1060,32 +1060,32 @@
 ! !REQUIREMENTS:
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalNE arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalNE arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalNE arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalNE arg2' )
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeIntNE(timeinterval1, timeinterval2, ESMF_TimeIntervalNE)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeIntNE(timeinterval1, timeinterval2, timelib_TimeIntervalNE)
 
-      end function ESMF_TimeIntervalNE
+      end function timelib_TimeIntervalNE
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalLT - Time interval 1 less than time interval 2 ?
+! !IROUTINE:  timelib_TimeIntervalLT - Time interval 1 less than time interval 2 ?
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalLT(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalLT(timeinterval1, timeinterval2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeIntervalLT
+      logical :: timelib_TimeIntervalLT
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 
 ! !DESCRIPTION:
 !     Return true if first time interval is less than second time interval,
 !     false otherwise. Maps overloaded (<) operator interface function to
-!     {\tt ESMF\_BaseTime} base class.
+!     {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -1098,32 +1098,32 @@
 ! !REQUIREMENTS:
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalLT arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalLT arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalLT arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalLT arg2' )
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeIntLT(timeinterval1, timeinterval2, ESMF_TimeIntervalLT)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeIntLT(timeinterval1, timeinterval2, timelib_TimeIntervalLT)
 
-      end function ESMF_TimeIntervalLT
+      end function timelib_TimeIntervalLT
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalGT - Time interval 1 greater than time interval 2?
+! !IROUTINE:  timelib_TimeIntervalGT - Time interval 1 greater than time interval 2?
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalGT(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalGT(timeinterval1, timeinterval2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeIntervalGT
+      logical :: timelib_TimeIntervalGT
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 
 ! !DESCRIPTION:
 !     Return true if first time interval is greater than second time interval,
 !     false otherwise.  Maps overloaded (>) operator interface function to
-!     {\tt ESMF\_BaseTime} base class.
+!     {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -1136,32 +1136,32 @@
 ! !REQUIREMENTS:
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalGT arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalGT arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalGT arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalGT arg2' )
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeIntGT(timeinterval1, timeinterval2, ESMF_TimeIntervalGT)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeIntGT(timeinterval1, timeinterval2, timelib_TimeIntervalGT)
 
-      end function ESMF_TimeIntervalGT
+      end function timelib_TimeIntervalGT
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalLE - Time interval 1 less than or equal to time interval 2 ?
+! !IROUTINE:  timelib_TimeIntervalLE - Time interval 1 less than or equal to time interval 2 ?
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalLE(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalLE(timeinterval1, timeinterval2)
 
 ! !RETURN VALUE:
-      logical :: ESMF_TimeIntervalLE
+      logical :: timelib_TimeIntervalLE
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 
 ! !DESCRIPTION:
 !     Return true if first time interval is less than or equal to second time
 !     interval, false otherwise.
-!     Maps overloaded (<=) operator interface function to {\tt ESMF\_BaseTime}
+!     Maps overloaded (<=) operator interface function to {\tt timelib\_BaseTime}
 !     base class.
 !
 !     The arguments are:
@@ -1175,32 +1175,32 @@
 ! !REQUIREMENTS:
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalLE arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalLE arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalLE arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalLE arg2' )
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeIntLE(timeinterval1, timeinterval2, ESMF_TimeIntervalLE)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeIntLE(timeinterval1, timeinterval2, timelib_TimeIntervalLE)
 
-      end function ESMF_TimeIntervalLE
+      end function timelib_TimeIntervalLE
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalGE - Time interval 1 greater than or equal to time interval 2 ?
+! !IROUTINE:  timelib_TimeIntervalGE - Time interval 1 greater than or equal to time interval 2 ?
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalGE(timeinterval1, timeinterval2)
+      function timelib_TimeIntervalGE(timeinterval1, timeinterval2)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeIntervalGE
+      logical :: timelib_TimeIntervalGE
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval1
-      type(ESMF_TimeInterval), intent(in) :: timeinterval2
+      type(timelib_TimeInterval), intent(in) :: timeinterval1
+      type(timelib_TimeInterval), intent(in) :: timeinterval2
 
 ! !DESCRIPTION:
 !     Return true if first time interval is greater than or equal to second
 !     time interval, false otherwise. Maps overloaded (>=) operator interface
-!     function to {\tt ESMF\_BaseTime} base class.
+!     function to {\tt timelib\_BaseTime} base class.
 !
 !     The arguments are:
 !     \begin{description}
@@ -1213,30 +1213,30 @@
 ! !REQUIREMENTS:
 !     TMG1.5.3, TMG2.4.3, TMG7.2
 !EOP
-      CALL timeintchecknormalized( timeinterval1, 'ESMF_TimeIntervalGE arg1' )
-      CALL timeintchecknormalized( timeinterval2, 'ESMF_TimeIntervalGE arg2' )
+      CALL timeintchecknormalized( timeinterval1, 'timelib_TimeIntervalGE arg1' )
+      CALL timeintchecknormalized( timeinterval2, 'timelib_TimeIntervalGE arg2' )
 
-      ! call ESMC_BaseTime base class function
-      call c_ESMC_BaseTimeIntGE(timeinterval1, timeinterval2, ESMF_TimeIntervalGE)
+      ! call timelibc_BaseTime base class function
+      call c_timelibc_BaseTimeIntGE(timeinterval1, timeinterval2, timelib_TimeIntervalGE)
 
-      end function ESMF_TimeIntervalGE
+      end function timelib_TimeIntervalGE
 
 
 !------------------------------------------------------------------------------
 !BOP
-! !IROUTINE:  ESMF_TimeIntervalIsPositive - Time interval greater than zero?
+! !IROUTINE:  timelib_TimeIntervalIsPositive - Time interval greater than zero?
 
 ! !INTERFACE:
-      function ESMF_TimeIntervalIsPositive(timeinterval)
+      function timelib_TimeIntervalIsPositive(timeinterval)
 !
 ! !RETURN VALUE:
-      logical :: ESMF_TimeIntervalIsPositive
+      logical :: timelib_TimeIntervalIsPositive
 
 ! !ARGUMENTS:
-      type(ESMF_TimeInterval), intent(in) :: timeinterval
+      type(timelib_TimeInterval), intent(in) :: timeinterval
 
 ! !LOCALS:
-      type(ESMF_TimeInterval) :: zerotimeint
+      type(timelib_TimeInterval) :: zerotimeint
       integer :: rcint
 
 ! !DESCRIPTION:
@@ -1250,19 +1250,19 @@
 !     \end{description}
 !EOP
       CALL timeintchecknormalized( timeinterval, &
-                                   'ESMF_TimeIntervalIsPositive arg' )
+                                   'timelib_TimeIntervalIsPositive arg' )
 
-      CALL ESMF_TimeIntervalSet ( zerotimeint, rc=rcint )
-      IF ( rcint /= ESMF_SUCCESS ) THEN
+      CALL timelib_TimeIntervalSet ( zerotimeint, rc=rcint )
+      IF ( rcint /= timelib_SUCCESS ) THEN
         CALL wrf_error_fatal( &
-          'ESMF_TimeIntervalIsPositive:  ESMF_TimeIntervalSet failed' )
+          'timelib_TimeIntervalIsPositive:  timelib_TimeIntervalSet failed' )
       ENDIF
 ! hack for bug in PGI 5.1-x
-!      ESMF_TimeIntervalIsPositive = timeinterval > zerotimeint
-      ESMF_TimeIntervalIsPositive = ESMF_TimeIntervalGT( timeinterval, &
+!      timelib_TimeIntervalIsPositive = timeinterval > zerotimeint
+      timelib_TimeIntervalIsPositive = timelib_TimeIntervalGT( timeinterval, &
                                                          zerotimeint )
-      end function ESMF_TimeIntervalIsPositive
+      end function timelib_TimeIntervalIsPositive
 
-      end module ESMF_TimeIntervalMod
+      end module timelib_TimeIntervalMod
 
 
diff -Naur WRFV3.9/external/esmf_time_f90/ESMF_TimeMgr.inc WRFV3.9.patch/external/esmf_time_f90/ESMF_TimeMgr.inc
--- WRFV3.9/external/esmf_time_f90/ESMF_TimeMgr.inc	2017-02-16 19:55:23.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/ESMF_TimeMgr.inc	1969-12-31 19:00:00.000000000 -0500
@@ -1,61 +0,0 @@
-#if 0
- 
-Earth System Modeling Framework
-Copyright 2002-2003, University Corporation for Atmospheric Research,
-Massachusetts Institute of Technology, Geophysical Fluid Dynamics
-Laboratory, University of Michigan, National Centers for Environmental
-Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
-NASA Goddard Space Flight Center.
-Licensed under the University of Illinois-NCSA license.
-
-Do not have C++ or F90 style comments in here because this file is processed
-by both C++ and F90 compilers.
-#endif
-
-#ifndef ESMF_TimeMgr_INC
-#define ESMF_TimeMgr_INC
-
-#if 0
-!BOP
--------------------------------------------------------------------------
-
- !DESCRIPTION:
-
- ESMF TimeMgr include file for F90
- The code in this file implements constants and macros for the TimeMgr...
-
--------------------------------------------------------------------------
-!EOP
-#endif
-
-#include "ESMF_Macros.inc"
-
-#define SECONDS_PER_DAY 86400_ESMF_KIND_I8
-#define SECONDS_PER_HOUR 3600_ESMF_KIND_I8
-#define SECONDS_PER_MINUTE 60_ESMF_KIND_I8
-#define HOURS_PER_DAY 24_ESMF_KIND_I8
-
-! Note that MAX_ALARMS must match MAX_WRF_ALARMS defined in 
-! ../../frame/module_domain.F !!!  Eliminate this dependence with 
-! grow-as-you-go AlarmList in ESMF_Clock...  
-#include "../../inc/streams.h"
-#define MAX_ALARMS (2*(MAX_HISTORY)+10)
-
-! TBH:  TODO:  Hook this into the WRF build so WRF can use either "no-leap" or 
-! TBH:         Gregorian calendar.  Now WRF is hard-wired to use Gregorian.  
-!#undef NO_LEAP_CALENDAR
-!#ifdef COUP_CSM
-!#define NO_LEAP_CALENDAR
-!#endif
-
-! TBH:  When NO_DT_COMPONENT_INIT is set, code that uses F95 compile-time 
-! TBH:  initialization of components of derived types is not included.  
-! TBH:  Some older compilers like PGI 5.x do not support this F95 
-! TBH:  feature.
-!#ifdef NO_LEAP_CALENDAR
-!#undef NO_DT_COMPONENT_INIT
-!#else
-!#define NO_DT_COMPONENT_INIT
-!#endif
-
-#endif
diff -Naur WRFV3.9/external/esmf_time_f90/Meat.F90 WRFV3.9.patch/external/esmf_time_f90/Meat.F90
--- WRFV3.9/external/esmf_time_f90/Meat.F90	2017-03-07 16:38:50.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/Meat.F90	2017-07-03 16:17:29.684707000 -0400
@@ -1,16 +1,16 @@
-#include <ESMF_TimeMgr.inc>
+#include <timelib_TimeMgr.inc>
 
 ! Factor so abs(Sn) < Sd and ensure that signs of S and Sn match.  
 ! Also, enforce consistency.  
 ! YR and MM fields are ignored.  
 
 SUBROUTINE normalize_basetime( basetime )
-  USE esmf_basemod
-  USE esmf_basetimemod
+  USE timelib_basemod
+  USE timelib_basetimemod
   IMPLICIT NONE
-  TYPE(ESMF_BaseTime), INTENT(INOUT) :: basetime
+  TYPE(timelib_BaseTime), INTENT(INOUT) :: basetime
   !BPR BEGIN
-  INTEGER(ESMF_KIND_I8) :: Sn_simplified, Sd_simplified
+  INTEGER(timelib_KIND_I8) :: Sn_simplified, Sd_simplified
   INTEGER :: primes_to_check
   !BPR END
 
@@ -35,13 +35,13 @@
     ! change sign of Sn if it does not match S
     IF ( ( basetime%S > 0 ) .AND. ( basetime%Sn < 0 ) ) THEN
 !PRINT *,'DEBUG:  normalize_basetime() B1:  S,Sn,Sd = ',basetime%S,basetime%Sn,basetime%Sd
-      basetime%S = basetime%S - 1_ESMF_KIND_I8
+      basetime%S = basetime%S - 1_timelib_KIND_I8
       basetime%Sn = basetime%Sn + basetime%Sd
 !PRINT *,'DEBUG:  normalize_basetime() B2:  S,Sn,Sd = ',basetime%S,basetime%Sn,basetime%Sd
     ENDIF
     IF ( ( basetime%S < 0 ) .AND. ( basetime%Sn > 0 ) ) THEN
 !PRINT *,'DEBUG:  normalize_basetime() C1:  S,Sn,Sd = ',basetime%S,basetime%Sn,basetime%Sd
-      basetime%S = basetime%S + 1_ESMF_KIND_I8
+      basetime%S = basetime%S + 1_timelib_KIND_I8
       basetime%Sn = basetime%Sn - basetime%Sd
 !PRINT *,'DEBUG:  normalize_basetime() C2:  S,Sn,Sd = ',basetime%S,basetime%Sn,basetime%Sd
     ENDIF
@@ -78,14 +78,14 @@
 ! A normalized time has time%basetime >= 0, time%basetime less than the current 
 ! year expressed as a timeInterval, and time%YR can take any value
 SUBROUTINE normalize_time( time )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timemod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timemod
   IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(INOUT) :: time
-  INTEGER(ESMF_KIND_I8) :: nsecondsinyear
+  TYPE(timelib_Time), INTENT(INOUT) :: time
+  INTEGER(timelib_KIND_I8) :: nsecondsinyear
   ! locals
-  TYPE(ESMF_BaseTime) :: cmptime, zerotime
+  TYPE(timelib_BaseTime) :: cmptime, zerotime
   INTEGER :: rc
   LOGICAL :: done
 
@@ -97,13 +97,13 @@
 
   ! next, underflow negative seconds into YEARS
   ! time%basetime must end up non-negative
-!$$$ push this down into ESMF_BaseTime constructor
+!$$$ push this down into timelib_BaseTime constructor
   zerotime%S  = 0
   zerotime%Sn = 0
   zerotime%Sd = 0
   DO WHILE ( time%basetime < zerotime )
     time%YR = time%YR - 1 
-!$$$ push this down into ESMF_BaseTime constructor
+!$$$ push this down into timelib_BaseTime constructor
     cmptime%S  = nsecondsinyear( time%YR )
     cmptime%Sn = 0
     cmptime%Sd = 0
@@ -113,7 +113,7 @@
   ! next, overflow seconds into YEARS
   done = .FALSE.
   DO WHILE ( .NOT. done )
-!$$$ push this down into ESMF_BaseTime constructor
+!$$$ push this down into timelib_BaseTime constructor
     cmptime%S  = nsecondsinyear( time%YR )
     cmptime%Sn = 0
     cmptime%Sd = 0
@@ -129,10 +129,10 @@
 
 
 SUBROUTINE normalize_timeint( timeInt )
-  USE esmf_basetimemod
-  USE esmf_timeintervalmod
+  USE timelib_basetimemod
+  USE timelib_timeintervalmod
   IMPLICIT NONE
-  TYPE(ESMF_TimeInterval), INTENT(INOUT) :: timeInt
+  TYPE(timelib_TimeInterval), INTENT(INOUT) :: timeInt
 
   ! normalize basetime
   ! this will force abs(Sn) < Sd and ensure that signs of S and Sn match
@@ -147,11 +147,11 @@
   ! Compute the sign of a time interval.  
   ! YR and MM fields are *IGNORED*.  
   ! returns 1, 0, or -1 or exits if timeInt fields have inconsistent signs.
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timeintervalmod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timeintervalmod
   IMPLICIT NONE
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeInt
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeInt
   INTEGER :: signnormtimeint
   LOGICAL :: positive, negative
 
@@ -183,9 +183,9 @@
 
 ! Exits with error message if timeInt is not normalized.  
 SUBROUTINE timeintchecknormalized( timeInt, msgstr )
-  USE esmf_timeintervalmod
+  USE timelib_timeintervalmod
   IMPLICIT NONE
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeInt
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeInt
   CHARACTER(LEN=*), INTENT(IN) :: msgstr
   ! locals
   CHARACTER(LEN=256) :: outstr
@@ -245,26 +245,26 @@
 
 FUNCTION nsecondsinyear ( year ) RESULT (numseconds)
   ! Compute the number of seconds in the given year
-  USE esmf_basemod
+  USE timelib_basemod
   IMPLICIT NONE
   INTEGER, INTENT(IN) :: year
-  INTEGER(ESMF_KIND_I8) :: numseconds
+  INTEGER(timelib_KIND_I8) :: numseconds
   INTEGER :: ndaysinyear
-  numseconds = SECONDS_PER_DAY * INT( ndaysinyear(year) , ESMF_KIND_I8 )
+  numseconds = SECONDS_PER_DAY * INT( ndaysinyear(year) , timelib_KIND_I8 )
 END FUNCTION nsecondsinyear
 
 
 
 SUBROUTINE initdaym 
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE ESMF_CalendarMod, only : months_per_year, mday, daym, mdaycum, monthbdys, &
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_CalendarMod, only : months_per_year, mday, daym, mdaycum, monthbdys, &
                                mdayleap, mdayleapcum, monthbdysleap, daymleap
   IMPLICIT NONE
   INTEGER i,j,m
   m = 1
   mdaycum(0) = 0
-!$$$ push this down into ESMF_BaseTime constructor
+!$$$ push this down into timelib_BaseTime constructor
   monthbdys(0)%S  = 0
   monthbdys(0)%Sn = 0
   monthbdys(0)%Sd = 0
@@ -274,14 +274,14 @@
       m = m + 1
     ENDDO
     mdaycum(i) = mdaycum(i-1) + mday(i)
-!$$$ push this down into ESMF_BaseTime constructor
-    monthbdys(i)%S  = SECONDS_PER_DAY * INT( mdaycum(i), ESMF_KIND_I8 )
+!$$$ push this down into timelib_BaseTime constructor
+    monthbdys(i)%S  = SECONDS_PER_DAY * INT( mdaycum(i), timelib_KIND_I8 )
     monthbdys(i)%Sn = 0
     monthbdys(i)%Sd = 0
   ENDDO
   m = 1
   mdayleapcum(0) = 0
-!$$$ push this down into ESMF_BaseTime constructor
+!$$$ push this down into timelib_BaseTime constructor
   monthbdysleap(0)%S  = 0
   monthbdysleap(0)%Sn = 0
   monthbdysleap(0)%Sd = 0
@@ -291,8 +291,8 @@
       m = m + 1
     ENDDO
     mdayleapcum(i) = mdayleapcum(i-1) + mdayleap(i)
-!$$$ push this down into ESMF_BaseTime constructor
-    monthbdysleap(i)%S  = SECONDS_PER_DAY * INT( mdayleapcum(i), ESMF_KIND_I8 )
+!$$$ push this down into timelib_BaseTime constructor
+    monthbdysleap(i)%S  = SECONDS_PER_DAY * INT( mdayleapcum(i), timelib_KIND_I8 )
     monthbdysleap(i)%Sn = 0
     monthbdysleap(i)%Sd = 0
   ENDDO
@@ -301,7 +301,7 @@
 
 !$$$ useful, but not used at the moment...  
 SUBROUTINE compute_dayinyear(YR,MM,DD,dayinyear)
-  use ESMF_CalendarMod, only : mday
+  use timelib_CalendarMod, only : mday
 IMPLICIT NONE
       INTEGER, INTENT(IN)  :: YR,MM,DD   ! DD is day of month
       INTEGER, INTENT(OUT) :: dayinyear
@@ -326,12 +326,12 @@
 
 
 SUBROUTINE timegetmonth( time, MM )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timemod
-  USE ESMF_CalendarMod, only : MONTHS_PER_YEAR, monthbdys, monthbdysleap
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timemod
+  USE timelib_CalendarMod, only : MONTHS_PER_YEAR, monthbdys, monthbdysleap
   IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(IN) :: time
+  TYPE(timelib_Time), INTENT(IN) :: time
   INTEGER, INTENT(OUT) :: MM
   ! locals
   INTEGER :: nfeb
@@ -365,17 +365,17 @@
 !$$$ may need to change dependencies in Makefile...  
 
 SUBROUTINE timegetdayofmonth( time, DD )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timemod
-  USE esmf_calendarmod, only : monthbdys, monthbdysleap
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timemod
+  USE timelib_calendarmod, only : monthbdys, monthbdysleap
   IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(IN) :: time
+  TYPE(timelib_Time), INTENT(IN) :: time
   INTEGER, INTENT(OUT) :: DD
   ! locals
   INTEGER :: nfeb
   INTEGER :: MM
-  TYPE(ESMF_BaseTime) :: tmpbasetime
+  TYPE(timelib_BaseTime) :: tmpbasetime
 #if defined PLANET
   tmpbasetime = time%basetime
 #else
@@ -395,23 +395,23 @@
 ! 1 <= MM <= 12
 ! Time is NOT normalized.  
 SUBROUTINE timeaddmonths( time, MM, ierr )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timemod
-  USE esmf_calendarmod, only : MONTHS_PER_YEAR, monthbdys, monthbdysleap
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timemod
+  USE timelib_calendarmod, only : MONTHS_PER_YEAR, monthbdys, monthbdysleap
   IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(INOUT) :: time
+  TYPE(timelib_Time), INTENT(INOUT) :: time
   INTEGER, INTENT(IN) :: MM
   INTEGER, INTENT(OUT) :: ierr
   ! locals
   INTEGER :: nfeb
-  ierr = ESMF_SUCCESS
+  ierr = timelib_SUCCESS
 !  PRINT *,'DEBUG:  BEGIN timeaddmonths()'
 #if defined PLANET
 !  time%basetime = time%basetime
 #else
   IF ( ( MM < 1 ) .OR. ( MM > MONTHS_PER_YEAR ) ) THEN
-    ierr = ESMF_FAILURE
+    ierr = timelib_FAILURE
   ELSE
     IF ( nfeb(time%YR) == 29 ) THEN
       time%basetime = time%basetime + monthbdysleap(MM-1)
@@ -426,12 +426,12 @@
 ! Increment Time by number of seconds in the current month.  
 ! Time is NOT normalized.  
 SUBROUTINE timeincmonth( time )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timemod
-  USE esmf_calendarmod, only : mday, mdayleap
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timemod
+  USE timelib_calendarmod, only : mday, mdayleap
   IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(INOUT) :: time
+  TYPE(timelib_Time), INTENT(INOUT) :: time
   ! locals
   INTEGER :: nfeb
   INTEGER :: MM
@@ -441,10 +441,10 @@
   CALL timegetmonth( time, MM )
   IF ( nfeb(time%YR) == 29 ) THEN
     time%basetime%S = time%basetime%S + &
-      ( INT( mdayleap(MM), ESMF_KIND_I8 ) * SECONDS_PER_DAY )
+      ( INT( mdayleap(MM), timelib_KIND_I8 ) * SECONDS_PER_DAY )
   ELSE
     time%basetime%S = time%basetime%S + &
-      ( INT( mday(MM), ESMF_KIND_I8 ) * SECONDS_PER_DAY )
+      ( INT( mday(MM), timelib_KIND_I8 ) * SECONDS_PER_DAY )
   ENDIF
 #endif
 END SUBROUTINE timeincmonth
@@ -454,12 +454,12 @@
 ! Decrement Time by number of seconds in the previous month.  
 ! Time is NOT normalized.  
 SUBROUTINE timedecmonth( time )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timemod
-  USE esmf_calendarmod, only : mday, months_per_year, mdayleap
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timemod
+  USE timelib_calendarmod, only : mday, months_per_year, mdayleap
   IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(INOUT) :: time
+  TYPE(timelib_Time), INTENT(INOUT) :: time
   ! locals
   INTEGER :: nfeb
   INTEGER :: MM
@@ -475,10 +475,10 @@
   ENDIF
   IF ( nfeb(time%YR) == 29 ) THEN
     time%basetime%S = time%basetime%S - &
-      ( INT( mdayleap(MM), ESMF_KIND_I8 ) * SECONDS_PER_DAY )
+      ( INT( mdayleap(MM), timelib_KIND_I8 ) * SECONDS_PER_DAY )
   ELSE
     time%basetime%S = time%basetime%S - &
-      ( INT( mday(MM), ESMF_KIND_I8 ) * SECONDS_PER_DAY )
+      ( INT( mday(MM), timelib_KIND_I8 ) * SECONDS_PER_DAY )
   ENDIF
 #endif
 END SUBROUTINE timedecmonth
@@ -487,15 +487,15 @@
 
 ! spaceship operator for Times
 SUBROUTINE timecmp(time1, time2, retval )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timemod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timemod
   IMPLICIT NONE
   INTEGER, INTENT(OUT) :: retval
 !
 ! !ARGUMENTS:
-  TYPE(ESMF_Time), INTENT(IN) :: time1
-  TYPE(ESMF_Time), INTENT(IN) :: time2
+  TYPE(timelib_Time), INTENT(IN) :: time1
+  TYPE(timelib_Time), INTENT(IN) :: time2
   IF ( time1%YR .GT. time2%YR ) THEN ; retval = 1 ; RETURN ; ENDIF
   IF ( time1%YR .LT. time2%YR ) THEN ; retval = -1 ; RETURN ; ENDIF
   CALL seccmp( time1%basetime%S, time1%basetime%Sn, time1%basetime%Sd, &
@@ -507,15 +507,15 @@
 
 ! spaceship operator for TimeIntervals
 SUBROUTINE timeintcmp(timeint1, timeint2, retval )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timeintervalmod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timeintervalmod
   IMPLICIT NONE
   INTEGER, INTENT(OUT) :: retval
 !
 ! !ARGUMENTS:
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint2
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint2
   CALL timeintchecknormalized( timeint1, 'timeintcmp arg1' )
   CALL timeintchecknormalized( timeint2, 'timeintcmp arg2' )
   CALL seccmp( timeint1%basetime%S, timeint1%basetime%Sn, &
@@ -528,15 +528,15 @@
 
 ! spaceship operator for seconds + Sn/Sd
 SUBROUTINE seccmp(S1, Sn1, Sd1, S2, Sn2, Sd2, retval )
-  USE esmf_basemod
+  USE timelib_basemod
   IMPLICIT NONE
   INTEGER, INTENT(OUT) :: retval
 !
 ! !ARGUMENTS:
-  INTEGER(ESMF_KIND_I8), INTENT(IN) :: S1, Sn1, Sd1
-  INTEGER(ESMF_KIND_I8), INTENT(IN) :: S2, Sn2, Sd2
+  INTEGER(timelib_KIND_I8), INTENT(IN) :: S1, Sn1, Sd1
+  INTEGER(timelib_KIND_I8), INTENT(IN) :: S2, Sn2, Sd2
 ! local
-  INTEGER(ESMF_KIND_I8) :: lcd, n1, n2
+  INTEGER(timelib_KIND_I8) :: lcd, n1, n2
 
   n1 = Sn1
   n2 = Sn2
@@ -556,178 +556,178 @@
 END SUBROUTINE seccmp
 
 
-SUBROUTINE c_esmc_basetimeeq (time1, time2, outflag)
-  USE esmf_alarmmod
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_calendarmod
-  USE esmf_clockmod
-  USE esmf_fractionmod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
+SUBROUTINE c_timelibc_basetimeeq (time1, time2, outflag)
+  USE timelib_alarmmod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_calendarmod
+  USE timelib_clockmod
+  USE timelib_fractionmod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
 IMPLICIT NONE
       logical, intent(OUT) :: outflag
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
       integer res 
       CALL timecmp(time1,time2,res)
       outflag = (res .EQ. 0)
-END SUBROUTINE c_esmc_basetimeeq
-SUBROUTINE c_esmc_basetimege(time1, time2, outflag)
-  USE esmf_alarmmod
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_calendarmod
-  USE esmf_clockmod
-  USE esmf_fractionmod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
+END SUBROUTINE c_timelibc_basetimeeq
+SUBROUTINE c_timelibc_basetimege(time1, time2, outflag)
+  USE timelib_alarmmod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_calendarmod
+  USE timelib_clockmod
+  USE timelib_fractionmod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
       logical, intent(OUT) :: outflag
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
       integer res 
       CALL timecmp(time1,time2,res)
       outflag = (res .EQ. 1 .OR. res .EQ. 0)
-END SUBROUTINE c_esmc_basetimege
-SUBROUTINE c_esmc_basetimegt(time1, time2, outflag)
-  USE esmf_alarmmod
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_calendarmod
-  USE esmf_clockmod
-  USE esmf_fractionmod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
+END SUBROUTINE c_timelibc_basetimege
+SUBROUTINE c_timelibc_basetimegt(time1, time2, outflag)
+  USE timelib_alarmmod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_calendarmod
+  USE timelib_clockmod
+  USE timelib_fractionmod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
 IMPLICIT NONE
       logical, intent(OUT) :: outflag
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
       integer res 
       CALL timecmp(time1,time2,res)
       outflag = (res .EQ. 1)
-END SUBROUTINE c_esmc_basetimegt
-SUBROUTINE c_esmc_basetimele(time1, time2, outflag)
-  USE esmf_alarmmod
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_calendarmod
-  USE esmf_clockmod
-  USE esmf_fractionmod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
+END SUBROUTINE c_timelibc_basetimegt
+SUBROUTINE c_timelibc_basetimele(time1, time2, outflag)
+  USE timelib_alarmmod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_calendarmod
+  USE timelib_clockmod
+  USE timelib_fractionmod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
 IMPLICIT NONE
       logical, intent(OUT) :: outflag
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
       integer res 
       CALL timecmp(time1,time2,res)
       outflag = (res .EQ. -1 .OR. res .EQ. 0)
-END SUBROUTINE c_esmc_basetimele
-SUBROUTINE c_esmc_basetimelt(time1, time2, outflag)
-  USE esmf_alarmmod
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_calendarmod
-  USE esmf_clockmod
-  USE esmf_fractionmod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
+END SUBROUTINE c_timelibc_basetimele
+SUBROUTINE c_timelibc_basetimelt(time1, time2, outflag)
+  USE timelib_alarmmod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_calendarmod
+  USE timelib_clockmod
+  USE timelib_fractionmod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
 IMPLICIT NONE
       logical, intent(OUT) :: outflag
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
       integer res 
       CALL timecmp(time1,time2,res)
       outflag = (res .EQ. -1)
-END SUBROUTINE c_esmc_basetimelt
-SUBROUTINE c_esmc_basetimene(time1, time2, outflag)
-  USE esmf_alarmmod
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_calendarmod
-  USE esmf_clockmod
-  USE esmf_fractionmod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
+END SUBROUTINE c_timelibc_basetimelt
+SUBROUTINE c_timelibc_basetimene(time1, time2, outflag)
+  USE timelib_alarmmod
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_calendarmod
+  USE timelib_clockmod
+  USE timelib_fractionmod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
 IMPLICIT NONE
       logical, intent(OUT) :: outflag
-      type(ESMF_Time), intent(in) :: time1
-      type(ESMF_Time), intent(in) :: time2
+      type(timelib_Time), intent(in) :: time1
+      type(timelib_Time), intent(in) :: time2
       integer res 
       CALL timecmp(time1,time2,res)
       outflag = (res .NE. 0)
-END SUBROUTINE c_esmc_basetimene
+END SUBROUTINE c_timelibc_basetimene
 
-SUBROUTINE c_esmc_basetimeinteq(timeint1, timeint2, outflag)
-  USE esmf_timeintervalmod
+SUBROUTINE c_timelibc_basetimeinteq(timeint1, timeint2, outflag)
+  USE timelib_timeintervalmod
   IMPLICIT NONE
   LOGICAL, INTENT(OUT) :: outflag
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint2
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint2
   INTEGER :: res 
   CALL timeintcmp(timeint1,timeint2,res)
   outflag = (res .EQ. 0)
-END SUBROUTINE c_esmc_basetimeinteq
-SUBROUTINE c_esmc_basetimeintne(timeint1, timeint2, outflag)
-  USE esmf_timeintervalmod
+END SUBROUTINE c_timelibc_basetimeinteq
+SUBROUTINE c_timelibc_basetimeintne(timeint1, timeint2, outflag)
+  USE timelib_timeintervalmod
   IMPLICIT NONE
   LOGICAL, INTENT(OUT) :: outflag
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint2
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint2
   INTEGER :: res 
   CALL timeintcmp(timeint1,timeint2,res)
   outflag = (res .NE. 0)
-END SUBROUTINE c_esmc_basetimeintne
-SUBROUTINE c_esmc_basetimeintlt(timeint1, timeint2, outflag)
-  USE esmf_timeintervalmod
+END SUBROUTINE c_timelibc_basetimeintne
+SUBROUTINE c_timelibc_basetimeintlt(timeint1, timeint2, outflag)
+  USE timelib_timeintervalmod
   IMPLICIT NONE
   LOGICAL, INTENT(OUT) :: outflag
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint2
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint2
   INTEGER :: res 
   CALL timeintcmp(timeint1,timeint2,res)
   outflag = (res .LT. 0)
-END SUBROUTINE c_esmc_basetimeintlt
-SUBROUTINE c_esmc_basetimeintgt(timeint1, timeint2, outflag)
-  USE esmf_timeintervalmod
+END SUBROUTINE c_timelibc_basetimeintlt
+SUBROUTINE c_timelibc_basetimeintgt(timeint1, timeint2, outflag)
+  USE timelib_timeintervalmod
   IMPLICIT NONE
   LOGICAL, INTENT(OUT) :: outflag
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint2
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint2
   INTEGER :: res 
   CALL timeintcmp(timeint1,timeint2,res)
   outflag = (res .GT. 0)
-END SUBROUTINE c_esmc_basetimeintgt
-SUBROUTINE c_esmc_basetimeintle(timeint1, timeint2, outflag)
-  USE esmf_timeintervalmod
+END SUBROUTINE c_timelibc_basetimeintgt
+SUBROUTINE c_timelibc_basetimeintle(timeint1, timeint2, outflag)
+  USE timelib_timeintervalmod
   IMPLICIT NONE
   LOGICAL, INTENT(OUT) :: outflag
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint2
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint2
   INTEGER :: res 
   CALL timeintcmp(timeint1,timeint2,res)
   outflag = (res .LE. 0)
-END SUBROUTINE c_esmc_basetimeintle
-SUBROUTINE c_esmc_basetimeintge(timeint1, timeint2, outflag)
-  USE esmf_timeintervalmod
+END SUBROUTINE c_timelibc_basetimeintle
+SUBROUTINE c_timelibc_basetimeintge(timeint1, timeint2, outflag)
+  USE timelib_timeintervalmod
   IMPLICIT NONE
   LOGICAL, INTENT(OUT) :: outflag
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeint2
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeint2
   INTEGER :: res 
   CALL timeintcmp(timeint1,timeint2,res)
   outflag = (res .GE. 0)
-END SUBROUTINE c_esmc_basetimeintge
+END SUBROUTINE c_timelibc_basetimeintge
 
 SUBROUTINE compute_lcd( e1, e2, lcd )
-  USE esmf_basemod
+  USE timelib_basemod
       IMPLICIT NONE
-      INTEGER(ESMF_KIND_I8), INTENT(IN) :: e1, e2
-      INTEGER(ESMF_KIND_I8), INTENT(OUT) :: lcd
+      INTEGER(timelib_KIND_I8), INTENT(IN) :: e1, e2
+      INTEGER(timelib_KIND_I8), INTENT(OUT) :: lcd
       INTEGER, PARAMETER ::  nprimes = 9
-      INTEGER(ESMF_KIND_I8), DIMENSION(nprimes), PARAMETER :: primes = (/2,3,5,7,11,13,17,19,23/)
+      INTEGER(timelib_KIND_I8), DIMENSION(nprimes), PARAMETER :: primes = (/2,3,5,7,11,13,17,19,23/)
       INTEGER i
-      INTEGER(ESMF_KIND_I8) d1, d2, p
+      INTEGER(timelib_KIND_I8) d1, d2, p
 
       d1 = e1 ; d2 = e2
       IF ( d1 .EQ. 0 .AND. d2 .EQ. 0 ) THEN ; lcd = 1 ; RETURN ; ENDIF
@@ -745,13 +745,13 @@
 END SUBROUTINE compute_lcd
 
 SUBROUTINE simplify( ni, di, no, do ) 
-  USE esmf_basemod
+  USE timelib_basemod
     IMPLICIT NONE
-    INTEGER(ESMF_KIND_I8), INTENT(IN)  :: ni, di
-    INTEGER(ESMF_KIND_I8), INTENT(OUT) :: no, do
+    INTEGER(timelib_KIND_I8), INTENT(IN)  :: ni, di
+    INTEGER(timelib_KIND_I8), INTENT(OUT) :: no, do
     INTEGER, PARAMETER ::  nprimes = 9
-    INTEGER(ESMF_KIND_I8), DIMENSION(nprimes), PARAMETER :: primes = (/2,3,5,7,11,13,17,19,23/)
-    INTEGER(ESMF_KIND_I8) :: pr, d, n
+    INTEGER(timelib_KIND_I8), DIMENSION(nprimes), PARAMETER :: primes = (/2,3,5,7,11,13,17,19,23/)
+    INTEGER(timelib_KIND_I8) :: pr, d, n
     INTEGER :: np
     LOGICAL keepgoing
     IF ( ni .EQ. 0 ) THEN
@@ -786,17 +786,17 @@
 !BPR BEGIN
 ! Same as simplify above, but allows user to choose the number of primes to check
 SUBROUTINE simplify_numprimes( ni, di, no, do, num_primes_to_check )
-  USE esmf_basemod
+  USE timelib_basemod
     IMPLICIT NONE
-    INTEGER(ESMF_KIND_I8), INTENT(IN)  :: ni, di
-    INTEGER(ESMF_KIND_I8), INTENT(OUT) :: no, do
+    INTEGER(timelib_KIND_I8), INTENT(IN)  :: ni, di
+    INTEGER(timelib_KIND_I8), INTENT(OUT) :: no, do
     INTEGER, INTENT(IN) :: num_primes_to_check !Number of primes to check
     INTEGER, PARAMETER ::  nprimes = 62
-    INTEGER(ESMF_KIND_I8), DIMENSION(nprimes), PARAMETER :: primes = (/2,3,5,7,11,13,17,&
+    INTEGER(timelib_KIND_I8), DIMENSION(nprimes), PARAMETER :: primes = (/2,3,5,7,11,13,17,&
      19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,&
      137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,&
      251,257,263,269,271,277,281,283,293/)
-    INTEGER(ESMF_KIND_I8) :: pr, d, n
+    INTEGER(timelib_KIND_I8) :: pr, d, n
     INTEGER :: np
     LOGICAL keepgoing
     INTEGER :: num_primes_to_check_final !Number of primes to check after being limited to max
@@ -837,16 +837,16 @@
 !BPR END
 
 
-!$$$ this should be named "c_esmc_timesum" or something less misleading
-SUBROUTINE c_esmc_basetimesum( time1, timeinterval, timeOut )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
-  IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(IN) :: time1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeinterval
-  TYPE(ESMF_Time), INTENT(INOUT) :: timeOut
+!$$$ this should be named "c_timelibc_timesum" or something less misleading
+SUBROUTINE c_timelibc_basetimesum( time1, timeinterval, timeOut )
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
+  IMPLICIT NONE
+  TYPE(timelib_Time), INTENT(IN) :: time1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeinterval
+  TYPE(timelib_Time), INTENT(INOUT) :: timeOut
   ! locals
   INTEGER :: m
   timeOut = time1
@@ -867,21 +867,21 @@
 #endif
   timeOut%YR = timeOut%YR + timeinterval%YR
   CALL normalize_time( timeOut )
-END SUBROUTINE c_esmc_basetimesum
+END SUBROUTINE c_timelibc_basetimesum
 
 
-!$$$ this should be named "c_esmc_timedec" or something less misleading
-SUBROUTINE c_esmc_basetimedec( time1, timeinterval, timeOut )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
+!$$$ this should be named "c_timelibc_timedec" or something less misleading
+SUBROUTINE c_timelibc_basetimedec( time1, timeinterval, timeOut )
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
   IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(IN) :: time1
-  TYPE(ESMF_TimeInterval), INTENT(IN) :: timeinterval
-  TYPE(ESMF_Time), INTENT(OUT) :: timeOut
+  TYPE(timelib_Time), INTENT(IN) :: time1
+  TYPE(timelib_TimeInterval), INTENT(IN) :: timeinterval
+  TYPE(timelib_Time), INTENT(OUT) :: timeOut
   ! locals
-  TYPE (ESMF_TimeInterval)  :: neginterval 
+  TYPE (timelib_TimeInterval)  :: neginterval 
   neginterval = timeinterval
 !$$$push this down into a unary negation operator on TimeInterval
   neginterval%basetime%S = -neginterval%basetime%S
@@ -894,23 +894,23 @@
 #endif
 #endif
   timeOut = time1 + neginterval
-END SUBROUTINE c_esmc_basetimedec
+END SUBROUTINE c_timelibc_basetimedec
 
 
-!$$$ this should be named "c_esmc_timediff" or something less misleading
-SUBROUTINE c_esmc_basetimediff( time1, time2, timeIntOut )
-  USE esmf_basemod
-  USE esmf_basetimemod
-  USE esmf_timeintervalmod
-  USE esmf_timemod
+!$$$ this should be named "c_timelibc_timediff" or something less misleading
+SUBROUTINE c_timelibc_basetimediff( time1, time2, timeIntOut )
+  USE timelib_basemod
+  USE timelib_basetimemod
+  USE timelib_timeintervalmod
+  USE timelib_timemod
   IMPLICIT NONE
-  TYPE(ESMF_Time), INTENT(IN) :: time1
-  TYPE(ESMF_Time), INTENT(IN) :: time2
-  TYPE(ESMF_TimeInterval), INTENT(OUT) :: timeIntOut
+  TYPE(timelib_Time), INTENT(IN) :: time1
+  TYPE(timelib_Time), INTENT(IN) :: time2
+  TYPE(timelib_TimeInterval), INTENT(OUT) :: timeIntOut
   ! locals
-  INTEGER(ESMF_KIND_I8) :: nsecondsinyear
+  INTEGER(timelib_KIND_I8) :: nsecondsinyear
   INTEGER :: yr
-  CALL ESMF_TimeIntervalSet( timeIntOut )
+  CALL timelib_TimeIntervalSet( timeIntOut )
   timeIntOut%basetime = time1%basetime - time2%basetime
   ! convert difference in years to basetime...  
   IF ( time1%YR > time2%YR ) THEN
@@ -924,7 +924,7 @@
   ENDIF
 !$$$ add tests for multi-year differences
   CALL normalize_timeint( timeIntOut )
-END SUBROUTINE c_esmc_basetimediff
+END SUBROUTINE c_timelibc_basetimediff
 
 
 ! some extra wrf stuff
@@ -935,10 +935,10 @@
 ! denominator is zero, return empty string.
 ! INTEGER*8 interface.  
 SUBROUTINE fraction_to_stringi8( numerator, denominator, frac_str )
-  USE ESMF_basemod
+  USE timelib_basemod
   IMPLICIT NONE
-  INTEGER(ESMF_KIND_I8), INTENT(IN) :: numerator
-  INTEGER(ESMF_KIND_I8), INTENT(IN) :: denominator
+  INTEGER(timelib_KIND_I8), INTENT(IN) :: numerator
+  INTEGER(timelib_KIND_I8), INTENT(IN) :: denominator
   CHARACTER (LEN=*), INTENT(OUT) :: frac_str
   IF ( denominator > 0 ) THEN
     IF ( mod( numerator, denominator ) /= 0 ) THEN
@@ -961,39 +961,39 @@
 ! denominator is zero, return empty string.
 ! INTEGER interface.  
 SUBROUTINE fraction_to_string( numerator, denominator, frac_str )
-  USE ESMF_basemod
+  USE timelib_basemod
   IMPLICIT NONE
   INTEGER, INTENT(IN) :: numerator
   INTEGER, INTENT(IN) :: denominator
   CHARACTER (LEN=*), INTENT(OUT) :: frac_str
   ! locals
-  INTEGER(ESMF_KIND_I8) :: numerator_i8, denominator_i8
-  numerator_i8 = INT( numerator, ESMF_KIND_I8 )
-  denominator_i8 = INT( denominator, ESMF_KIND_I8 )
+  INTEGER(timelib_KIND_I8) :: numerator_i8, denominator_i8
+  numerator_i8 = INT( numerator, timelib_KIND_I8 )
+  denominator_i8 = INT( denominator, timelib_KIND_I8 )
   CALL fraction_to_stringi8( numerator_i8, denominator_i8, frac_str )
 END SUBROUTINE fraction_to_string
 
 
 SUBROUTINE print_a_time( time )
-   use ESMF_basemod
-   use ESMF_Timemod
+   use timelib_basemod
+   use timelib_Timemod
    IMPLICIT NONE
-   type(ESMF_Time) time
+   type(timelib_Time) time
    character*128 :: s
    integer rc
-   CALL ESMF_TimeGet( time, timeString=s, rc=rc )
+   CALL timelib_TimeGet( time, timeString=s, rc=rc )
    print *,'Print a time|',TRIM(s),'|'
    return
 END SUBROUTINE print_a_time
 
 SUBROUTINE print_a_timeinterval( time )
-   use ESMF_basemod
-   use ESMF_TimeIntervalmod
+   use timelib_basemod
+   use timelib_TimeIntervalmod
    IMPLICIT NONE
-   type(ESMF_TimeInterval) time
+   type(timelib_TimeInterval) time
    character*128 :: s
    integer rc
-   CALL ESMFold_TimeIntervalGetString( time, s, rc )
+   CALL timelibold_TimeIntervalGetString( time, s, rc )
    print *,'Print a time interval|',TRIM(s),'|'
    return
 END SUBROUTINE print_a_timeinterval
diff -Naur WRFV3.9/external/esmf_time_f90/module_symbols_util.F90 WRFV3.9.patch/external/esmf_time_f90/module_symbols_util.F90
--- WRFV3.9/external/esmf_time_f90/module_symbols_util.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/module_symbols_util.F90	2017-07-03 16:17:29.686093000 -0400
@@ -1,5 +1,5 @@
 ! 
-! NOTE:  This file will be removed once encapsulation of bare ESMF 
+! NOTE:  This file will be removed once encapsulation of bare timelib 
 !        calls is complete within WRF non-external source code.  
 !
 ! NOTE:  This file was automatically generated by the findsymbol script 
@@ -8,119 +8,119 @@
 ! 1) Run the findsymbol script on a machine that has Ruby installed to 
 !    generate this file.  Type "findsymbol -h" for help using findsymbol.  
 !    For example:  
-! >> hender IN loquat:/loquat2/hender/Ruby/FortranTools/ >> findsymbol -d /users/hender/Tasks/WRF_ESMF/WRFV2_20050512_1410_WORK/WRFV2/external/esmf_time_f90 -S ESMF_ -p -g WRFU_ -o ESMF_Mod -n module_symbols_util > & ! module_symbols_util.F90
+! >> hender IN loquat:/loquat2/hender/Ruby/FortranTools/ >> findsymbol -d /users/hender/Tasks/WRF_timelib/WRFV2_20050512_1410_WORK/WRFV2/external/timelib_time_f90 -S timelib_ -p -g WRFU_ -o timelib_Mod -n module_symbols_util > & ! module_symbols_util.F90
 ! 
 ! 2) Added this comment block by hand.
 !
       MODULE module_symbols_util
 
-        USE ESMF_Mod, WRFU_ALARM => ESMF_ALARM
-        USE ESMF_Mod, WRFU_ALARMCREATE => ESMF_ALARMCREATE
-        USE ESMF_Mod, WRFU_ALARMDESTROY => ESMF_ALARMDESTROY
-        USE ESMF_Mod, WRFU_ALARMDISABLE => ESMF_ALARMDISABLE
-        USE ESMF_Mod, WRFU_ALARMENABLE => ESMF_ALARMENABLE
-        USE ESMF_Mod, WRFU_ALARMGET => ESMF_ALARMGET
-        USE ESMF_Mod, WRFU_ALARMISRINGING => ESMF_ALARMISRINGING
-        USE ESMF_Mod, WRFU_ALARMPRINT => ESMF_ALARMPRINT
-        USE ESMF_Mod, WRFU_ALARMRINGEROFF => ESMF_ALARMRINGEROFF
-        USE ESMF_Mod, WRFU_ALARMRINGERON => ESMF_ALARMRINGERON
-        USE ESMF_Mod, WRFU_ALARMSET => ESMF_ALARMSET
-        USE ESMF_Mod, WRFU_ALARMVALIDATE => ESMF_ALARMVALIDATE
-        USE ESMF_Mod, WRFU_ATTRIBUTE => ESMF_ATTRIBUTE
-        USE ESMF_Mod, WRFU_ATTRIBUTECOPY => ESMF_ATTRIBUTECOPY
-        USE ESMF_Mod, WRFU_ATTRIBUTECOPYALL => ESMF_ATTRIBUTECOPYALL
-        USE ESMF_Mod, WRFU_ATTRIBUTEGET => ESMF_ATTRIBUTEGET
-        USE ESMF_Mod, WRFU_ATTRIBUTEGETBYNUMBER => ESMF_ATTRIBUTEGETBYNUMBER
-        USE ESMF_Mod, WRFU_ATTRIBUTEGETCOUNT => ESMF_ATTRIBUTEGETCOUNT
-        USE ESMF_Mod, WRFU_ATTRIBUTEGETLIST => ESMF_ATTRIBUTEGETLIST
-        USE ESMF_Mod, WRFU_ATTRIBUTEGETNAMELIST => ESMF_ATTRIBUTEGETNAMELIST
-        USE ESMF_Mod, WRFU_ATTRIBUTEGETOBJECTLIST => ESMF_ATTRIBUTEGETOBJECTLIST
-        USE ESMF_Mod, WRFU_ATTRIBUTESET => ESMF_ATTRIBUTESET
-        USE ESMF_Mod, WRFU_ATTRIBUTESETLIST => ESMF_ATTRIBUTESETLIST
-        USE ESMF_Mod, WRFU_ATTRIBUTESETOBJECTLIST => ESMF_ATTRIBUTESETOBJECTLIST
-        USE ESMF_Mod, WRFU_AXISINDEX => ESMF_AXISINDEX
-        USE ESMF_Mod, WRFU_AXISINDEXGET => ESMF_AXISINDEXGET
-        USE ESMF_Mod, WRFU_BAD_POINTER => ESMF_BAD_POINTER
-        USE ESMF_Mod, WRFU_BASE => ESMF_BASE
-        USE ESMF_Mod, WRFU_BASETIME => ESMF_BASETIME
-        USE ESMF_Mod, WRFU_CALENDAR => ESMF_CALENDAR
-        USE ESMF_Mod, WRFU_CALENDARTYPE => ESMF_CALENDARTYPE
-        USE ESMF_Mod, WRFU_CAL_360DAY => ESMF_CAL_360DAY
-        USE ESMF_Mod, WRFU_CAL_GREGORIAN => ESMF_CAL_GREGORIAN
-        USE ESMF_Mod, WRFU_CAL_NOCALENDAR => ESMF_CAL_NOCALENDAR
-        USE ESMF_Mod, WRFU_CAL_NOLEAP => ESMF_CAL_NOLEAP
-        USE ESMF_Mod, WRFU_CLOCK => ESMF_CLOCK
-        USE ESMF_Mod, WRFU_CLOCKADDALARM => ESMF_CLOCKADDALARM
-        USE ESMF_Mod, WRFU_CLOCKADVANCE => ESMF_CLOCKADVANCE
-        USE ESMF_Mod, WRFU_CLOCKCREATE => ESMF_CLOCKCREATE
-        USE ESMF_Mod, WRFU_CLOCKDESTROY => ESMF_CLOCKDESTROY
-        USE ESMF_Mod, WRFU_CLOCKGET => ESMF_CLOCKGET
-        USE ESMF_Mod, WRFU_CLOCKGETALARMLIST => ESMF_CLOCKGETALARMLIST
-        USE ESMF_Mod, WRFU_CLOCKISSTOPTIME => ESMF_CLOCKISSTOPTIME
-        USE ESMF_Mod, WRFU_CLOCKPRINT => ESMF_CLOCKPRINT
-        USE ESMF_Mod, WRFU_CLOCKSET => ESMF_CLOCKSET
-        USE ESMF_Mod, WRFU_CLOCKSTOPTIMEDISABLE => ESMF_CLOCKSTOPTIMEDISABLE
-        USE ESMF_Mod, WRFU_CLOCKVALIDATE => ESMF_CLOCKVALIDATE
-        USE ESMF_Mod, WRFU_DATATYPE => ESMF_DATATYPE
-        USE ESMF_Mod, WRFU_DATATYPESTRING => ESMF_DATATYPESTRING
-        USE ESMF_Mod, WRFU_DATAVALUE => ESMF_DATAVALUE
-        USE ESMF_Mod, WRFU_DATA_CHARACTER => ESMF_DATA_CHARACTER
-        USE ESMF_Mod, WRFU_DATA_INTEGER => ESMF_DATA_INTEGER
-        USE ESMF_Mod, WRFU_DATA_LOGICAL => ESMF_DATA_LOGICAL
-        USE ESMF_Mod, WRFU_DATA_REAL => ESMF_DATA_REAL
-        USE ESMF_Mod, WRFU_FAILURE => ESMF_FAILURE
-        USE ESMF_Mod, WRFU_FINALIZE => ESMF_FINALIZE
-        USE ESMF_Mod, WRFU_FRACTION => ESMF_FRACTION
-        USE ESMF_Mod, WRFU_GETNAME => ESMF_GETNAME
-        USE ESMF_Mod, WRFU_GETPOINTER => ESMF_GETPOINTER
-        USE ESMF_Mod, WRFU_GRID => ESMF_GRID
-        USE ESMF_Mod, WRFU_GRIDCOMP => ESMF_GRIDCOMP
-        USE ESMF_Mod, WRFU_INITIALIZE => ESMF_INITIALIZE
-        USE ESMF_Mod, WRFU_ISINITIALIZED => ESMF_ISINITIALIZED
-        USE ESMF_Mod, WRFU_KIND_C16 => ESMF_KIND_C16
-        USE ESMF_Mod, WRFU_KIND_C8 => ESMF_KIND_C8
-        USE ESMF_Mod, WRFU_KIND_I1 => ESMF_KIND_I1
-        USE ESMF_Mod, WRFU_KIND_I2 => ESMF_KIND_I2
-        USE ESMF_Mod, WRFU_KIND_I4 => ESMF_KIND_I4
-        USE ESMF_Mod, WRFU_KIND_I8 => ESMF_KIND_I8
-        USE ESMF_Mod, WRFU_KIND_R4 => ESMF_KIND_R4
-        USE ESMF_Mod, WRFU_KIND_R8 => ESMF_KIND_R8
-        USE ESMF_Mod, WRFU_LOG => ESMF_LOG
-        USE ESMF_Mod, WRFU_LOGICAL => ESMF_LOGICAL
-        USE ESMF_Mod, WRFU_LOGWRITE => ESMF_LOGWRITE
-        USE ESMF_Mod, WRFU_LOG_ERROR => ESMF_LOG_ERROR
-        USE ESMF_Mod, WRFU_LOG_INFO => ESMF_LOG_INFO
-        USE ESMF_Mod, WRFU_LOG_WARNING => ESMF_LOG_WARNING
-        USE ESMF_Mod, WRFU_MAJOR_VERSION => ESMF_MAJOR_VERSION
-        USE ESMF_Mod, WRFU_MAXDECOMPDIM => ESMF_MAXDECOMPDIM
-        USE ESMF_Mod, WRFU_MAXDIM => ESMF_MAXDIM
-        USE ESMF_Mod, WRFU_MAXGRIDDIM => ESMF_MAXGRIDDIM
-        USE ESMF_Mod, WRFU_MAXSTR => ESMF_MAXSTR
-        USE ESMF_Mod, WRFU_MINOR_VERSION => ESMF_MINOR_VERSION
-        USE ESMF_Mod, WRFU_MSGTYPE => ESMF_MSGTYPE
-        USE ESMF_Mod, WRFU_NULL_POINTER => ESMF_NULL_POINTER
-        USE ESMF_Mod, WRFU_POINTER => ESMF_POINTER
-        USE ESMF_Mod, WRFU_REVISION => ESMF_REVISION
-        USE ESMF_Mod, WRFU_SETNAME => ESMF_SETNAME
-        USE ESMF_Mod, WRFU_SETNULLPOINTER => ESMF_SETNULLPOINTER
-        USE ESMF_Mod, WRFU_SETPOINTER => ESMF_SETPOINTER
-        USE ESMF_Mod, WRFU_STATE => ESMF_STATE
-        USE ESMF_Mod, WRFU_STATE_INVALID => ESMF_STATE_INVALID
-        USE ESMF_Mod, WRFU_STATUS => ESMF_STATUS
-        USE ESMF_Mod, WRFU_STATUSSTRING => ESMF_STATUSSTRING
-        USE ESMF_Mod, WRFU_SUCCESS => ESMF_SUCCESS
-        USE ESMF_Mod, WRFU_TIME => ESMF_TIME
-        USE ESMF_Mod, WRFU_TIMEEQ => ESMF_TIMEEQ
-        USE ESMF_Mod, WRFU_TIMEGET => ESMF_TIMEGET
-        USE ESMF_Mod, WRFU_TIMEINTERVAL => ESMF_TIMEINTERVAL
-        USE ESMF_Mod, WRFU_TIMEINTERVALABSVALUE => ESMF_TIMEINTERVALABSVALUE
-        USE ESMF_Mod, WRFU_TIMEINTERVALDIVQUOT => ESMF_TIMEINTERVALDIVQUOT
-        USE ESMF_Mod, WRFU_TIMEINTERVALGET => ESMF_TIMEINTERVALGET
-        USE ESMF_Mod, WRFU_TIMEINTERVALNEGABSVALUE => ESMF_TIMEINTERVALNEGABSVALUE
-        USE ESMF_Mod, WRFU_TIMEINTERVALSET => ESMF_TIMEINTERVALSET
-        USE ESMF_Mod, WRFU_TIMESET => ESMF_TIMESET
-        USE ESMF_Mod, WRFU_VERSION_STRING => ESMF_VERSION_STRING
-        USE ESMF_Mod, WRFU_VM => ESMF_VM
+        USE timelib_Mod, WRFU_ALARM => timelib_ALARM
+        USE timelib_Mod, WRFU_ALARMCREATE => timelib_ALARMCREATE
+        USE timelib_Mod, WRFU_ALARMDESTROY => timelib_ALARMDESTROY
+        USE timelib_Mod, WRFU_ALARMDISABLE => timelib_ALARMDISABLE
+        USE timelib_Mod, WRFU_ALARMENABLE => timelib_ALARMENABLE
+        USE timelib_Mod, WRFU_ALARMGET => timelib_ALARMGET
+        USE timelib_Mod, WRFU_ALARMISRINGING => timelib_ALARMISRINGING
+        USE timelib_Mod, WRFU_ALARMPRINT => timelib_ALARMPRINT
+        USE timelib_Mod, WRFU_ALARMRINGEROFF => timelib_ALARMRINGEROFF
+        USE timelib_Mod, WRFU_ALARMRINGERON => timelib_ALARMRINGERON
+        USE timelib_Mod, WRFU_ALARMSET => timelib_ALARMSET
+        USE timelib_Mod, WRFU_ALARMVALIDATE => timelib_ALARMVALIDATE
+        USE timelib_Mod, WRFU_ATTRIBUTE => timelib_ATTRIBUTE
+        USE timelib_Mod, WRFU_ATTRIBUTECOPY => timelib_ATTRIBUTECOPY
+        USE timelib_Mod, WRFU_ATTRIBUTECOPYALL => timelib_ATTRIBUTECOPYALL
+        USE timelib_Mod, WRFU_ATTRIBUTEGET => timelib_ATTRIBUTEGET
+        USE timelib_Mod, WRFU_ATTRIBUTEGETBYNUMBER => timelib_ATTRIBUTEGETBYNUMBER
+        USE timelib_Mod, WRFU_ATTRIBUTEGETCOUNT => timelib_ATTRIBUTEGETCOUNT
+        USE timelib_Mod, WRFU_ATTRIBUTEGETLIST => timelib_ATTRIBUTEGETLIST
+        USE timelib_Mod, WRFU_ATTRIBUTEGETNAMELIST => timelib_ATTRIBUTEGETNAMELIST
+        USE timelib_Mod, WRFU_ATTRIBUTEGETOBJECTLIST => timelib_ATTRIBUTEGETOBJECTLIST
+        USE timelib_Mod, WRFU_ATTRIBUTESET => timelib_ATTRIBUTESET
+        USE timelib_Mod, WRFU_ATTRIBUTESETLIST => timelib_ATTRIBUTESETLIST
+        USE timelib_Mod, WRFU_ATTRIBUTESETOBJECTLIST => timelib_ATTRIBUTESETOBJECTLIST
+        USE timelib_Mod, WRFU_AXISINDEX => timelib_AXISINDEX
+        USE timelib_Mod, WRFU_AXISINDEXGET => timelib_AXISINDEXGET
+        USE timelib_Mod, WRFU_BAD_POINTER => timelib_BAD_POINTER
+        USE timelib_Mod, WRFU_BASE => timelib_BASE
+        USE timelib_Mod, WRFU_BASETIME => timelib_BASETIME
+        USE timelib_Mod, WRFU_CALENDAR => timelib_CALENDAR
+        USE timelib_Mod, WRFU_CALENDARTYPE => timelib_CALENDARTYPE
+        USE timelib_Mod, WRFU_CAL_360DAY => timelib_CAL_360DAY
+        USE timelib_Mod, WRFU_CAL_GREGORIAN => timelib_CAL_GREGORIAN
+        USE timelib_Mod, WRFU_CAL_NOCALENDAR => timelib_CAL_NOCALENDAR
+        USE timelib_Mod, WRFU_CAL_NOLEAP => timelib_CAL_NOLEAP
+        USE timelib_Mod, WRFU_CLOCK => timelib_CLOCK
+        USE timelib_Mod, WRFU_CLOCKADDALARM => timelib_CLOCKADDALARM
+        USE timelib_Mod, WRFU_CLOCKADVANCE => timelib_CLOCKADVANCE
+        USE timelib_Mod, WRFU_CLOCKCREATE => timelib_CLOCKCREATE
+        USE timelib_Mod, WRFU_CLOCKDESTROY => timelib_CLOCKDESTROY
+        USE timelib_Mod, WRFU_CLOCKGET => timelib_CLOCKGET
+        USE timelib_Mod, WRFU_CLOCKGETALARMLIST => timelib_CLOCKGETALARMLIST
+        USE timelib_Mod, WRFU_CLOCKISSTOPTIME => timelib_CLOCKISSTOPTIME
+        USE timelib_Mod, WRFU_CLOCKPRINT => timelib_CLOCKPRINT
+        USE timelib_Mod, WRFU_CLOCKSET => timelib_CLOCKSET
+        USE timelib_Mod, WRFU_CLOCKSTOPTIMEDISABLE => timelib_CLOCKSTOPTIMEDISABLE
+        USE timelib_Mod, WRFU_CLOCKVALIDATE => timelib_CLOCKVALIDATE
+        USE timelib_Mod, WRFU_DATATYPE => timelib_DATATYPE
+        USE timelib_Mod, WRFU_DATATYPESTRING => timelib_DATATYPESTRING
+        USE timelib_Mod, WRFU_DATAVALUE => timelib_DATAVALUE
+        USE timelib_Mod, WRFU_DATA_CHARACTER => timelib_DATA_CHARACTER
+        USE timelib_Mod, WRFU_DATA_INTEGER => timelib_DATA_INTEGER
+        USE timelib_Mod, WRFU_DATA_LOGICAL => timelib_DATA_LOGICAL
+        USE timelib_Mod, WRFU_DATA_REAL => timelib_DATA_REAL
+        USE timelib_Mod, WRFU_FAILURE => timelib_FAILURE
+        USE timelib_Mod, WRFU_FINALIZE => timelib_FINALIZE
+        USE timelib_Mod, WRFU_FRACTION => timelib_FRACTION
+        USE timelib_Mod, WRFU_GETNAME => timelib_GETNAME
+        USE timelib_Mod, WRFU_GETPOINTER => timelib_GETPOINTER
+        USE timelib_Mod, WRFU_GRID => timelib_GRID
+        USE timelib_Mod, WRFU_GRIDCOMP => timelib_GRIDCOMP
+        USE timelib_Mod, WRFU_INITIALIZE => timelib_INITIALIZE
+        USE timelib_Mod, WRFU_ISINITIALIZED => timelib_ISINITIALIZED
+        USE timelib_Mod, WRFU_KIND_C16 => timelib_KIND_C16
+        USE timelib_Mod, WRFU_KIND_C8 => timelib_KIND_C8
+        USE timelib_Mod, WRFU_KIND_I1 => timelib_KIND_I1
+        USE timelib_Mod, WRFU_KIND_I2 => timelib_KIND_I2
+        USE timelib_Mod, WRFU_KIND_I4 => timelib_KIND_I4
+        USE timelib_Mod, WRFU_KIND_I8 => timelib_KIND_I8
+        USE timelib_Mod, WRFU_KIND_R4 => timelib_KIND_R4
+        USE timelib_Mod, WRFU_KIND_R8 => timelib_KIND_R8
+        USE timelib_Mod, WRFU_LOG => timelib_LOG
+        USE timelib_Mod, WRFU_LOGICAL => timelib_LOGICAL
+        USE timelib_Mod, WRFU_LOGWRITE => timelib_LOGWRITE
+        USE timelib_Mod, WRFU_LOG_ERROR => timelib_LOG_ERROR
+        USE timelib_Mod, WRFU_LOG_INFO => timelib_LOG_INFO
+        USE timelib_Mod, WRFU_LOG_WARNING => timelib_LOG_WARNING
+        USE timelib_Mod, WRFU_MAJOR_VERSION => timelib_MAJOR_VERSION
+        USE timelib_Mod, WRFU_MAXDECOMPDIM => timelib_MAXDECOMPDIM
+        USE timelib_Mod, WRFU_MAXDIM => timelib_MAXDIM
+        USE timelib_Mod, WRFU_MAXGRIDDIM => timelib_MAXGRIDDIM
+        USE timelib_Mod, WRFU_MAXSTR => timelib_MAXSTR
+        USE timelib_Mod, WRFU_MINOR_VERSION => timelib_MINOR_VERSION
+        USE timelib_Mod, WRFU_MSGTYPE => timelib_MSGTYPE
+        USE timelib_Mod, WRFU_NULL_POINTER => timelib_NULL_POINTER
+        USE timelib_Mod, WRFU_POINTER => timelib_POINTER
+        USE timelib_Mod, WRFU_REVISION => timelib_REVISION
+        USE timelib_Mod, WRFU_SETNAME => timelib_SETNAME
+        USE timelib_Mod, WRFU_SETNULLPOINTER => timelib_SETNULLPOINTER
+        USE timelib_Mod, WRFU_SETPOINTER => timelib_SETPOINTER
+        USE timelib_Mod, WRFU_STATE => timelib_STATE
+        USE timelib_Mod, WRFU_STATE_INVALID => timelib_STATE_INVALID
+        USE timelib_Mod, WRFU_STATUS => timelib_STATUS
+        USE timelib_Mod, WRFU_STATUSSTRING => timelib_STATUSSTRING
+        USE timelib_Mod, WRFU_SUCCESS => timelib_SUCCESS
+        USE timelib_Mod, WRFU_TIME => timelib_TIME
+        USE timelib_Mod, WRFU_TIMEEQ => timelib_TIMEEQ
+        USE timelib_Mod, WRFU_TIMEGET => timelib_TIMEGET
+        USE timelib_Mod, WRFU_TIMEINTERVAL => timelib_TIMEINTERVAL
+        USE timelib_Mod, WRFU_TIMEINTERVALABSVALUE => timelib_TIMEINTERVALABSVALUE
+        USE timelib_Mod, WRFU_TIMEINTERVALDIVQUOT => timelib_TIMEINTERVALDIVQUOT
+        USE timelib_Mod, WRFU_TIMEINTERVALGET => timelib_TIMEINTERVALGET
+        USE timelib_Mod, WRFU_TIMEINTERVALNEGABSVALUE => timelib_TIMEINTERVALNEGABSVALUE
+        USE timelib_Mod, WRFU_TIMEINTERVALSET => timelib_TIMEINTERVALSET
+        USE timelib_Mod, WRFU_TIMESET => timelib_TIMESET
+        USE timelib_Mod, WRFU_VERSION_STRING => timelib_VERSION_STRING
+        USE timelib_Mod, WRFU_VM => timelib_VM
 
       END MODULE module_symbols_util
 
diff -Naur WRFV3.9/external/esmf_time_f90/Test1.F90 WRFV3.9.patch/external/esmf_time_f90/Test1.F90
--- WRFV3.9/external/esmf_time_f90/Test1.F90	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/Test1.F90	2017-07-03 16:17:29.685175000 -0400
@@ -1,11 +1,11 @@
 !
-! Sub-system tests for esmf_time_f90
+! Sub-system tests for timelib_time_f90
 !
 ! Someday, switch over to funit!  
 !
 
 MODULE my_tests
-  USE ESMF_Mod
+  USE timelib_Mod
   IMPLICIT NONE
 
   ! Set this to .TRUE. to make wrf_error_fatal3() print a message on failure 
@@ -15,7 +15,7 @@
 
 CONTAINS
 
-  ! Test printing of an ESMF_Time or ESMF_TimeInterval object.  
+  ! Test printing of an timelib_Time or timelib_TimeInterval object.  
   !
   ! Correct results are also passed in through this interface and compared 
   ! with computed results.  PASS/FAIL messages are printed.  
@@ -64,9 +64,9 @@
     CHARACTER (LEN=512) :: itestname
     LOGICAL :: iexpect_error
     INTEGER rc
-    TYPE(ESMF_Time)           :: t
-    TYPE(ESMF_TimeInterval)   :: ti
-    CHARACTER(LEN=ESMF_MAXSTR) :: str, computed_str, frac_str
+    TYPE(timelib_Time)           :: t
+    TYPE(timelib_TimeInterval)   :: ti
+    CHARACTER(LEN=timelib_MAXSTR) :: str, computed_str, frac_str
     CHARACTER(LEN=17) :: type_str
     INTEGER :: res_len, computed_len, Sn, Sd
     LOGICAL :: test_passed
@@ -131,38 +131,38 @@
     Sn = 0
     Sd = 0
     IF ( is_t ) THEN
-      type_str = 'ESMF_Time'
-!PRINT *,'DEBUG:  test_print():  calling ESMF_TimeSet()'
+      type_str = 'timelib_Time'
+!PRINT *,'DEBUG:  test_print():  calling timelib_TimeSet()'
 !PRINT *,'DEBUG:  test_print():  YY,MM,DD,H,M,S,Sn,Sd = ', it_YY,it_MM,it_DD,it_H,it_M,it_S,it_Sn,it_Sd
-      CALL ESMF_TimeSet( t, YY=it_YY, MM=it_MM, DD=it_DD , &
+      CALL timelib_TimeSet( t, YY=it_YY, MM=it_MM, DD=it_DD , &
                              H=it_H, M=it_M, S=it_S, Sn=it_Sn, Sd=it_Sd, rc=rc )
-!PRINT *,'DEBUG:  test_print():  back from ESMF_TimeSet()'
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                             TRIM(itestname)//'ESMF_TimeSet() ', &
+!PRINT *,'DEBUG:  test_print():  back from timelib_TimeSet()'
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                             TRIM(itestname)//'timelib_TimeSet() ', &
                              __FILE__ , &
                              __LINE__  )
-!PRINT *,'DEBUG:  test_print():  calling ESMF_TimeGet()'
-      CALL ESMF_TimeGet( t, timeString=computed_str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestname)//'ESMF_TimeGet() ', &
+!PRINT *,'DEBUG:  test_print():  calling timelib_TimeGet()'
+      CALL timelib_TimeGet( t, timeString=computed_str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
-!PRINT *,'DEBUG:  test_print():  back from ESMF_TimeGet(), computed_str = ',TRIM(computed_str)
+!PRINT *,'DEBUG:  test_print():  back from timelib_TimeGet(), computed_str = ',TRIM(computed_str)
     ELSE
-      type_str = 'ESMF_TimeInterval'
-!PRINT *,'DEBUG:  test_print():  calling ESMF_TimeIntervalSet()'
-      CALL ESMF_TimeIntervalSet( ti, YY=iti_YY, MM=iti_MM, &
+      type_str = 'timelib_TimeInterval'
+!PRINT *,'DEBUG:  test_print():  calling timelib_TimeIntervalSet()'
+      CALL timelib_TimeIntervalSet( ti, YY=iti_YY, MM=iti_MM, &
                                       D=iti_DD ,           &
                                       H=iti_H, M=iti_M,    &
                                       S=iti_S, Sn=iti_Sn, Sd=iti_Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                             TRIM(itestname)//'ESMF_TimeIntervalSet() ', &
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                             TRIM(itestname)//'timelib_TimeIntervalSet() ', &
                              __FILE__ , &
                              __LINE__  )
-!PRINT *,'DEBUG:  test_print():  calling ESMF_TimeIntervalGet()'
-      CALL ESMF_TimeIntervalGet( ti, timeString=computed_str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestname)//'ESMF_TimeGet() ', &
+!PRINT *,'DEBUG:  test_print():  calling timelib_TimeIntervalGet()'
+      CALL timelib_TimeIntervalGet( ti, timeString=computed_str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
     ENDIF
@@ -203,16 +203,16 @@
 
 
 
-  ! Test the following arithmetic operations on ESMF_Time and 
-  ! ESMF_TimeInterval objects:
-  !  ESMF_Time         = ESMF_Time         + ESMF_TimeInterval
-  !  ESMF_Time         = ESMF_TimeInterval + ESMF_Time
-  !  ESMF_Time         = ESMF_Time         - ESMF_TimeInterval
-  !  ESMF_TimeInterval = ESMF_Time         - ESMF_Time        
-  !  ESMF_TimeInterval = ESMF_TimeInterval + ESMF_TimeInterval
-  !  ESMF_TimeInterval = ESMF_TimeInterval - ESMF_TimeInterval
-  !  ESMF_TimeInterval = ESMF_TimeInterval * INTEGER
-  !  ESMF_TimeInterval = ESMF_TimeInterval / INTEGER
+  ! Test the following arithmetic operations on timelib_Time and 
+  ! timelib_TimeInterval objects:
+  !  timelib_Time         = timelib_Time         + timelib_TimeInterval
+  !  timelib_Time         = timelib_TimeInterval + timelib_Time
+  !  timelib_Time         = timelib_Time         - timelib_TimeInterval
+  !  timelib_TimeInterval = timelib_Time         - timelib_Time        
+  !  timelib_TimeInterval = timelib_TimeInterval + timelib_TimeInterval
+  !  timelib_TimeInterval = timelib_TimeInterval - timelib_TimeInterval
+  !  timelib_TimeInterval = timelib_TimeInterval * INTEGER
+  !  timelib_TimeInterval = timelib_TimeInterval / INTEGER
   !
   ! Correct results are also passed in through this interface and compared 
   ! with computed results.  PASS/FAIL messages are printed.  
@@ -344,9 +344,9 @@
     LOGICAL :: iexpect_error
     INTEGER :: rc
     INTEGER :: computed_int, Sn, Sd
-    TYPE(ESMF_Time)           :: op1_t , op2_t , res_t, computed_t
-    TYPE(ESMF_TimeInterval)   :: op1_ti, op2_ti, res_ti, computed_ti
-    CHARACTER(LEN=ESMF_MAXSTR) :: str, op1_str, op2_str, res_str, computed_str, frac_str
+    TYPE(timelib_Time)           :: op1_t , op2_t , res_t, computed_t
+    TYPE(timelib_TimeInterval)   :: op1_ti, op2_ti, res_ti, computed_ti
+    CHARACTER(LEN=timelib_MAXSTR) :: str, op1_str, op2_str, res_str, computed_str, frac_str
     CHARACTER(LEN=1) :: op_str
     CHARACTER(LEN=17) :: op1_type_str, op2_type_str, res_type_str
 
@@ -526,34 +526,34 @@
 
     ! Initialize op1
     IF ( op1_is_t ) THEN
-      op1_type_str = 'ESMF_Time'
-      CALL ESMF_TimeSet( op1_t, YY=iop1_t_YY, MM=iop1_t_MM, DD=iop1_t_DD , &
+      op1_type_str = 'timelib_Time'
+      CALL timelib_TimeSet( op1_t, YY=iop1_t_YY, MM=iop1_t_MM, DD=iop1_t_DD , &
                                  H=iop1_t_H, M=iop1_t_M, S=iop1_t_S, Sn=iop1_t_Sn, Sd=iop1_t_Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                             TRIM(itestname)//'ESMF_TimeSet() ', &
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                             TRIM(itestname)//'timelib_TimeSet() ', &
                              __FILE__ , &
                              __LINE__  )
-      CALL ESMF_TimeGet( op1_t, timeString=op1_str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeGet( op1_t, timeString=op1_str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       ! handle fractions
       CALL fraction_to_string( Sn, Sd, frac_str )
       op1_str = TRIM(op1_str)//TRIM(frac_str)
     ELSE
-      op1_type_str = 'ESMF_TimeInterval'
-      CALL ESMF_TimeIntervalSet( op1_ti, YY=iop1_ti_YY, MM=iop1_ti_MM, &
+      op1_type_str = 'timelib_TimeInterval'
+      CALL timelib_TimeIntervalSet( op1_ti, YY=iop1_ti_YY, MM=iop1_ti_MM, &
                                           D=iop1_ti_DD ,               &
                                           H=iop1_ti_H, M=iop1_ti_M,    &
                                           S=iop1_ti_S, Sn=iop1_ti_Sn, Sd=iop1_ti_Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                             TRIM(itestname)//'ESMF_TimeIntervalSet() ', &
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                             TRIM(itestname)//'timelib_TimeIntervalSet() ', &
                              __FILE__ , &
                              __LINE__  )
-      CALL ESMF_TimeIntervalGet( op1_ti, timeString=op1_str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeIntervalGet( op1_ti, timeString=op1_str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       ! handle fractions
@@ -562,34 +562,34 @@
     ENDIF
     ! Initialize op2
     IF ( op2_is_t ) THEN
-      op2_type_str = 'ESMF_Time'
-      CALL ESMF_TimeSet( op2_t, YY=iop2_t_YY, MM=iop2_t_MM, DD=iop2_t_DD , &
+      op2_type_str = 'timelib_Time'
+      CALL timelib_TimeSet( op2_t, YY=iop2_t_YY, MM=iop2_t_MM, DD=iop2_t_DD , &
                                  H=iop2_t_H, M=iop2_t_M, S=iop2_t_S, Sn=iop2_t_Sn, Sd=iop2_t_Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                             TRIM(itestname)//'ESMF_TimeSet() ', &
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                             TRIM(itestname)//'timelib_TimeSet() ', &
                              __FILE__ , &
                              __LINE__  )
-      CALL ESMF_TimeGet( op2_t, timeString=op2_str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeGet( op2_t, timeString=op2_str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       ! handle fractions
       CALL fraction_to_string( Sn, Sd, frac_str )
       op2_str = TRIM(op2_str)//TRIM(frac_str)
     ELSE IF ( op2_is_ti ) THEN
-      op2_type_str = 'ESMF_TimeInterval'
-      CALL ESMF_TimeIntervalSet( op2_ti, YY=iop2_ti_YY, MM=iop2_ti_MM, &
+      op2_type_str = 'timelib_TimeInterval'
+      CALL timelib_TimeIntervalSet( op2_ti, YY=iop2_ti_YY, MM=iop2_ti_MM, &
                                           D=iop2_ti_DD ,               &
                                           H=iop2_ti_H, M=iop2_ti_M,    &
                                           S=iop2_ti_S, Sn=iop2_ti_Sn, Sd=iop2_ti_Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                             TRIM(itestname)//'ESMF_TimeIntervalSet() ', &
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                             TRIM(itestname)//'timelib_TimeIntervalSet() ', &
                              __FILE__ , &
                              __LINE__  )
-      CALL ESMF_TimeIntervalGet( op2_ti, timeString=op2_str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeIntervalGet( op2_ti, timeString=op2_str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       ! handle fractions
@@ -604,35 +604,35 @@
       ENDIF
     ENDIF
     ! Initialize res
-    IF ( res_is_t ) THEN  ! result is ESMF_Time
-      res_type_str = 'ESMF_Time'
-      CALL ESMF_TimeSet( res_t, YY=ires_t_YY, MM=ires_t_MM, DD=ires_t_DD , &
+    IF ( res_is_t ) THEN  ! result is timelib_Time
+      res_type_str = 'timelib_Time'
+      CALL timelib_TimeSet( res_t, YY=ires_t_YY, MM=ires_t_MM, DD=ires_t_DD , &
                                  H=ires_t_H, M=ires_t_M, S=ires_t_S, Sn=ires_t_Sn, Sd=ires_t_Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                             TRIM(itestname)//'ESMF_TimeSet() ', &
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                             TRIM(itestname)//'timelib_TimeSet() ', &
                              __FILE__ , &
                              __LINE__  )
-      CALL ESMF_TimeGet( res_t, timeString=res_str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeGet( res_t, timeString=res_str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       ! handle fractions
       CALL fraction_to_string( Sn, Sd, frac_str )
       res_str = TRIM(res_str)//TRIM(frac_str)
-    ELSE IF ( res_is_ti ) THEN  ! result is ESMF_TimeInterval
-      res_type_str = 'ESMF_TimeInterval'
-      CALL ESMF_TimeIntervalSet( res_ti, YY=ires_ti_YY, MM=ires_ti_MM, &
+    ELSE IF ( res_is_ti ) THEN  ! result is timelib_TimeInterval
+      res_type_str = 'timelib_TimeInterval'
+      CALL timelib_TimeIntervalSet( res_ti, YY=ires_ti_YY, MM=ires_ti_MM, &
                                           D=ires_ti_DD ,               &
                                           H=ires_ti_H, M=ires_ti_M,    &
                                           S=ires_ti_S, Sn=ires_ti_Sn, Sd=ires_ti_Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                             TRIM(itestname)//'ESMF_TimeIntervalSet() ', &
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                             TRIM(itestname)//'timelib_TimeIntervalSet() ', &
                              __FILE__ , &
                              __LINE__  )
-      CALL ESMF_TimeIntervalGet( res_ti, timeString=res_str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeIntervalGet( res_ti, timeString=res_str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       ! handle fractions
@@ -654,19 +654,19 @@
     ! add
     IF ( iadd_op ) THEN
       op_str = '+'
-      IF ( res_is_t ) THEN  ! result is ESMF_Time
+      IF ( res_is_t ) THEN  ! result is timelib_Time
         IF ( op1_is_t .AND. op2_is_ti ) THEN
-          !  ESMF_Time         = ESMF_Time         + ESMF_TimeInterval
+          !  timelib_Time         = timelib_Time         + timelib_TimeInterval
           computed_t = op1_t + op2_ti
         ELSE IF ( op1_is_ti .AND. op2_is_t ) THEN
-          !  ESMF_Time         = ESMF_TimeInterval + ESMF_Time
+          !  timelib_Time         = timelib_TimeInterval + timelib_Time
           computed_t = op1_ti + op2_t
         ELSE
           unsupported_op = .TRUE.
         ENDIF
-      ELSE  ! result is ESMF_TimeInterval
+      ELSE  ! result is timelib_TimeInterval
         IF ( op1_is_ti .AND. op2_is_ti ) THEN
-          !  ESMF_TimeInterval = ESMF_TimeInterval + ESMF_TimeInterval
+          !  timelib_TimeInterval = timelib_TimeInterval + timelib_TimeInterval
           computed_ti = op1_ti + op2_ti
         ELSE
           unsupported_op = .TRUE.
@@ -675,19 +675,19 @@
     ! subtract
     ELSE  IF ( isubtract_op ) THEN
       op_str = '-'
-      IF ( res_is_t ) THEN  ! result is ESMF_Time
+      IF ( res_is_t ) THEN  ! result is timelib_Time
         IF ( op1_is_t .AND. op2_is_ti ) THEN
-          !  ESMF_Time         = ESMF_Time         - ESMF_TimeInterval
+          !  timelib_Time         = timelib_Time         - timelib_TimeInterval
           computed_t = op1_t - op2_ti
         ELSE
           unsupported_op = .TRUE.
         ENDIF
-      ELSE  ! result is ESMF_TimeInterval
+      ELSE  ! result is timelib_TimeInterval
         IF ( op1_is_t .AND. op2_is_t ) THEN
-          !  ESMF_TimeInterval = ESMF_Time         - ESMF_Time        
+          !  timelib_TimeInterval = timelib_Time         - timelib_Time        
           computed_ti = op1_t - op2_t
         ELSE IF ( op1_is_ti .AND. op2_is_ti ) THEN
-          !  ESMF_TimeInterval = ESMF_TimeInterval - ESMF_TimeInterval
+          !  timelib_TimeInterval = timelib_TimeInterval - timelib_TimeInterval
           computed_ti = op1_ti - op2_ti
         ELSE
           unsupported_op = .TRUE.
@@ -695,9 +695,9 @@
       ENDIF
     ELSE  IF ( imultiply_op ) THEN
       op_str = '*'
-      IF ( res_is_ti ) THEN  ! result is ESMF_TimeInterval
+      IF ( res_is_ti ) THEN  ! result is timelib_TimeInterval
         IF ( op1_is_ti .AND. op2_is_int ) THEN
-          !  ESMF_TimeInterval = ESMF_TimeInterval * INTEGER
+          !  timelib_TimeInterval = timelib_TimeInterval * INTEGER
           computed_ti = op1_ti * op2_int
         ELSE
           unsupported_op = .TRUE.
@@ -705,18 +705,18 @@
       ENDIF
     ELSE  IF ( idivide_op ) THEN
       op_str = '/'
-      IF ( res_is_ti ) THEN  ! result is ESMF_TimeInterval
+      IF ( res_is_ti ) THEN  ! result is timelib_TimeInterval
         IF ( op1_is_ti .AND. op2_is_int ) THEN
-          !  ESMF_TimeInterval = ESMF_TimeInterval / INTEGER
+          !  timelib_TimeInterval = timelib_TimeInterval / INTEGER
           computed_ti = op1_ti / op2_int
         ELSE
           unsupported_op = .TRUE.
         ENDIF
       ELSE IF ( res_is_int ) THEN  ! result is INTEGER
         IF ( op1_is_ti .AND. op2_is_ti ) THEN
-          !  INTEGER = ESMF_TimeInterval / ESMF_TimeInterval
+          !  INTEGER = timelib_TimeInterval / timelib_TimeInterval
           ! number of whole time intervals
-          computed_int = ESMF_TimeIntervalDIVQuot( op1_ti , op2_ti )
+          computed_int = timelib_TimeIntervalDIVQuot( op1_ti , op2_ti )
         ELSE
           unsupported_op = .TRUE.
         ENDIF
@@ -734,26 +734,26 @@
 
     ! check result
     test_passed = .FALSE.
-    IF ( res_is_t ) THEN  ! result is ESMF_Time
+    IF ( res_is_t ) THEN  ! result is timelib_Time
       IF ( computed_t == res_t ) THEN
         test_passed = .TRUE.
       ELSE
-        CALL ESMF_TimeGet( computed_t, timeString=computed_str, Sn=Sn, Sd=Sd, rc=rc )
-        CALL test_check_error( ESMF_SUCCESS, rc, &
-                              TRIM(itestname)//'ESMF_TimeGet() ', &
+        CALL timelib_TimeGet( computed_t, timeString=computed_str, Sn=Sn, Sd=Sd, rc=rc )
+        CALL test_check_error( timelib_SUCCESS, rc, &
+                              TRIM(itestname)//'timelib_TimeGet() ', &
                               __FILE__ , &
                               __LINE__  )
         ! handle fractions
         CALL fraction_to_string( Sn, Sd, frac_str )
         computed_str = TRIM(computed_str)//TRIM(frac_str)
       ENDIF
-    ELSE IF ( res_is_ti ) THEN  ! result is ESMF_TimeInterval
+    ELSE IF ( res_is_ti ) THEN  ! result is timelib_TimeInterval
       IF ( computed_ti == res_ti ) THEN
         test_passed = .TRUE.
       ELSE
-        CALL ESMF_TimeIntervalGet( computed_ti, timeString=computed_str, Sn=Sn, Sd=Sd, rc=rc )
-        CALL test_check_error( ESMF_SUCCESS, rc, &
-                              TRIM(itestname)//'ESMF_TimeGet() ', &
+        CALL timelib_TimeIntervalGet( computed_ti, timeString=computed_str, Sn=Sn, Sd=Sd, rc=rc )
+        CALL test_check_error( timelib_SUCCESS, rc, &
+                              TRIM(itestname)//'timelib_TimeGet() ', &
                               __FILE__ , &
                               __LINE__  )
         ! handle fractions
@@ -840,13 +840,13 @@
     INTEGER :: iincrement_Sd
     INTEGER :: Sn, Sd
     INTEGER rc
-    TYPE(ESMF_Time)           :: start_time, stop_time, current_time
-    TYPE(ESMF_Clock), POINTER :: domain_clock
-    TYPE(ESMF_TimeInterval)   :: timestep, increment
-    TYPE(ESMF_Time)           :: add_time, subtract_time
+    TYPE(timelib_Time)           :: start_time, stop_time, current_time
+    TYPE(timelib_Clock), POINTER :: domain_clock
+    TYPE(timelib_TimeInterval)   :: timestep, increment
+    TYPE(timelib_Time)           :: add_time, subtract_time
     INTEGER :: itimestep
-    REAL(ESMF_KIND_R8) :: dayr8
-    CHARACTER(LEN=ESMF_MAXSTR) :: str, frac_str
+    REAL(timelib_KIND_R8) :: dayr8
+    CHARACTER(LEN=timelib_MAXSTR) :: str, frac_str
 
     istart_YY = 0
     istart_MM = 1
@@ -896,45 +896,45 @@
 
     ! Initialize start time, stop time, time step, clock for simple case. 
     itestfullname = TRIM(itestname)//'SETUP'
-    CALL ESMF_TimeSet( start_time, YY=istart_YY, MM=istart_MM, DD=istart_DD , &
+    CALL timelib_TimeSet( start_time, YY=istart_YY, MM=istart_MM, DD=istart_DD , &
                                    H=istart_H, M=istart_M, S=istart_S, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeSet() ', &
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeSet() ', &
                           __FILE__ , &
                           __LINE__  )
 
-    CALL ESMF_TimeGet( start_time, timeString=str, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeGet() ', &
+    CALL timelib_TimeGet( start_time, timeString=str, rc=rc )
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeGet() ', &
                           __FILE__ , &
                           __LINE__  )
     WRITE(*,FMT='(A,A,A,A)') TRIM(itestfullname),':  start_time = <',TRIM(str),'>'
 
-    CALL ESMF_TimeSet( stop_time, YY=istop_YY, MM=istop_MM, DD=istop_DD , &
+    CALL timelib_TimeSet( stop_time, YY=istop_YY, MM=istop_MM, DD=istop_DD , &
                                    H=istop_H, M=istop_M, S=istop_S, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeSet() ', &
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeSet() ', &
                           __FILE__ , &
                           __LINE__  )
 
-    CALL ESMF_TimeGet( stop_time, timeString=str, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeGet() ', &
+    CALL timelib_TimeGet( stop_time, timeString=str, rc=rc )
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeGet() ', &
                           __FILE__ , &
                           __LINE__  )
     WRITE(*,FMT='(A,A,A,A)') TRIM(itestfullname),':  stop_time = <',TRIM(str),'>'
 
-    CALL ESMF_TimeIntervalSet( timestep, D=itimestep_D, H=itimestep_H, &
+    CALL timelib_TimeIntervalSet( timestep, D=itimestep_D, H=itimestep_H, &
                                          M=itimestep_M, S=itimestep_S, &
                                          Sn=itimestep_Sn, Sd=itimestep_Sd, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeIntervalSet() ', &
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeIntervalSet() ', &
                           __FILE__ , &
                           __LINE__  )
 
-    CALL ESMF_TimeIntervalGet( timestep, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeIntervalGet() ', &
+    CALL timelib_TimeIntervalGet( timestep, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeIntervalGet() ', &
                           __FILE__ , &
                           __LINE__  )
     ! handle fractions
@@ -942,16 +942,16 @@
     str = TRIM(str)//TRIM(frac_str)
     WRITE(*,FMT='(A,A,A,A)') TRIM(itestfullname),':  timestep = <',TRIM(str),'>'
 
-    CALL ESMF_TimeIntervalSet( increment, S=iincrement_S, &
+    CALL timelib_TimeIntervalSet( increment, S=iincrement_S, &
                                Sn=iincrement_Sn, Sd=iincrement_Sd, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeIntervalSet() ', &
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeIntervalSet() ', &
                           __FILE__ , &
                           __LINE__  )
 
-    CALL ESMF_TimeIntervalGet( increment, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeIntervalGet() ', &
+    CALL timelib_TimeIntervalGet( increment, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeIntervalGet() ', &
                           __FILE__ , &
                           __LINE__  )
     ! handle fractions
@@ -960,42 +960,42 @@
     WRITE(*,FMT='(A,A,A,A)') TRIM(itestfullname),':  increment = <',TRIM(str),'>'
 
     ALLOCATE( domain_clock )
-    domain_clock = ESMF_ClockCreate( TimeStep= timestep,  &
+    domain_clock = timelib_ClockCreate( TimeStep= timestep,  &
                                      StartTime=start_time, &
                                      StopTime= stop_time,  &
                                      rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_ClockCreate() ', &
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_ClockCreate() ', &
                           __FILE__ , &
                           __LINE__  )
 
-    CALL ESMF_ClockGet( domain_clock, CurrTime=current_time, &
+    CALL timelib_ClockGet( domain_clock, CurrTime=current_time, &
                         rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_ClockGet() ', &
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_ClockGet() ', &
                           __FILE__ , &
                           __LINE__  )
 
-    CALL ESMF_TimeGet( current_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeGet() ', &
+    CALL timelib_TimeGet( current_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeGet() ', &
                           __FILE__ , &
                           __LINE__  )
     CALL fraction_to_string( Sn, Sd, frac_str )
     str = TRIM(str)//TRIM(frac_str)
     WRITE(*,FMT='(A,A,A,A)') TRIM(itestfullname),':  clock current_time = <',TRIM(str),'>'
 
-    CALL ESMF_TimeGet( current_time, dayOfYear_r8=dayr8, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeGet() ', &
+    CALL timelib_TimeGet( current_time, dayOfYear_r8=dayr8, rc=rc )
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeGet() ', &
                           __FILE__ , &
                           __LINE__  )
     WRITE(*,FMT='(A,A,F10.6,A)') TRIM(itestfullname),':  current_time dayOfYear_r8 = < ',dayr8,' >'
 
     subtract_time = current_time - increment
-    CALL ESMF_TimeGet( subtract_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeGet() ', &
+    CALL timelib_TimeGet( subtract_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeGet() ', &
                           __FILE__ , &
                           __LINE__  )
     CALL fraction_to_string( Sn, Sd, frac_str )
@@ -1003,9 +1003,9 @@
     WRITE(*,FMT='(A,A,A,A)') TRIM(itestfullname),':  current_time-increment = <',TRIM(str),'>'
 
     add_time = current_time + increment
-    CALL ESMF_TimeGet( add_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
-    CALL test_check_error( ESMF_SUCCESS, rc, &
-                          TRIM(itestfullname)//'ESMF_TimeGet() ', &
+    CALL timelib_TimeGet( add_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
+    CALL test_check_error( timelib_SUCCESS, rc, &
+                          TRIM(itestfullname)//'timelib_TimeGet() ', &
                           __FILE__ , &
                           __LINE__  )
     CALL fraction_to_string( Sn, Sd, frac_str )
@@ -1015,29 +1015,29 @@
     ! Advance clock.  
     itestfullname = TRIM(itestname)//'ADVANCE'
     itimestep = 0
-    DO WHILE ( .NOT. ESMF_ClockIsStopTime(domain_clock ,rc=rc) )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestfullname)//'ESMF_ClockIsStopTime() ', &
+    DO WHILE ( .NOT. timelib_ClockIsStopTime(domain_clock ,rc=rc) )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestfullname)//'timelib_ClockIsStopTime() ', &
                             __FILE__ , &
                             __LINE__  )
       itimestep = itimestep + 1
 
-      CALL ESMF_ClockAdvance( domain_clock, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestfullname)//'ESMF_ClockAdvance() ', &
+      CALL timelib_ClockAdvance( domain_clock, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestfullname)//'timelib_ClockAdvance() ', &
                             __FILE__ , &
                             __LINE__  )
 
-      CALL ESMF_ClockGet( domain_clock, CurrTime=current_time, &
+      CALL timelib_ClockGet( domain_clock, CurrTime=current_time, &
                           rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestfullname)//'ESMF_ClockGet() ', &
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestfullname)//'timelib_ClockGet() ', &
                             __FILE__ , &
                             __LINE__  )
 
-      CALL ESMF_TimeGet( current_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestfullname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeGet( current_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestfullname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       CALL fraction_to_string( Sn, Sd, frac_str )
@@ -1046,9 +1046,9 @@
         itimestep,'  current_time = <',TRIM(str),'>'
 
       subtract_time = current_time - increment
-      CALL ESMF_TimeGet( subtract_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestfullname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeGet( subtract_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestfullname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       CALL fraction_to_string( Sn, Sd, frac_str )
@@ -1056,9 +1056,9 @@
       WRITE(*,FMT='(A,A,A,A)') TRIM(itestfullname),':  current_time-increment = <',TRIM(str),'>'
 
       add_time = current_time + increment
-      CALL ESMF_TimeGet( add_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
-      CALL test_check_error( ESMF_SUCCESS, rc, &
-                            TRIM(itestfullname)//'ESMF_TimeGet() ', &
+      CALL timelib_TimeGet( add_time, timeString=str, Sn=Sn, Sd=Sd, rc=rc )
+      CALL test_check_error( timelib_SUCCESS, rc, &
+                            TRIM(itestfullname)//'timelib_TimeGet() ', &
                             __FILE__ , &
                             __LINE__  )
       CALL fraction_to_string( Sn, Sd, frac_str )
@@ -1171,19 +1171,19 @@
 
 
 PROGRAM time_manager_test
-  USE ESMF_Mod
+  USE timelib_Mod
   USE my_tests
   IMPLICIT NONE
   INTEGER :: rc
 
   PRINT *,'BEGIN TEST SUITE'
 
-  CALL ESMF_Initialize( defaultCalendar=ESMF_CAL_GREGORIAN, rc=rc )
-  CALL test_check_error( ESMF_SUCCESS, rc, &
-                        'ESMF_Initialize() ', &
+  CALL timelib_Initialize( defaultCalendar=timelib_CAL_GREGORIAN, rc=rc )
+  CALL test_check_error( timelib_SUCCESS, rc, &
+                        'timelib_Initialize() ', &
                         __FILE__ , &
                         __LINE__  )
-!  PRINT *,'DEBUG:  back from ESMF_Initialize(), rc = ',rc
+!  PRINT *,'DEBUG:  back from timelib_Initialize(), rc = ',rc
 
 !  CALL test_print(  t_yy,  t_mm,  t_dd,  t_h,  t_m,  t_s, &
 !                   ti_yy, ti_mm, ti_dd, ti_h, ti_m, ti_s, &
@@ -1280,7 +1280,7 @@
 !    res_str='02002-005-500_002:001:010', testname='printTI_NN3', expect_error=.TRUE. )
 
   ! Addition tests
-  ! ESMF_Time = ESMF_Time + ESMF_TimeInterval
+  ! timelib_Time = timelib_Time + timelib_TimeInterval
   CALL test_arithmetic( add_op=.TRUE.,                                             &
      op1_t_yy=2001,  op1_t_mm=12,  op1_t_dd=3,  op1_t_h=1,  op1_t_m=20,  op1_t_s=10, &
     op2_ti_yy=   0, op2_ti_mm= 0, op2_ti_dd=0, op2_ti_h=3, op2_ti_m=10, op2_ti_s=10, &
@@ -1359,7 +1359,7 @@
     op2_ti_yy=   0, op2_ti_mm= 0, op2_ti_dd=366, op2_ti_h=22, op2_ti_m=10, op2_ti_s=10, &
      res_t_yy=2005,  res_t_mm=04,  res_t_dd=01,  res_t_h=2,  res_t_m=40,  res_t_s=10, &
     testname='AddT_T_TI15' )
-  ! ESMF_Time = ESMF_Time + ESMF_TimeInterval with fractions
+  ! timelib_Time = timelib_Time + timelib_TimeInterval with fractions
   CALL test_arithmetic( add_op=.TRUE.,                                             &
      op1_t_yy=2004,  op1_t_mm=12,  op1_t_dd=31,  op1_t_h=22,  op1_t_m=30,  op1_t_s=00, &
      op1_t_sn=01,  op1_t_sd=03, &
@@ -1377,7 +1377,7 @@
 !     res_t_yy=2005,  res_t_mm= 1,  res_t_dd=1,  res_t_h=2,  res_t_m=40,  res_t_s=10, &
 !     res_t_sn=01,  res_t_sd=03, &
 !    testname='AddT_T_TI_F2' )
-  ! ESMF_Time = ESMF_TimeInterval + ESMF_Time
+  ! timelib_Time = timelib_TimeInterval + timelib_Time
   CALL test_arithmetic( add_op=.TRUE.,                                             &
     op1_ti_yy=   0, op1_ti_mm= 0, op1_ti_dd=0, op1_ti_h=3, op1_ti_m=10, op1_ti_s=10, &
      op2_t_yy=2001,  op2_t_mm=12,  op2_t_dd=3,  op2_t_h=1,  op2_t_m=20,  op2_t_s=10, &
@@ -1388,7 +1388,7 @@
      op2_t_yy=2001,  op2_t_mm=12,  op2_t_dd=31,  op2_t_h=22,  op2_t_m=30,  op2_t_s=00, &
      res_t_yy=2002,  res_t_mm= 1,  res_t_dd=1,  res_t_h=2,  res_t_m=40,  res_t_s=10, &
     testname='AddT_TI_T2' )
-  ! ESMF_TimeInterval = ESMF_TimeInterval + ESMF_TimeInterval
+  ! timelib_TimeInterval = timelib_TimeInterval + timelib_TimeInterval
   CALL test_arithmetic( add_op=.TRUE.,                                             &
     op1_ti_yy=0000, op1_ti_mm=00, op1_ti_dd=3, op1_ti_h=1, op1_ti_m=20, op1_ti_s=10, &
     op2_ti_yy=0000, op2_ti_mm=00, op2_ti_dd=1, op2_ti_h=1, op2_ti_m=10, op2_ti_s=10, &
@@ -1406,7 +1406,7 @@
     testname='AddTI_TI_TI3' )
 
   ! Subtraction tests
-  ! ESMF_Time = ESMF_Time - ESMF_TimeInterval
+  ! timelib_Time = timelib_Time - timelib_TimeInterval
   CALL test_arithmetic( add_op=.FALSE.,                                            &
      op1_t_yy=2001,  op1_t_mm=12,  op1_t_dd=3,  op1_t_h=1,  op1_t_m=20,  op1_t_s=10, &
     op2_ti_yy=   0, op2_ti_mm= 0, op2_ti_dd=0, op2_ti_h=3, op2_ti_m=10, op2_ti_s=10, &
@@ -1437,7 +1437,7 @@
     op2_ti_yy=   0, op2_ti_mm= 0, op2_ti_dd=367, op2_ti_h=4, op2_ti_m=10, op2_ti_s=10, &
      res_t_yy=2004,  res_t_mm=12,  res_t_dd=30,  res_t_h=4,  res_t_m=30,  res_t_s=00, &
     testname='SubtractT_T_TI6' )
-  ! ESMF_Time = ESMF_Time - ESMF_TimeInterval with fractions
+  ! timelib_Time = timelib_Time - timelib_TimeInterval with fractions
   CALL test_arithmetic( add_op=.FALSE.,                                             &
      op1_t_yy=2005,  op1_t_mm=01,  op1_t_dd=01,  op1_t_h=00,  op1_t_m=00,  op1_t_s=00, &
      op1_t_sn=00,  op1_t_sd=00, &
@@ -1446,7 +1446,7 @@
      res_t_yy=2004,  res_t_mm=12,  res_t_dd=31,  res_t_h=23,  res_t_m=59,  res_t_s=58, &
      res_t_sn=02,  res_t_sd=03, &
     testname='SubtractT_T_TI_F1' )
-  ! ESMF_TimeInterval = ESMF_Time - ESMF_Time
+  ! timelib_TimeInterval = timelib_Time - timelib_Time
   CALL test_arithmetic( add_op=.FALSE.,                                            &
      op1_t_yy=2001,  op1_t_mm=12,  op1_t_dd=3,  op1_t_h=1,  op1_t_m=20,  op1_t_s=10, &
      op2_t_yy=2001,  op2_t_mm=12,  op2_t_dd=1,  op2_t_h=1,  op2_t_m=10,  op2_t_s=10, &
@@ -1517,7 +1517,7 @@
      op2_t_yy=-2002,  op2_t_mm=02,  op2_t_dd=28, op2_t_h=00, op2_t_m=00,  op2_t_s=00, &
     res_ti_yy=0000, res_ti_mm=00, res_ti_dd=0, res_ti_h=0, res_ti_m=00, res_ti_s=00, &
     testname='SubtractTI_T_T14' )
-  ! ESMF_TimeInterval = ESMF_TimeInterval - ESMF_TimeInterval
+  ! timelib_TimeInterval = timelib_TimeInterval - timelib_TimeInterval
   CALL test_arithmetic( add_op=.FALSE.,                                            &
     op1_ti_yy=0000, op1_ti_mm=00, op1_ti_dd=3, op1_ti_h=1, op1_ti_m=20, op1_ti_s=10, &
     op2_ti_yy=0000, op2_ti_mm=00, op2_ti_dd=1, op2_ti_h=1, op2_ti_m=10, op2_ti_s=10, &
@@ -1533,7 +1533,7 @@
     op2_ti_yy=0000, op2_ti_mm=00, op2_ti_dd=-3, op2_ti_h=-1, op2_ti_m=-20, op2_ti_s=-10, &
     res_ti_yy=0000, res_ti_mm=00, res_ti_dd=2, res_ti_h=0, res_ti_m=10, res_ti_s=00,  &
     testname='SubtractTI_TI_TI3' )
-  ! Negative result ESMF_TimeInterval = ESMF_TimeInterval - ESMF_TimeInterval
+  ! Negative result timelib_TimeInterval = timelib_TimeInterval - timelib_TimeInterval
   CALL test_arithmetic( add_op=.FALSE.,                                            &
     op1_ti_yy=0000, op1_ti_mm=00, op1_ti_dd=1, op1_ti_h=1, op1_ti_m=10, op1_ti_s=10, &
     op2_ti_yy=0000, op2_ti_mm=00, op2_ti_dd=3, op2_ti_h=1, op2_ti_m=20, op2_ti_s=10, &
@@ -1545,7 +1545,7 @@
     res_ti_yy=0000, res_ti_mm=00, res_ti_dd=-4, res_ti_h=-2, res_ti_m=-30, res_ti_s=-20,  &
     testname='SubtractTI_TI_TIN2' )
 
-  ! Un-normalized ESMF_TimeInterval = ESMF_TimeInterval - ESMF_TimeInterval
+  ! Un-normalized timelib_TimeInterval = timelib_TimeInterval - timelib_TimeInterval
   ! this is an error
 !  CALL test_arithmetic( add_op=.FALSE.,                                            &
 !    op1_ti_yy=2001, op1_ti_mm=11, op1_ti_dd=3, op1_ti_h=1, op1_ti_m=20, op1_ti_s=10, &
@@ -1561,7 +1561,7 @@
 !    testname='AddTT1' )
 
   ! Multiplication tests
-  ! ESMF_TimeInterval = ESMF_TimeInterval * INTEGER
+  ! timelib_TimeInterval = timelib_TimeInterval * INTEGER
   CALL test_arithmetic( multiply_op=.TRUE.,                &
     op1_ti_dd=3,  op1_ti_h=12,  op1_ti_m=18,  op1_ti_s=33, &
     op2_int=2,                                             &
@@ -1579,7 +1579,7 @@
     testname='MultiplyTI_TI_INT3' )
 
   ! Division tests
-  ! ESMF_TimeInterval = ESMF_TimeInterval / INTEGER
+  ! timelib_TimeInterval = timelib_TimeInterval / INTEGER
   CALL test_arithmetic( multiply_op=.FALSE.,               &
     op1_ti_dd=3,  op1_ti_h=12,  op1_ti_m=18,  op1_ti_s=33, &
     op2_int=3,                                             &
@@ -1596,7 +1596,7 @@
     op2_int=5,                                             &
     res_ti_s=0, res_ti_sn=7,  res_ti_sd=20,                &
     testname='DivideTI_TI_INT3' )
-  ! INTEGER = ESMF_TimeInterval / ESMF_TimeInterval
+  ! INTEGER = timelib_TimeInterval / timelib_TimeInterval
   ! this operator truncates to whole integers
   CALL test_arithmetic( multiply_op=.FALSE.,               &
     op1_ti_dd=3,  op1_ti_h=12,  op1_ti_m=18,  op1_ti_s=33, &
@@ -1706,9 +1706,9 @@
     testname="LeapYearFractionClockAdvance",                                  &
     increment_S=1, increment_Sn=1, increment_Sd=3 )
 
-  CALL ESMF_Finalize( rc=rc )
-  CALL test_check_error( ESMF_SUCCESS, rc, &
-                        'ESMF_Finalize() ', &
+  CALL timelib_Finalize( rc=rc )
+  CALL test_check_error( timelib_SUCCESS, rc, &
+                        'timelib_Finalize() ', &
                         __FILE__ , &
                         __LINE__  )
 
diff -Naur WRFV3.9/external/esmf_time_f90/timelib_Macros.inc WRFV3.9.patch/external/esmf_time_f90/timelib_Macros.inc
--- WRFV3.9/external/esmf_time_f90/timelib_Macros.inc	1969-12-31 19:00:00.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/timelib_Macros.inc	2017-07-03 16:17:29.688689000 -0400
@@ -0,0 +1,35 @@
+#if 0
+
+Earth System Modeling Framework
+Copyright 2002-2003, University Corporation for Atmospheric Research,
+Massachusetts Institute of Technology, Geophysical Fluid Dynamics
+Laboratory, University of Michigan, National Centers for Environmental
+Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
+NASA Goddard Space Flight Center.
+Licensed under the University of Illinois-NCSA license.
+
+Do not have C++ or F90 style comments in here because this file is processed
+by both C++ and F90 compilers.
+
+These lines prevent this file from being read more than once if it
+ends up being included multiple times.
+#endif
+
+#ifndef timelib_MACROS_INC
+#define timelib_MACROS_INC
+
+#if 0
+
+former file contents moved to timelib_BaseMod
+so user code can be compiled without requiring
+the preprocessor.
+
+#endif 
+
+#if 0
+i left the following macro here in case it is needed for our internal use.
+#endif
+
+#define timelib_SRCLINE __FILE__, __LINE__
+
+#endif 
diff -Naur WRFV3.9/external/esmf_time_f90/timelib_TimeMgr.inc WRFV3.9.patch/external/esmf_time_f90/timelib_TimeMgr.inc
--- WRFV3.9/external/esmf_time_f90/timelib_TimeMgr.inc	1969-12-31 19:00:00.000000000 -0500
+++ WRFV3.9.patch/external/esmf_time_f90/timelib_TimeMgr.inc	2017-07-03 16:17:29.689086000 -0400
@@ -0,0 +1,60 @@
+#if 0
+ 
+Earth System Modeling Framework
+Copyright 2002-2003, University Corporation for Atmospheric Research,
+Massachusetts Institute of Technology, Geophysical Fluid Dynamics
+Laboratory, University of Michigan, National Centers for Environmental
+Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
+NASA Goddard Space Flight Center.
+Licensed under the University of Illinois-NCSA license.
+
+Do not have C++ or F90 style comments in here because this file is processed
+by both C++ and F90 compilers.
+#endif
+
+#ifndef timelib_TimeMgr_INC
+#define timelib_TimeMgr_INC
+
+#if 0
+!BOP
+-------------------------------------------------------------------------
+
+ !DESCRIPTION:
+
+ timelib TimeMgr include file for F90
+ The code in this file implements constants and macros for the TimeMgr...
+
+-------------------------------------------------------------------------
+!EOP
+#endif
+
+#include "timelib_Macros.inc"
+
+#define SECONDS_PER_DAY 86400_timelib_KIND_I8
+#define SECONDS_PER_HOUR 3600_timelib_KIND_I8
+#define SECONDS_PER_MINUTE 60_timelib_KIND_I8
+#define HOURS_PER_DAY 24_timelib_KIND_I8
+
+! Note that MAX_ALARMS must match MAX_WRF_ALARMS defined in 
+! ../../frame/module_domain.F !!!  Eliminate this dependence with 
+! grow-as-you-go AlarmList in timelib_Clock...  
+#define MAX_ALARMS (2*(MAX_HISTORY)+10)
+
+! TBH:  TODO:  Hook this into the WRF build so WRF can use either "no-leap" or 
+! TBH:         Gregorian calendar.  Now WRF is hard-wired to use Gregorian.  
+!#undef NO_LEAP_CALENDAR
+!#ifdef COUP_CSM
+!#define NO_LEAP_CALENDAR
+!#endif
+
+! TBH:  When NO_DT_COMPONENT_INIT is set, code that uses F95 compile-time 
+! TBH:  initialization of components of derived types is not included.  
+! TBH:  Some older compilers like PGI 5.x do not support this F95 
+! TBH:  feature.
+!#ifdef NO_LEAP_CALENDAR
+!#undef NO_DT_COMPONENT_INIT
+!#else
+!#define NO_DT_COMPONENT_INIT
+!#endif
+
+#endif
diff -Naur WRFV3.9/frame/module_domain.F WRFV3.9.patch/frame/module_domain.F
--- WRFV3.9/frame/module_domain.F	2017-03-07 16:38:50.000000000 -0500
+++ WRFV3.9.patch/frame/module_domain.F	2017-07-03 16:17:29.961254132 -0400
@@ -2044,17 +2044,13 @@
         is_stop_subtime = .FALSE.
         CALL domain_clock_get( grid, time_step=timeStep, &
                                      current_time=currentTime )
-        positive_timestep = ESMF_TimeIntervalIsPositive( timeStep )
+        positive_timestep = timelib_TimeIntervalIsPositive( timeStep )
         IF ( positive_timestep ) THEN
-! hack for bug in PGI 5.1-x
-!        IF ( currentTime .GE. grid%stop_subtime ) THEN
-          IF ( ESMF_TimeGE( currentTime, grid%stop_subtime ) ) THEN
+         IF ( currentTime .GE. grid%stop_subtime ) THEN
             is_stop_subtime = .TRUE.
           ENDIF
         ELSE
-! hack for bug in PGI 5.1-x
-!        IF ( currentTime .LE. grid%stop_subtime ) THEN
-          IF ( ESMF_TimeLE( currentTime, grid%stop_subtime ) ) THEN
+         IF ( currentTime .LE. grid%stop_subtime ) THEN
             is_stop_subtime = .TRUE.
           ENDIF
         ENDIF
diff -Naur WRFV3.9/phys/module_bl_ysu.F WRFV3.9.patch/phys/module_bl_ysu.F
--- WRFV3.9/phys/module_bl_ysu.F	2017-02-16 19:55:23.000000000 -0500
+++ WRFV3.9.patch/phys/module_bl_ysu.F	2017-07-03 16:17:29.997445000 -0400
@@ -7,6 +7,10 @@
 !
 !
 module module_bl_ysu
+
+logical :: ESMF_CouplerStarted      = .false. ! uwin
+integer :: UMCM_VectorStressLimiter = 0       ! uwin
+
 contains
 !
 !
@@ -31,6 +35,7 @@
                   ims,ime, jms,jme, kms,kme,                                   &
                   its,ite, jts,jte, kts,kte,                                   &
                 !optional
+                  taux_esmf,tauy_esmf,& ! uwin
                   regime                                           )
 !-------------------------------------------------------------------------------
    implicit none
@@ -105,6 +110,8 @@
 !-- jte         end index for j in tile
 !-- kts         start index for k in tile
 !-- kte         end index for k in tile
+!-- taux_esmf   wind stress x-component (N/m^2), optional ! uwin
+!-- tauy_esmf   wind stress y-component (N/m^2), optional ! uwin
 !-------------------------------------------------------------------------------
 !
    integer,parameter ::  ndiff = 3
@@ -199,6 +206,8 @@
              optional                                                        , &
              intent(in   )   ::                                         ctopo, &
                                                                        ctopo2
+   real,dimension(ims:ime,jms:jme),optional,intent(inout) :: taux_esmf,tauy_esmf ! uwin
+
 !local
    integer ::  i,j,k
    real,     dimension( its:ite, kts:kte*ndiff )  ::                 rqvbl2dt, &
@@ -257,7 +266,8 @@
               ,ctopo=ctopo(ims,j),ctopo2=ctopo2(ims,j)                         &
               ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kds,kde=kde               &
               ,ims=ims,ime=ime, jms=jms,jme=jme, kms=kms,kme=kme               &
-              ,its=its,ite=ite, jts=jts,jte=jte, kts=kts,kte=kte   )
+              ,its=its,ite=ite, jts=jts,jte=jte, kts=kts,kte=kte               &
+              ,taux_esmf=taux_esmf(ims,j),tauy_esmf=tauy_esmf(ims,j)) ! uwin
 !
      do k = kts,kte
        do i = its,ite
@@ -293,6 +303,7 @@
                   ims,ime, jms,jme, kms,kme,                                   &
                   its,ite, jts,jte, kts,kte,                                   &
                 !optional
+                  taux_esmf,tauy_esmf,                                         & ! uwin
                   regime )
 !-------------------------------------------------------------------------------
    implicit none
@@ -432,6 +443,8 @@
    real,     dimension( ims:ime )                                            , &
              optional                                                        , &
              intent(inout)   ::                                        regime
+
+   real,dimension(ims:ime),optional,intent(inout) :: taux_esmf,tauy_esmf ! uwin
 !
 ! local vars
 !
@@ -508,6 +521,7 @@
    real    ::  utend,vtend,ttend,qtend
    real    ::  dtstep,govrthv
    real    ::  cont, conq, conw, conwrc
+   real    ::  min_cd,min_tau,tau_util,tau_mag,tau_dir ! uwin
 !
 
    real, dimension( its:ite, kts:kte )     ::                wscalek,wscalek2
@@ -1300,6 +1314,17 @@
 ! paj: ctopo=1 if topo_wind=0 (default)
 !raquel---paj tke code (could be replaced with shin-hong tke in future
    do i = its,ite
+
+     tau_mag = sqrt(taux_esmf(i)**2+tauy_esmf(i)**2) ! uwin
+
+     if(tau_mag > 0 .and. xland(i) > 1.5 &           ! uwin
+                    .and. ESMF_CouplerStarted)then   ! uwin
+       ad(i,1) = 1.                                  ! uwin
+       tau_util = g/del(i,1)*dt2                     ! uwin
+       f1(i,1) = ux(i,1)-taux_esmf(i)*tau_util       ! uwin
+       f2(i,1) = vx(i,1)-tauy_esmf(i)*tau_util       ! uwin
+     else       
+
       do k= kts, kte-1
         shear_ysu(i,k)=xkzm(i,k)*((-hgamu(i)/hpbl(i)+(ux(i,k+1)-ux(i,k))/dza(i,k+1))*(ux(i,k+1)-ux(i,k))/dza(i,k+1) &
         + (-hgamv(i)/hpbl(i)+(vx(i,k+1)-vx(i,k))/dza(i,k+1))*(vx(i,k+1)-vx(i,k))/dza(i,k+1))
@@ -1353,6 +1378,9 @@
       endif
      f1(i,1) = ux(i,1)+uox(i)*ust(i)**2*rhox(i)*g/del(i,1)*dt2/wspd1(i)*(wspd1(i)/wspd(i))**2
      f2(i,1) = vx(i,1)+vox(i)*ust(i)**2*rhox(i)*g/del(i,1)*dt2/wspd1(i)*(wspd1(i)/wspd(i))**2
+
+     endif ! uwin
+
    enddo
 !
    do k = kts,kte-1
diff -Naur WRFV3.9/phys/module_cu_kfeta.F WRFV3.9.patch/phys/module_cu_kfeta.F
--- WRFV3.9/phys/module_cu_kfeta.F	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/phys/module_cu_kfeta.F	2017-07-03 16:17:30.015597000 -0400
@@ -739,7 +739,8 @@
 !...INTO GRID-RESOLVED RAINWATER (OR SNOW/GRAUPEL)     ! PPT FB MODS
 !...FIELD.  "FBFRC" IS THE FRACTION OF AVAILABLE       ! PPT FB MODS
 !...PRECIPITATION TO BE FED BACK (0.0 - 1.0)...        ! PPT FB MODS
-      FBFRC=0.0                                        ! PPT FB MODS
+!     FBFRC=0.0                                        ! PPT FB MODS
+      FBFRC=0.3                                        ! PPT FB MODS
 !...mods to allow shallow convection...
       NCHM = 0
       ISHALL = 0
diff -Naur WRFV3.9/phys/module_pbl_driver.F WRFV3.9.patch/phys/module_pbl_driver.F
--- WRFV3.9/phys/module_pbl_driver.F	2017-02-16 19:54:53.000000000 -0500
+++ WRFV3.9.patch/phys/module_pbl_driver.F	2017-07-03 16:17:30.071648000 -0400
@@ -69,6 +69,7 @@
                  ,ims,ime, jms,jme, kms,kme                        &
                  ,i_start,i_end, j_start,j_end, kts,kte, num_tiles &
              ! Optional
+                 ,taux_esmf,tauy_esmf                              & ! uwin
                  ,hol, mol, regime                                 &
              ! Optional gravity-wave drag             
                  ,gwd_opt                                          &
@@ -337,6 +338,8 @@
 !-- wsedl3d     Sedimentation velocity of stratiform liquid cloud droplet (m/s)
 !-- turbtype3d  Turbulent interface types [ no unit ]  
 !-- smaw3d      Normalized Galperin instability function for momentum  ( 0<= <=4.964 and 1 at neutral ) [no units]
+!-- taux_esmf     wind stress x-component (N/m^2), optional ! uwin
+!-- tauy_esmf     wind stress y-component (N/m^2), optional ! uwin
 !
 !-- P_QV          species index for water vapor
 !-- P_QC          species index for cloud water
@@ -438,6 +441,9 @@
                                                                z, &
                                                           th_phy
 
+   REAL,DIMENSION(ims:ime,jms:jme),OPTIONAL,INTENT(INOUT) :: taux_esmf ! uwin
+   REAL,DIMENSION(ims:ime,jms:jme),OPTIONAL,INTENT(INOUT) :: tauy_esmf ! uwin
+
 !1D variables required for CAMUWPBL scheme
    REAL , DIMENSION( kms:kme ) ,                                      &
         INTENT(IN   ) , OPTIONAL ::                                        fnm,  & !Factors for interpolation at "w" grid (interfaces)
@@ -1179,6 +1185,7 @@
               ,IDS=ids,IDE=ide,JDS=jds,JDE=jde,KDS=kds,KDE=kde      &
               ,IMS=ims,IME=ime,JMS=jms,JME=jme,KMS=kms,KME=kme      &
               ,ITS=its,ITE=ite,JTS=jts,JTE=jte,KTS=kts,KTE=kte      &
+              ,TAUX_ESMF=taux_esmf,TAUY_ESMF=tauy_esmf              &! uwin
                                                                     )
 !
 ! FASDAS
diff -Naur WRFV3.9/phys/module_sf_sfclay.F WRFV3.9.patch/phys/module_sf_sfclay.F
--- WRFV3.9/phys/module_sf_sfclay.F	2017-03-08 14:18:28.000000000 -0500
+++ WRFV3.9.patch/phys/module_sf_sfclay.F	2017-07-03 16:17:30.087561000 -0400
@@ -8,12 +8,15 @@
 
  REAL,   DIMENSION(0:1000 ),SAVE          :: PSIMTB,PSIHTB
 
+ LOGICAL,SAVE :: ESMF_CouplerStarted = .FALSE. ! uwin
+
 CONTAINS
 
 !-------------------------------------------------------------------
    SUBROUTINE SFCLAY(U3D,V3D,T3D,QV3D,P3D,dz8w,                    &
                      CP,G,ROVCP,R,XLV,PSFC,CHS,CHS2,CQS2,CPM,      &
-                     ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
+!                    ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
+                     ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIM10,PSIH, & ! uwin
                      FM,FH,                                        &
                      XLAND,HFX,QFX,LH,TSK,FLHC,FLQC,QGH,QSFC,RMOL, &
                      U10,V10,TH2,T2,Q2,                            &
@@ -155,7 +158,8 @@
 !
       REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                 INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
-                                                  PSIM,PSIH,FM,FH
+!                                                 PSIM,PSIH,FM,FH
+                                                  PSIM,PSIM10,PSIH,FM,FH ! uwin
 
       REAL,     DIMENSION( ims:ime, kms:kme, jms:jme )           , &
                 INTENT(IN   )   ::                            U3D, &
@@ -223,7 +227,8 @@
                 CP,G,ROVCP,R,XLV,PSFC(ims,j),CHS(ims,j),CHS2(ims,j),&
                 CQS2(ims,j),CPM(ims,j),PBLH(ims,j), RMOL(ims,j),   &
                 ZNT(ims,j),UST(ims,j),MAVAIL(ims,j),ZOL(ims,j),    &
-                MOL(ims,j),REGIME(ims,j),PSIM(ims,j),PSIH(ims,j),  &
+!               MOL(ims,j),REGIME(ims,j),PSIM(ims,j),PSIH(ims,j),  &
+                MOL(ims,j),REGIME(ims,j),PSIM(ims,j),PSIM10(ims,j),PSIH(ims,j),  & ! uwin
                 FM(ims,j),FH(ims,j),                               &
                 XLAND(ims,j),HFX(ims,j),QFX(ims,j),TSK(ims,j),     &
                 U10(ims,j),V10(ims,j),TH2(ims,j),T2(ims,j),        &
@@ -250,7 +255,8 @@
 !-------------------------------------------------------------------
    SUBROUTINE SFCLAY1D(J,UX,VX,T1D,QV1D,P1D,dz8w1d,                &
                      CP,G,ROVCP,R,XLV,PSFCPA,CHS,CHS2,CQS2,CPM,PBLH,RMOL, &
-                     ZNT,UST,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH,FM,FH,&
+!                    ZNT,UST,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH,FM,FH,&
+                     ZNT,UST,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIM10_ESMF,PSIH,FM,FH,& ! uwin
                      XLAND,HFX,QFX,TSK,                            &
                      U10,V10,TH2,T2,Q2,FLHC,FLQC,QGH,              &
                      QSFC,LH,GZ1OZ0,WSPD,BR,ISFFLX,DX,             &
@@ -297,7 +303,8 @@
 !
       REAL,     DIMENSION( ims:ime )                             , &
                 INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
-                                                  PSIM,PSIH,FM,FH
+!                                                 PSIM,PSIH,FM,FH
+                                                  PSIM,PSIM10_ESMF,PSIH,FM,FH ! uwin
 
       REAL,     DIMENSION( ims:ime )                             , &
                 INTENT(INOUT)   ::                            ZNT, &
@@ -774,7 +781,13 @@
            ENDIF
         ENDIF
 ! TO PREVENT OSCILLATIONS AVERAGE WITH OLD VALUE 
-        UST(I)=0.5*UST(I)+0.5*KARMAN*WSPD(I)/PSIX                                             
+        IF(ESMF_CouplerStarted)THEN                     ! uwin
+          IF(XLAND(I) < 1.5)THEN                        ! uwin
+            UST(I) = 0.5*UST(I)+0.5*KARMAN*WSPD(I)/PSIX ! uwin
+          ENDIF                                         ! uwin
+        ELSE                                            ! uwin
+          UST(I) = 0.5*UST(I)+0.5*KARMAN*WSPD(I)/PSIX
+        ENDIF                                           ! uwin
 ! TKE coupling: compute ust without vconv for use in tke scheme
         WSPDI(I)=SQRT(UX(I)*UX(I)+VX(I)*VX(I))
         IF ( PRESENT(USTM) ) THEN
@@ -801,6 +814,7 @@
         DENOMT2(I)=PSIT2
         FM(I)=PSIX
         FH(I)=PSIT
+        PSIM10_ESMF(I)=PSIM10(I) ! uwin
   330 CONTINUE                                                                   
 !                                                                                
   335 CONTINUE                                                                   
diff -Naur WRFV3.9/phys/module_surface_driver.F WRFV3.9.patch/phys/module_surface_driver.F
--- WRFV3.9/phys/module_surface_driver.F	2017-04-07 18:20:07.000000000 -0400
+++ WRFV3.9.patch/phys/module_surface_driver.F	2017-07-03 16:17:30.091314079 -0400
@@ -23,7 +23,8 @@
      &          ,pert_Cd, ens_random_seed, ens_Cdamp                  &
      &          ,cd_out,ch_out                                        &
 #else
-     &          ,psim,p_phy,q10,q2,qfx,qsfc,qshltr,qz0                &
+!    &          ,psim,p_phy,q10,q2,qfx,qsfc,qshltr,qz0                &
+     &          ,psim,psim10,p_phy,q10,q2,qfx,qsfc,qshltr,qz0         & ! uwin
 #endif
      &          ,raincv,rho,sfcevp,sfcexc,sfcrunoff ,acrunoff         &
      &          ,smois,smstav,smstot,snoalb,snow,snowc,snowh,stepbl   &
@@ -782,6 +783,7 @@
    REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)::   FM
    REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)::   PSIH
    REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)::   PSIM
+   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)::   PSIM10 ! uwin
    REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)::   Q10
    REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)::   QSHLTR
    REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)::   TH10
@@ -1859,7 +1861,8 @@
          IF ( FRACTIONAL_SEAICE == 1 ) THEN
             CALL SFCLAY_SEAICE_WRAPPER(u_phytmp,v_phytmp,t_phy,qv_curr,&
                  p_phy,dz8w,cp,g,rcp,r_d,xlv,psfc,chs,chs2,cqs2,cpm, &
-                 znt,ust,pblh,mavail,zol,mol,regime,psim,psih,fm,fhh, &
+!                znt,ust,pblh,mavail,zol,mol,regime,psim,psih,fm,fhh, &
+                 znt,ust,pblh,mavail,zol,mol,regime,psim,psim10,psih,fm,fhh, & ! uwin
                  xland,hfx,qfx,lh,tsk,flhc,flqc,qgh,qsfc,rmol,       &
                  u10,v10,th2,t2,q2,                                  &
                  gz1oz0,wspd,br,isfflx,dx,                           &
@@ -1877,7 +1880,8 @@
          ELSE
          CALL SFCLAY(u_phytmp,v_phytmp,t_phy,qv_curr,              &
                p_phy,dz8w,cp,g,rcp,r_d,xlv,psfc,chs,chs2,cqs2,cpm, &
-               znt,ust,pblh,mavail,zol,mol,regime,psim,psih,fm,fhh, &
+!              znt,ust,pblh,mavail,zol,mol,regime,psim,psih,fm,fhh, &
+               znt,ust,pblh,mavail,zol,mol,regime,psim,psim10,psih,fm,fhh, & ! uwin
                xland,hfx,qfx,lh,tsk,flhc,flqc,qgh,qsfc,rmol,       &
                u10,v10,th2,t2,q2,                                  &
                gz1oz0,wspd,br,isfflx,dx,                           &
@@ -5834,7 +5838,8 @@
 
    SUBROUTINE sfclay_seaice_wrapper(U3D,V3D,T3D,QV3D,P3D,dz8w,     &
                      CP,G,ROVCP,R,XLV,PSFC,CHS,CHS2,CQS2,CPM,      &
-                     ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
+!                    ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
+                     ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIM10,PSIH, & ! uwin
                      FM,FH,                                        &
                      XLAND,HFX,QFX,LH,TSK,FLHC,FLQC,QGH,QSFC,RMOL, &
                      U10,V10,TH2,T2,Q2,                            &
@@ -5893,7 +5898,8 @@
 
      REAL,     DIMENSION( ims:ime, jms:jme )                    , &
                INTENT(INOUT)   ::                 GZ1OZ0,WSPD,BR, &
-                                                 PSIM,PSIH,FM,FH
+!                                                PSIM,PSIH,FM,FH
+                                                 PSIM,PSIM10,PSIH,FM,FH ! uwin
 
      REAL,     DIMENSION( ims:ime, kms:kme, jms:jme )           , &
                INTENT(IN   )   ::                            U3D, &
@@ -5972,6 +5978,7 @@
                                                 MOL_HOLD,         &
                                                 PSIH_HOLD,        &
                                                 PSIM_HOLD,        &
+                                                PSIM10_HOLD,      & ! uwin
                                                 FH_HOLD,          &
                                                 FM_HOLD,          &
                                                 QFX_HOLD,         &
@@ -6005,6 +6012,7 @@
                                                 MOL_SEA,          &
                                                 PSIH_SEA,         &
                                                 PSIM_SEA,         &
+                                                PSIM10_SEA,       & ! uwin
                                                 FH_SEA,           &
                                                 FM_SEA,           &
                                                 REGIME_SEA,       &
@@ -6054,6 +6062,7 @@
      MOL_HOLD  = MOL
      PSIH_HOLD = PSIH
      PSIM_HOLD = PSIM
+     PSIM10_HOLD = PSIM10 ! uwin
      FH_HOLD   = FH
      FM_HOLD   = FM
      QFX_HOLD  = QFX
@@ -6090,7 +6099,8 @@
      ! land/frozen-water call
      call sfclay(U3D,V3D,T3D,QV3D,P3D,dz8w,                    & ! I
                  CP,G,ROVCP,R,XLV,PSFC,CHS,CHS2,CQS2,CPM,      & ! I,I,I,I,I,I,IO,IO,IO,IO,
-                 ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
+!                ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIH, &
+                 ZNT,UST,PBLH,MAVAIL,ZOL,MOL,REGIME,PSIM,PSIM10,PSIH, & ! uwin
                  FM,FH,                                        &
                  XLAND,HFX,QFX,LH,TSK_LOCAL,FLHC,FLQC,QGH,QSFC,RMOL, &
                  U10,V10,TH2,T2,Q2,                            &
@@ -6162,6 +6172,7 @@
      MOL_SEA  = MOL_HOLD
      PSIH_SEA = PSIH_HOLD
      PSIM_SEA = PSIM_HOLD
+     PSIM10_SEA = PSIM10_HOLD ! uwin
      FH_SEA   = FH_HOLD
      FM_SEA   = FM_HOLD
      QFX_SEA  = QFX_HOLD
@@ -6178,7 +6189,8 @@
                  CHS_SEA,CHS2_SEA,CQS2_SEA,CPM_SEA,            & ! I/O
                  ZNT_SEA,UST_SEA,                              & ! I/O
                  PBLH,MAVAIL_SEA,                              & ! I
-                 ZOL_SEA,MOL_SEA,REGIME_SEA,PSIM_SEA,PSIH_SEA, & ! I/O
+!                ZOL_SEA,MOL_SEA,REGIME_SEA,PSIM_SEA,PSIH_SEA, & ! I/O
+                 ZOL_SEA,MOL_SEA,REGIME_SEA,PSIM_SEA,PSIM10_SEA,PSIH_SEA, & ! I/O ! uwin
                  FM_SEA,FH_SEA,                                &
                  XLAND_SEA,                              & ! I
                  HFX_SEA,QFX_SEA,LH_SEA,                       & ! I/O
diff -Naur WRFV3.9/Registry/Registry.EM_COMMON WRFV3.9.patch/Registry/Registry.EM_COMMON
--- WRFV3.9/Registry/Registry.EM_COMMON	2017-04-07 21:31:45.000000000 -0400
+++ WRFV3.9.patch/Registry/Registry.EM_COMMON	2017-07-03 16:17:29.507422942 -0400
@@ -1169,7 +1169,14 @@
 i1      real    ht_loc         ij      misc         1         -     - 
 state   integer  shadowmask    ij      misc         1         -     - 
 state   integer min_ptchsz     -       misc         1         -     r
-
+state   real    UE_ESMF        ij      misc         1         -     ihdf=(interp_fcn)       "UE_ESMF"  "OCEAN SURFACE EULERIAN VELOCITY, X-COMPONENT" "m s-1"
+state   real    VE_ESMF        ij      misc         1         -     ihdf=(interp_fcn)       "VE_ESMF"  "OCEAN SURFACE EULERIAN VELOCITY, Y-COMPONENT" "m s-1"
+state   real    UST_ESMF       ij      misc         1         -     ihdf=(interp_fcn)       "UST_ESMF" "OCEAN SURFACE STOKES DRIFT, X-COMPONENT" "m s-1"
+state   real    VST_ESMF       ij      misc         1         -     ihdf=(interp_fcn)       "VST_ESMF" "OCEAN SURFACE STOKES DRIFT, Y-COMPONENT" "m s-1"
+state   real    WSPDREL        ij      misc         1         -     h         "WSPDREL"               "FIRST LEVEL WIND SPEED RELATIVE TO WATER SURFACE" "m s-1"
+state   real    PSIM_ESMF      ij      misc         1         -     h         "PSIM_ESMF"             "STABILITY FUNCTION FOR MOMENTUM"
+state   real    TAUX_ESMF      ij      misc         1         -     h         "TAUX_ESMF"             "WIND STRESS X-COMPONENT FROM UWIN-CM" "N/m^2"
+state   real    TAUY_ESMF      ij      misc         1         -     h         "TAUY_ESMF"             "WIND STRESS Y-COMPONENT FROM UWIN-CM" "N/m^2"
 state   real    TSK            ij      misc         1         -     i012rhd=(interp_mask_field:lu_index,iswater)u=(copy_fcnm)    "TSK"                   "SURFACE SKIN TEMPERATURE"                  "K"
 state   real    dfi_TSK        ij      misc         1         -     r                       "TSK_dfi"               "saved SURFACE SKIN TEMPERATURE"
 state   real    TSK_SAVE       ij      misc         1         -     r         "TSK_SAVE" "SURFACE SKIN TEMPERATURE, EXTRA COPY FOR SEA ICE TESTS in REAL"       "K"
