! $Id$
!
! Earth System Modeling Framework
! Copyright 2002-2016, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!==============================================================================
!
^define ESMF_FILENAME "ESMF_StateAPI.cppF90"
!
!     ESMF StateAPI module
module ESMF_StateAPIMod
!
!==============================================================================
!
! This file contains the State user API methods.
!
!------------------------------------------------------------------------------
! INCLUDES
!------------------------------------------------------------------------------
^include "ESMF.h"

!------------------------------------------------------------------------------
!BOPI
! !MODULE: ESMF_StateMod - Data exchange between components
!
! !DESCRIPTION:
!
! The code in this file implements the Fortran function and subroutine 
!  interfaces to the {\tt State} class and associated data structures.
!
!
! !USES:
      use ESMF_UtilTypesMod
      use ESMF_LogErrMod
      use ESMF_BaseMod
      use ESMF_ContainerMod
      use ESMF_VMMod
      use ESMF_ArrayMod
      use ESMF_ArrayGetMod
      use ESMF_ArrayBundleMod
      use ESMF_FieldMod
      use ESMF_FieldGetMod
      use ESMF_FieldCreateMod
      use ESMF_FieldBundleMod
      use ESMF_RHandleMod
      use ESMF_StateTypesMod
      use ESMF_StateContainerMod
      use ESMF_StateVaMod
      use ESMF_StateInternalsMod
      use ESMF_StateWrMod
      use ESMF_InitMacrosMod
      use ESMF_IO_NetCDFMod
      use ESMF_IOUtilMod
      use ESMF_UtilMod
      
      implicit none
      
!------------------------------------------------------------------------------
! !PRIVATE TYPES:
      private
      
!------------------------------------------------------------------------------
! !PUBLIC TYPES:
      public ESMF_State               ! implemented in ESMF_StateTypesMod

!------------------------------------------------------------------------------

! !PUBLIC MEMBER FUNCTIONS:

      public operator(==)
      public operator(/=)

      public ESMF_StateCreate, ESMF_StateDestroy
      
      public ESMF_StateDestruct    ! for ESMF garbage collection

      public ESMF_StateAdd, ESMF_StateAddReplace
      public ESMF_StateGet
      public ESMF_StateIsCreated
      public ESMF_StateIsReconcileNeeded

      public ESMF_StateWriteRestart
      public ESMF_StateReadRestart

      public ESMF_StateRead
      public ESMF_StateWrite
      public ESMF_StatePrint

      public ESMF_StateSerialize, ESMF_StateDeserialize

      public ESMF_StateClassFindData
      
!EOPI

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
      character(*), parameter, private :: version = &
      '$Id$'

!==============================================================================
! 
! INTERFACE BLOCKS
!
!==============================================================================

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_StateAdd -- Add items to a State

! !INTERFACE:
  interface ESMF_StateAdd

! !PRIVATE MEMBER FUNCTIONS:
!
!    module procedure ESMF_StateAddOneArray
    module procedure ESMF_StateAddOneArrayX
    module procedure ESMF_StateAddArrayList

!    module procedure ESMF_StateAddOneArrayBundle
    module procedure ESMF_StateAddOneArrayBundleX
    module procedure ESMF_StateAddArrayBundleList

!    module procedure ESMF_StateAddOneField
    module procedure ESMF_StateAddOneFieldX
    module procedure ESMF_StateAddFieldList

!    module procedure ESMF_StateAddOneFieldBundle
    module procedure ESMF_StateAddOneFieldBundleX
    module procedure ESMF_StateAddFieldBundleList

!    module procedure ESMF_StateAddOneRouteHandle
    module procedure ESMF_StateAddRouteHandleList

!    module procedure ESMF_StateAddOneState
    module procedure ESMF_StateAddOneStateX
    module procedure ESMF_StateAddStateList


! !DESCRIPTION: 
! This interface provides a single entry point for the various 
! types of {\tt ESMF\_StateAdd} functions.   
!  
!EOPI 
  end interface

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_StateAddRplace -- Add/replace items to a State

! !INTERFACE:
  interface ESMF_StateAddReplace

! !PRIVATE MEMBER FUNCTIONS:
!
    module procedure ESMF_StateAddRpArrayList
    module procedure ESMF_StateAddRpArrayBundleList
    module procedure ESMF_StateAddRpFieldList
    module procedure ESMF_StateAddRpFieldBundleList
    module procedure ESMF_StateAddRpRoutehandleList
    module procedure ESMF_StateAddRpStateList


! !DESCRIPTION: 
! This interface provides a single entry point for the various 
! types of {\tt ESMF\_StateAdd} functions.   
!  
!EOPI 
  end interface

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_StateGet -- Get items from a State

! !INTERFACE:
  interface ESMF_StateGet

! !PRIVATE MEMBER FUNCTIONS:
!
      module procedure ESMF_StateGetArray
      module procedure ESMF_StateGetArrayBundle
      module procedure ESMF_StateGetField
      module procedure ESMF_StateGetFieldBundle
      module procedure ESMF_StateGetRouteHandle
      module procedure ESMF_StateGetState
      module procedure ESMF_StateGetInfo
      module procedure ESMF_StateGetItemInfo


! !DESCRIPTION: 
! This interface provides a single entry point for the various 
! types of {\tt ESMF\_StateGet} functions.   
!  
!EOPI 
  end interface

!===============================================================================
! StateOperator() interfaces
!===============================================================================

! -------------------------- ESMF-public method -------------------------------
!BOP
! !IROUTINE: ESMF_StateAssignment(=) - State assignment
!
! !INTERFACE:
!   interface assignment(=)
!   state1 = state2
!
! !ARGUMENTS:
!   type(ESMF_State) :: state1
!   type(ESMF_State) :: state2
!
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!   Assign state1 as an alias to the same ESMF State object in memory
!   as state2. If state2 is invalid, then state1 will be equally invalid after
!   the assignment.
!
!   The arguments are:
!   \begin{description}
!   \item[state1]
!     The {\tt ESMF\_State} object on the left hand side of the assignment.
!   \item[state2]
!     The {\tt ESMF\_State} object on the right hand side of the assignment.
!   \end{description}
!
!EOP
!------------------------------------------------------------------------------


! -------------------------- ESMF-public method -------------------------------
!BOP
! !IROUTINE: ESMF_StateOperator(==) - State equality operator
!
! !INTERFACE:
  interface operator(==)
!   if (state1 == state2) then ... endif
!             OR
!   result = (state1 == state2)
! !RETURN VALUE:
!   logical :: result
!
! !ARGUMENTS:
!   type(ESMF_State), intent(in) :: state1
!   type(ESMF_State), intent(in) :: state2
!
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!   Test whether state1 and state2 are valid aliases to the same ESMF
!   State object in memory. For a more general comparison of two ESMF States,
!   going beyond the simple alias test, the ESMF\_StateMatch() function (not yet
!   implemented) must be used.
!
!   The arguments are:
!   \begin{description}
!   \item[state1]
!     The {\tt ESMF\_State} object on the left hand side of the equality
!     operation.
!   \item[state2]
!     The {\tt ESMF\_State} object on the right hand side of the equality
!     operation.
!   \end{description}
!
!EOP
    module procedure ESMF_StateEQ

  end interface
!------------------------------------------------------------------------------


! -------------------------- ESMF-public method -------------------------------
!BOP
! !IROUTINE: ESMF_StateOperator(/=) - State not equal operator
!
! !INTERFACE:
  interface operator(/=)
!   if (state1 /= state2) then ... endif
!             OR
!   result = (state1 /= state2)
! !RETURN VALUE:
!   logical :: result
!
! !ARGUMENTS:
!   type(ESMF_State), intent(in) :: state1
!   type(ESMF_State), intent(in) :: state2
!
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!   Test whether state1 and state2 are {\it not} valid aliases to the
!   same ESMF State object in memory. For a more general comparison of two ESMF
!   States, going beyond the simple alias test, the ESMF\_StateMatch() function
!   (not yet implemented) must be used.
!
!   The arguments are:
!   \begin{description}
!   \item[state1]
!     The {\tt ESMF\_State} object on the left hand side of the non-equality
!     operation.
!   \item[state2]
!     The {\tt ESMF\_State} object on the right hand side of the non-equality
!     operation.
!   \end{description}
!
!EOP
    module procedure ESMF_StateNE

  end interface
!------------------------------------------------------------------------------


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!-------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateEQ()"
!BOPI
! !IROUTINE:  ESMF_StateEQ - Compare two States for equality
!
! !INTERFACE:
  function ESMF_StateEQ(state1, state2)
! 
! !RETURN VALUE:
    logical :: ESMF_StateEQ

! !ARGUMENTS:
    type(ESMF_State), intent(in) :: state1
    type(ESMF_State), intent(in) :: state2

! !DESCRIPTION:
!   Test if both {\tt state1} and {\tt state2} alias the same ESMF State 
!   object.
!
!EOPI
!-------------------------------------------------------------------------------

    ESMF_INIT_TYPE sinit1, sinit2

    ! Use the following logic, rather than "ESMF-INIT-CHECK-DEEP", to gain 
    ! init checks on both args, and in the case where both are uninitialized,
    ! to distinguish equality based on uninitialized type (uncreated,
    ! deleted).

    ! TODO: Consider moving this logic to C++: use Base class? status?
    !       Or replicate logic for C interface also.

    ! check inputs
    sinit1 = ESMF_StateGetInit(state1)
    sinit2 = ESMF_StateGetInit(state2)

    ! TODO: this line must remain split in two for SunOS f90 8.3 127000-03
    if (sinit1 .eq. ESMF_INIT_CREATED .and. &
      sinit2 .eq. ESMF_INIT_CREATED) then
      ESMF_StateEQ = associated(state1%statep,state2%statep)
    else
      ESMF_StateEQ = ESMF_FALSE
    endif

  end function ESMF_StateEQ
!-------------------------------------------------------------------------------


!-------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateNE()"
!BOPI
! !IROUTINE:  ESMF_StateNE - Compare two States for non-equality
!
! !INTERFACE:
  function ESMF_StateNE(state1, state2)
! 
! !RETURN VALUE:
    logical :: ESMF_StateNE

! !ARGUMENTS:
    type(ESMF_State), intent(in) :: state1
    type(ESMF_State), intent(in) :: state2

! !DESCRIPTION:
!   Test if both {\tt state1} and {\tt state2} alias the same ESMF State 
!   object.
!
!EOPI
!-------------------------------------------------------------------------------

    ! Use the following logic, rather than "ESMF-INIT-CHECK-DEEP", to gain 
    ! init checks on both args, and in the case where both are uninitialized,
    ! to distinguish equality based on uninitialized type (uncreated,
    ! deleted).
    
    ESMF_StateNE = .not.ESMF_StateEQ(state1, state2)

  end function ESMF_StateNE
!-------------------------------------------------------------------------------



!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_StateAdd - Add a single item to a State
!
! !INTERFACE:
!  subroutine ESMF_StateAdd(state, <item>, keywordEnforcer, relaxedflag, rc)
!
! !ARGUMENTS:
!    type(ESMF_State), intent(inout)          :: state
!    <item>, see below for supported values
!    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
!    logical,          intent(in),   optional :: relaxedflag
!    integer,          intent(out),  optional :: rc
!     
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!      Add a reference to a single <item> to an existing 
!      {\tt state}.  The name of the <item> must be unique within
!      the {\tt state}.
!
!      Supported values for <item> are:
!      \begin{description}
!      \item type(ESMF\_Array), intent(in)            :: array
!      \item type(ESMF\_ArrayBundle), intent(in)      :: arraybundle
!      \item type(ESMF\_Field), intent(in)            :: field
!      \item type(ESMF\_FieldBundle), intent(in)      :: fieldbundle
!      \item type(ESMF\_RouteHandle), intent(in)      :: routehandle
!      \item type(ESMF\_State), intent(in)            :: nestedState
!      \end{description}
!
! The arguments are:
! \begin{description}
! \item[state]
!      The {\tt ESMF\_State} to which <item>s will be added.
! \item[<item>]
!      The <item> to be added.  This is a reference only; when
!      the {\tt state} is destroyed the <item>s contained in it will
!      not be destroyed.   Also, the <item> cannot be safely 
!      destroyed before the {\tt state} is destroyed.
!      Since <item>s can be added to multiple containers, it remains
!      the responsibility of the user to manage their
!      destruction when they are no longer in use.
! \item[{[relaxedflag]}]
!      A setting of {\tt .true.} indicates a relaxed definition of "add",
!      where it is {\em not} an error if {\tt <item>} contains items
!       with names that are already found in {\tt state}. The {\tt State}
!      is left unchanged for these items. For {\tt .false.} this is treated
!      as an error condition.  The default setting is {\tt .false.}.
! \item[{[rc]}]
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!
! When replacing an existing <item>, the {\tt ESMF\_StateReplace} method
! should be used.
!EOPI
!------------------------------------------------------------------------------

!------------------------------------------------------------------------------
#define StateAddMacro(mtype, mentryname, mname, mnameatt, mnameattbase) \
! ^undef  ESMF_METHOD @\
! ^define ESMF_METHOD "ESMF_StateAdd" @\
! !BOPI @\
! ! !IROUTINE: ESMF_StateAdd - Add an item to a State @\
! ! @\
! ! !INTERFACE: @\
!   ! Private name; call using ESMF_StateAdd()  @\
!   subroutine ESMF_StateAdd##mentryname (state, mname, keywordEnforcer, rc) @\
! ! @\
! ! !ARGUMENTS: @\
!     type(ESMF_State), intent(inout)          :: state @\
!     type(mtype),      intent(in)             :: mname @\
!     type(ESMF_KeywordEnforcer), optional     :: keywordEnforcer ! must use keywords for the below @\
!     integer,          intent(out),  optional :: rc @\
! !EOPI @\
! !------------------------------------------------------------------------------ @\
!  @\
!     call ESMF_StateAdd (state, mname, addflag=.true., proxyflag=.false., rc=rc) @\
!  @\
!   end subroutine ESMF_StateAdd##mentryname @\
! ^undef  ESMF_METHOD @\
! ^define ESMF_METHOD "ESMF_StateAddRp" @\
! !BOPI @\
! ! !IROUTINE: ESMF_StateAddRp - Add/replace an item to a State @\
! ! @\
! ! !INTERFACE: @\
!   ! Private name; call using ESMF_StateAdd()  @\
!   subroutine ESMF_StateAddRp##mentryname (state, mname, keywordEnforcer, rc) @\
! ! @\
! ! !ARGUMENTS: @\
!     type(ESMF_State), intent(inout)          :: state @\
!     type(mtype),      intent(in)             :: mname @\
!     type(ESMF_KeywordEnforcer), optional     :: keywordEnforcer ! must use keywords for the below @\
!     integer,          intent(out),  optional :: rc @\
! !EOPI @\
! !------------------------------------------------------------------------------ @\
!  @\
!     call ESMF_StateAdd (state, mname,  & @\
!         addflag=.true., replaceflag=.true.,  & @\
!         proxyflag=.false., rc=rc) @\
!  @\
!   end subroutine ESMF_StateAddRp##mentryname @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_StateAddX" @\
!BOPI @\
! !IROUTINE: ESMF_StateAdd - Add an item to a State with proxyflag @\
! @\
! !INTERFACE: @\
  ! Private name; call using ESMF_StateAdd()  @\
  subroutine ESMF_StateAdd##mentryname##X (state, mname,  & @\
                                    proxyflag, addflag, replaceflag, relaxedflag, rc) @\
! @\
! !ARGUMENTS: @\
    type(ESMF_State), intent(inout)          :: state @\
    type(mtype),      intent(in)             :: mname @\
    logical,          intent(in)             :: proxyflag @\
    logical,          intent(in),   optional :: addflag @\
    logical,          intent(in),   optional :: replaceflag @\
    logical,          intent(in),   optional :: relaxedflag @\
    integer,          intent(out),  optional :: rc @\
!EOPI @\
!------------------------------------------------------------------------------ @\
      type(mtype) :: temp_list(1) @\
^if !defined (noattributesversion) @\
      character(ESMF_MAXSTR) :: lvalue1, lvalue2 @\
      character(ESMF_MAXSTR) :: lobject, lname @\
      type(ESMF_Logical) :: linkChange @\
^endif @\
      integer :: localrc @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) @\
      ESMF_INIT_CHECK_DEEP(mtype##GetInit,mname,rc) @\
 @\
      ! Initialize return code; assume routine not implemented @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
      localrc = ESMF_RC_NOT_IMPL @\
 @\
      call ESMF_StateValidate(state, rc=localrc) @\
      if (ESMF_LogFoundError(localrc, & @\
        ESMF_ERR_PASSTHRU, & @\
        ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      temp_list(1) = mname @\
 @\
      call ESMF_StateClsAdd (state%statep, temp_list, & @\
        addflag=addflag, replaceflag=replaceflag, relaxedflag=relaxedflag,  & @\
        proxyflag=proxyflag, rc=localrc)  @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
                    ESMF_CONTEXT, rcToReturn=rc))  return @\
 @\
^if !defined (noattributesversion) @\
      !  link the Attribute hierarchies @\
      linkChange = ESMF_TRUE @\
      call c_ESMC_AttributeLink(state%statep%base,  & @\
          mnameattbase, linkChange, localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
                    ESMF_CONTEXT, rcToReturn=rc))  return @\
 @\
      ! set the import and export Attributes on any item connected to this State @\
      lobject = #mnameatt @\
      lvalue1 = 'Import'  @\
      lvalue2 = 'Export' @\
      lname  = 'VariableIntent' @\
      if (state%statep%st == ESMF_STATEINTENT_IMPORT) then @\
        call c_ESMC_AttributeSetObjChrInTree(state%statep%base,  & @\
           trim (lobject), trim (lname), trim (lvalue1), localrc) @\
        if (ESMF_LogFoundError(localrc, & @\
           ESMF_ERR_PASSTHRU, & @\
           ESMF_CONTEXT, rcToReturn=rc)) return @\
      else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then @\
        call c_ESMC_AttributeSetObjChrInTree(state%statep%base,  & @\
           trim (lobject), trim (lname), trim (lvalue2), localrc) @\
        if (ESMF_LogFoundError(localrc, & @\
           ESMF_ERR_PASSTHRU, & @\
           ESMF_CONTEXT, rcToReturn=rc)) return @\
      endif @\
^endif @\
       @\
      if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_StateAdd##mentryname##X

!------------------------------------------------------------------------------
StateAddMacro(ESMF_Array,      OneArray,      array,      array, array)
StateAddMacro(ESMF_ArrayBundle,OneArrayBundle,arraybundle,array, arraybundle)
StateAddMacro(ESMF_Field,      OneField,      field,      field, field%ftypep%base)
StateAddMacro(ESMF_FieldBundle,OneFieldBundle,fieldbundle,field, fieldbundle%this%base)
^define noattributesversion
StateAddMacro(ESMF_Routehandle,OneRouteHandle,routehandle,routehandle, routehandle)
^undef noattributesversion
^define stateversion
StateAddMacro(ESMF_State,OneState,nestedState,state,nestedState%statep%base)
^undef stateversion

!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_StateAdd - Add a list of items to a State
!
! !INTERFACE:
!  subroutine ESMF_StateAdd(state, <itemList>, relaxedFlag, rc)
!
! !ARGUMENTS:
!    type(ESMF_State), intent(inout)          :: state 
!    <itemList>, see below for supported values
!    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
!    logical,          intent(in),   optional :: relaxedFlag
!    integer,          intent(out),  optional :: rc     
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
! Add a list of items to a {\tt ESMF\_State}. It is an error if any item in
! <itemlist> already matches, by name, an item already contained in {\tt state}.
!    
!    Supported values for <itemList> are:   
!    \begin{description}
!    \item type(ESMF\_Array), intent(in)             :: arrayList(:)
!    \item type(ESMF\_ArrayBundle), intent(in)       :: arraybundleList(:)
!    \item type(ESMF\_Field), intent(in)             :: fieldList(:)
!    \item type(ESMF\_FieldBundle), intent(in)       :: fieldbundleList(:)
!    \item type(ESMF\_RouteHandle), intent(in)       :: routehandleList(:)
!    \item type(ESMF\_State), intent(in)             :: nestedStateList(:)
!    \end{description}
!
! The arguments are:
! \begin{description}
! \item[state]
!     An {\tt ESMF\_State} to which the <itemList> will be added.
! \item[<itemList>]
!     The list of items to be added.
!     This is a reference only; when
!     the {\tt ESMF\_State} is destroyed the <itemList> items contained within it will
!     not be destroyed.   Also, the items in the <itemList> cannot be safely 
!     destroyed before the {\tt ESMF\_State} is destroyed.
!     Since <itemList> items can be added to multiple containers, it remains
!     the responsibility of the user to manage their
!     destruction when they are no longer in use.
! \item[{[relaxedflag]}]
!     A setting of {\tt .true.} indicates a relaxed definition of "add",
!     where it is {\em not} an error if {\tt <itemList>} contains items
!     with names that are found in {\tt state}. The {\tt State}
!     is left unchanged for these items. For {\tt .false.} this is treated
!     as an error condition.  The default setting is {\tt .false.}.
! \item[{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
#define StateAddListMacro(mtype, mentryname, mname, mnameatt, mnameattbase) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_StateAddList" @\
!BOPI @\
! !IROUTINE: ESMF_StateAdd - Add a list of items to a State @\
! @\
! !INTERFACE: @\
  ! Private name; call using ESMF_StateAdd()  @\
  subroutine ESMF_StateAdd##mentryname##List(state, mname,  & @\
                                    keywordEnforcer, relaxedflag, rc) @\
! @\
! !ARGUMENTS: @\
    type(ESMF_State), intent(inout)          :: state  @\
    type(mtype),      intent(in)             :: mname(:) @\
    type(ESMF_KeywordEnforcer), optional     :: keywordEnforcer ! must use keywords for the below @\
    logical,          intent(in),   optional :: relaxedflag @\
    integer,          intent(out),  optional :: rc      @\
!EOPI @\
!------------------------------------------------------------------------------ @\
      integer :: localrc, i @\
      integer :: localcount @\
      logical :: localrelaxed @\
^if !defined (noattributesversion) @\
      character(ESMF_MAXSTR) :: lvalue1, lvalue2 @\
      character(ESMF_MAXSTR) :: lobject, lname @\
      type(ESMF_Logical) :: linkChange @\
^endif @\
 @\
      ! Initialize return code; assume routine not implemented @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
      localrc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) @\
      call ESMF_StateValidate(state, rc=localrc) @\
      if (ESMF_LogFoundError(localrc, & @\
         ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
                                   @\
      localrelaxed = .false. @\
      if (present (relaxedflag)) then @\
        localrelaxed = relaxedflag @\
      end if @\
 @\
      localcount = size (mname) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) @\
      do i=1, localcount @\
          ESMF_INIT_CHECK_DEEP(ESMF_##mentryname##GetInit,mname(i),rc) @\
      enddo @\
 @\
      call ESMF_StateClsAdd (state%statep, mname, & @\
          addflag=.true., relaxedflag=localrelaxed, rc=localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc))  return @\
 @\
^if !defined (noattributesversion) @\
      ! link the Attribute hierarchies @\
      linkChange = ESMF_TRUE @\
      do i=1, localcount @\
         call c_ESMC_AttributeLink(state%statep%base, & @\
            mnameattbase, linkChange, localrc) @\
         if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
                    ESMF_CONTEXT, rcToReturn=rc))  return @\
      enddo @\
 @\
      ! set the import and export Attributes on any item connected to this State @\
      lobject = #mnameatt @\
      lvalue1 = 'Import'  @\
      lvalue2 = 'Export' @\
      lname  = 'VariableIntent' @\
      if (state%statep%st == ESMF_STATEINTENT_IMPORT) then @\
        call c_ESMC_AttributeSetObjChrInTree(state%statep%base,  & @\
          trim (lobject), trim (lname), trim (lvalue1), localrc) @\
        if (ESMF_LogFoundError(localrc, & @\
          ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, & @\
          rcToReturn=rc)) return @\
      else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then @\
        call c_ESMC_AttributeSetObjChrInTree(state%statep%base,  & @\
          trim (lobject), trim (lname), trim (lvalue2), localrc) @\
        if (ESMF_LogFoundError(localrc, & @\
          ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, & @\
          rcToReturn=rc)) return @\
      endif @\
^endif @\
       @\
      if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_StateAdd##mentryname##List

!------------------------------------------------------------------------------
StateAddListMacro(ESMF_Array,Array,arrayList,array,arrayList(i))
StateAddListMacro(ESMF_ArrayBundle,ArrayBundle,arraybundleList,array,arraybundleList(i))
StateAddListMacro(ESMF_Field,Field,fieldList,field,fieldList(i)%ftypep%base)
StateAddListMacro(ESMF_FieldBundle,FieldBundle,fieldbundleList,field,fieldbundleList(i)%this%base)
^define noattributesversion
StateAddListMacro(ESMF_RouteHandle,RouteHandle,routehandleList,none,none)
^undef noattributesversion
StateAddListMacro(ESMF_State,State,nestedStateList,state,nestedStateList(i)%statep%base)


!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_StateAddReplace - Add or replace a list of items to a State
!
! !INTERFACE:
!  subroutine ESMF_StateAddReplace(state, <itemList>, rc)
!
! !ARGUMENTS:
!    type(ESMF_State), intent(inout)          :: state 
!    <itemList>, see below for supported values
!    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
!    integer,          intent(out),  optional :: rc     
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
! Add or replace a list of items to an {\tt ESMF\_State}.  If an item in
! <itemlist> does not match any items already present in {\tt state}, it is
! added.  Items with names already present in the {\tt state} replace the
! existing item.
!    
!    Supported values for <itemList> are:   
!    \begin{description}
!    \item type(ESMF\_Array), intent(in)             :: arrayList(:)
!    \item type(ESMF\_ArrayBundle), intent(in)       :: arraybundleList(:)
!    \item type(ESMF\_Field), intent(in)             :: fieldList(:)
!    \item type(ESMF\_FieldBundle), intent(in)       :: fieldbundleList(:)
!    \item type(ESMF\_RouteHandle), intent(in)       :: routehandleList(:)
!    \item type(ESMF\_State), intent(in)             :: nestedStateList(:)
!    \end{description}
!
! The arguments are:
! \begin{description}
! \item[state]
!     An {\tt ESMF\_State} to which the <itemList> will be added or replaced.
! \item[<itemList>]
!     The list of items to be added or replaced.
!     This is a reference only; when
!     the {\tt ESMF\_State} is destroyed the <itemList> items contained within it will
!     not be destroyed.   Also, the items in the <itemList> cannot be safely 
!     destroyed before the {\tt ESMF\_State} is destroyed.
!     Since <itemList> items can be added to multiple containers, it remains
!     the responsibility of the user to manage their
!     destruction when they are no longer in use.
! \item[{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
! \end{description}
!EOP
!------------------------------------------------------------------------------
#define StateAddRepListMacro(mtype, mentryname, mname, mnameatt, mnameattbase) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_StateAddRpList" @\
!BOPI @\
! !IROUTINE: ESMF_StateAddReplace - Add a list of items to a State @\
! @\
! !INTERFACE: @\
  ! Private name; call using ESMF_StateAddReplace()  @\
  subroutine ESMF_StateAddRp##mentryname##List(state, mname,  & @\
                                    keywordEnforcer, rc) @\
! @\
! !ARGUMENTS: @\
    type(ESMF_State), intent(inout)          :: state  @\
    type(mtype),      intent(in)             :: mname(:) @\
    type(ESMF_KeywordEnforcer), optional     :: keywordEnforcer ! must use keywords for the below @\
    integer,          intent(out),  optional :: rc      @\
!EOPI @\
!------------------------------------------------------------------------------ @\
      integer :: localrc, i @\
      integer :: localcount @\
^if !defined (noattributesversion) @\
      character(ESMF_MAXSTR) :: lvalue1, lvalue2 @\
      character(ESMF_MAXSTR) :: lobject, lname @\
      type(ESMF_Logical) :: linkChange @\
^endif @\
 @\
      ! Initialize return code; assume routine not implemented @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
      localrc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) @\
      call ESMF_StateValidate(state, rc=localrc) @\
      if (ESMF_LogFoundError(localrc, & @\
         ESMF_ERR_PASSTHRU, & @\
         ESMF_CONTEXT, rcToReturn=rc)) return @\
                                   @\
      localcount = size (mname) @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) @\
      do i=1, localcount @\
          ESMF_INIT_CHECK_DEEP(ESMF_##mentryname##GetInit,mname(i),rc) @\
      enddo @\
 @\
      call ESMF_StateClsAdd (state%statep, mname, & @\
          addflag=.true., replaceflag=.true., rc=localrc) @\
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, rcToReturn=rc))  return @\
 @\
^if !defined (noattributesversion) @\
      ! link the Attribute hierarchies @\
      linkChange = ESMF_TRUE @\
      do i=1, localcount @\
         call c_ESMC_AttributeLink(state%statep%base, & @\
            mnameattbase, linkChange, localrc) @\
         if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, & @\
                    ESMF_CONTEXT, rcToReturn=rc))  return @\
      enddo @\
 @\
      ! set the import and export Attributes on any item connected to this State @\
      lobject = #mnameatt @\
      lvalue1 = 'Import'  @\
      lvalue2 = 'Export' @\
      lname  = 'VariableIntent' @\
      if (state%statep%st == ESMF_STATEINTENT_IMPORT) then @\
        call c_ESMC_AttributeSetObjChrInTree(state%statep%base,  & @\
          trim (lobject), trim (lname), trim (lvalue1), localrc) @\
        if (ESMF_LogFoundError(localrc, & @\
          ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, & @\
          rcToReturn=rc)) return @\
      else if (state%statep%st == ESMF_STATEINTENT_EXPORT) then @\
        call c_ESMC_AttributeSetObjChrInTree(state%statep%base,  & @\
          trim (lobject), trim (lname), trim (lvalue2), localrc) @\
        if (ESMF_LogFoundError(localrc, & @\
          ESMF_ERR_PASSTHRU, & @\
          ESMF_CONTEXT, & @\
          rcToReturn=rc)) return @\
      endif @\
^endif @\
       @\
      if (present(rc)) rc = ESMF_SUCCESS @\
  end subroutine ESMF_StateAddRp##mentryname##List

!------------------------------------------------------------------------------
StateAddRepListMacro(ESMF_Array,Array,arrayList,array,arrayList(i))
StateAddRepListMacro(ESMF_ArrayBundle,ArrayBundle,arraybundleList,array,arraybundleList(i))
StateAddRepListMacro(ESMF_Field,Field,fieldList,field,fieldList(i)%ftypep%base)
StateAddRepListMacro(ESMF_FieldBundle,FieldBundle,fieldbundleList,field,fieldbundleList(i)%this%base)
^define noattributesversion
StateAddRepListMacro(ESMF_RouteHandle,RouteHandle,routehandleList,none,none)
^undef noattributesversion
StateAddRepListMacro(ESMF_State,State,nestedStateList,state,nestedStateList(i)%statep%base)

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateCreate"
!BOP
! !IROUTINE: ESMF_StateCreate - Create a new State

! !INTERFACE:
      function ESMF_StateCreate(keywordEnforcer, stateintent, &
                   arrayList, arraybundleList,  &
                   fieldList, fieldbundleList,  &
                   nestedStateList,             &
                   routehandleList, name, rc)
!
! !RETURN VALUE:
      type(ESMF_State) :: ESMF_StateCreate
!
! !ARGUMENTS:
    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
      type(ESMF_StateIntent_Flag),   intent(in),  optional :: stateintent
      type(ESMF_Array),       intent(in),  optional :: arrayList(:)
      type(ESMF_ArrayBundle), intent(in),  optional :: arraybundleList(:)
      type(ESMF_Field),       intent(in),  optional :: fieldList(:)
      type(ESMF_FieldBundle), intent(in),  optional :: fieldbundleList(:)
      type(ESMF_State),       intent(in),  optional :: nestedStateList(:)
      type(ESMF_RouteHandle), intent(in),  optional :: routehandleList(:)
      character(len=*),       intent(in),  optional :: name 
      integer,                intent(out), optional :: rc 
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!  Create a new {\tt ESMF\_State}, set default characteristics for
!   objects added to it, and optionally add initial objects to it.
!    
!  The arguments are:
!  \begin{description}
!   \item[{[stateintent]}]
!    Import or Export {\tt ESMF\_State}.  Valid values are 
!    {\tt ESMF\_STATEINTENT\_IMPORT}, {\tt ESMF\_STATEINTENT\_EXPORT}, 
!    or {\tt ESMF\_STATEINTENT\_UNSPECIFIED} The default 
!    is {\tt ESMF\_STATEINTENT\_UNSPECIFIED}.
!   \item[{[arrayList]}]
!    A list (Fortran array) of {\tt ESMF\_Array}s.
!   \item[{[arraybundleList]}]
!    A list (Fortran array) of {\tt ESMF\_ArrayBundle}s.
!   \item[{[fieldList]}]
!    A list (Fortran array) of {\tt ESMF\_Field}s.
!   \item[{[fieldbundleList]}]
!    A list (Fortran array) of {\tt ESMF\_FieldBundle}s.
!   \item[{[nestedStateList]}]
!    A list (Fortran array) of {\tt ESMF\_State}s to be nested 
!    inside the outer {\tt ESMF\_State}.
!   \item[{[routehandleList]}]
!    A list (Fortran array) of {\tt ESMF\_RouteHandle}s.
!   \item[{[name]}]
!    Name of this {\tt ESMF\_State} object.   A default name will be generated
!    if none is specified.
!   \item[{[rc]}]
!    Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!   \end{description}
!
!EOP

        ! local vars
        type (ESMF_StateClass), pointer :: stypep
        integer :: localrc      ! local error status
        integer :: memstat      ! Stat from allocate/deallocate
        integer :: i

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

        ! check input variables
        if (present(arrayList)) then
           do i=1,size(arrayList)
ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,arrayList(i),rc)
           enddo
        endif
        if (present(arraybundleList)) then
           do i=1,size(arraybundleList)
ESMF_INIT_CHECK_DEEP(ESMF_ArrayBundleGetInit,arraybundleList(i),rc)
           enddo
        endif
        if (present(fieldbundleList)) then
           do i=1,size(fieldbundleList)
ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundleList(i),rc)
           enddo
        endif
        if (present(fieldList)) then
           do i=1,size(fieldList)
ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,fieldList(i),rc)
           enddo
        endif
        if (present(nestedStateList)) then
           do i=1,size(nestedStateList)
ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,nestedStateList(i),rc)
           enddo
        endif
        if (present(routehandleList)) then
           do i=1,size(routehandleList)
ESMF_INIT_CHECK_DEEP(ESMF_RouteHandleGetInit,routehandleList(i),rc)
           enddo
        endif


        ! Initialize the pointers to null.
        nullify(ESMF_StateCreate%statep)
        nullify(stypep)

        allocate(stypep, stat=memstat)
        if (ESMF_LogFoundAllocError(memstat, msg="State type", &
                 ESMF_CONTEXT, rcToReturn=rc)) return
        
        call ESMF_StateConstruct(stypep,  &
                 statename=name, stateintent=stateintent, &
                 arrays=arrayList, arraybundles=arraybundleList, &
                 fields=fieldList, fieldbundles=fieldbundleList, &
                 states=nestedStateList,  &
                 routehandles=routehandleList, rc=localrc)
        if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) then 
            deallocate(stypep, stat=memstat)
            return
        endif

        ! Set return values
        ESMF_StateCreate%statep => stypep

        ! Add reference to this object into ESMF garbage collection table
        call c_ESMC_VMAddFObject(ESMF_StateCreate, ESMF_ID_STATE%objectID)
      
        ! validate created state
        ESMF_INIT_SET_CREATED(ESMF_StateCreate)
 
        if (present(rc)) rc = ESMF_SUCCESS

        end function ESMF_StateCreate


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateDestroy"
!BOP
! !IROUTINE: ESMF_StateDestroy - Release resources for a State
!
! !INTERFACE:
      recursive subroutine ESMF_StateDestroy(state, keywordEnforcer, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout)          :: state
    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
      integer,          intent(out),  optional :: rc
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!     Releases resources associated with this {\tt ESMF\_State}. Actual
!     objects added to {\tt ESMF\_State}s will not be destroyed, it
!     remains the responsibility of the user to destroy these objects in the correct
!     context.
!
!     The arguments are:
!     \begin{description}
!     \item[state]
!      Destroy contents of this {\tt ESMF\_State}.
!     \item[{[rc]}]
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP

        ! Local vars
        integer :: localrc                   ! local error status

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

        ! check input variables
        ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

        if (.not.associated(state%statep)) then 
          call ESMF_LogSetError(rcToCheck=ESMF_RC_OBJ_BAD, &
            msg="Uninitialized or already destroyed State: statep unassociated", &
            ESMF_CONTEXT, rcToReturn=rc)
          return
        endif 

        ! Call Destruct to release resources
        call ESMF_StateDestruct(state%statep, localrc)
        if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return

        ! mark object invalid
        call ESMF_BaseSetStatus(state%statep%base, ESMF_STATUS_INVALID, &
          rc=localrc)
        if (ESMF_LogFoundError(localrc, &
          ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) return

        ! Invalidate Destroyed State
        ESMF_INIT_SET_DELETED(state)

        ! Set return code if user specified it
        if (present(rc)) rc = ESMF_SUCCESS

        end subroutine ESMF_StateDestroy

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateGetInfo"
!BOP
! !IROUTINE: ESMF_StateGet - Get object-wide information from a State
!
! !INTERFACE:
      ! Private name; call using ESMF_StateGet()   
      subroutine ESMF_StateGetInfo(state,  &
            keywordEnforcer, itemSearch, itemorderflag, nestedFlag,  &
            stateintent, itemCount, itemNameList, itemTypeList, name, rc)
!
! !ARGUMENTS:
      type(ESMF_State),          intent(in)            :: state
    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
      character (len=*),         intent(in),  optional :: itemSearch
      type(ESMF_ItemOrder_Flag), intent(in),  optional :: itemorderflag
      logical,                   intent(in),  optional :: nestedFlag
      type(ESMF_StateIntent_Flag), intent(out), optional :: stateintent
      integer,                   intent(out), optional :: itemCount
      character (len=*),         intent(out), optional :: itemNameList(:)
      type(ESMF_StateItem_Flag), intent(out), optional :: itemTypeList(:)
      character (len=*),         intent(out), optional :: name
      integer,                   intent(out), optional :: rc             

!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \item\apiStatusModifiedSinceVersion{5.2.0r}
! \begin{description}
! \item[6.1.0] Added argument {\tt itemorderflag}.
!              The new argument gives the user control over the order in which
!              the items are returned.
! \end{description}
! \end{itemize}
!
! !DESCRIPTION:
!     Returns the requested information about this {\tt ESMF\_State}.
!     The optional {\tt itemSearch} argument may specify the name of
!     an individual item to search for.  When used in conjunction with
!     the {\tt nestedFlag}, nested States will also be searched.
!
!     Typically, an {\tt ESMF\_StateGet()} information request will be performed
!     twice.  The first time, the {\tt itemCount} argument will be used to
!     query the size of arrays that are needed.  Arrays can then be allocated
!     to the correct size for {\tt itemNameList} and {\tt itemtypeList}
!     as needed.  A second call to {\tt ESMF\_StateGet()} will then fill in the
!     values.
!
!     The arguments are:
!     \begin{description}     
!     \item[state]
!       An {\tt ESMF\_State} object to be queried.
!     \item[{[itemSearch]}]
!       Query objects by name in the State.  When the {\tt nestedFlag}
!       option is set to .true., all nested States will also be searched
!       for the specified name.
!     \item[{[itemorderflag]}]
!       Specifies the order of the returned items in the {\tt itemNameList}
!       and {\tt itemTypeList}.  The default is {\tt ESMF\_ITEMORDER\_ABC}.
!       See \ref{const:itemorderflag} for a full list of options.
!     \item[{[nestedFlag]}]
!       When set to {\tt .false.}, returns information at the current
!       State level only (default)
!       When set to {\tt .true.}, additionally returns information from
!       nested States
!     \item[{[stateintent]}]
!       Returns the type, e.g., Import or Export, of this {\tt ESMF\_State}.
!       Possible values are listed in Section~\ref{const:stateintent}.
!     \item[{[itemCount]}]
!       Count of items in this {\tt ESMF\_State}.
!       When the {\tt nestedFlag} option is
!       set to {\tt .true.}, the count will include items present in nested
!       States.  When using {\tt itemSearch}, it will count the number of
!       items matching the specified name.
!     \item[{[itemNameList]}]
!       Array of item names in this {\tt ESMF\_State}.
!       When the {\tt nestedFlag} option is
!       set to {\tt .true.}, the list will include items present in nested
!       States.  When using {\tt itemSearch}, it will return the names of
!       items matching the specified name.  {\tt itemNameList} must be at least
!       {\tt itemCount} long.
!     \item[{[itemTypeList]}]  
!       Array of possible item object types in this {\tt ESMF\_State}.
!       When the {\tt nestedFlag} option is
!       set to {\tt .true.}, the list will include items present in nested
!       States.  When using {\tt itemSearch}, it will return the types of
!       items matching the specified name. Must be at least {\tt itemCount}
!       long.  Return values are listed in Section~\ref{const:stateitem}.
!     \item[{[name]}]
!       Returns the name of this {\tt ESMF\_State}.
!     \item[{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP
      integer :: ilpos
      integer :: localrc
      integer :: localitemcount
      logical :: localnestedflag
      type(ESMF_ItemOrder_Flag)      :: itemorderflagArg
      type(ESMF_StateClass), pointer :: stypep

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

      call ESMF_StateValidate(state, rc=localrc)
      if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return

      localnestedflag = .false.
      if (present (nestedFlag)) then
        localnestedflag = nestedFlag
      end if
    
      itemorderflagArg = ESMF_ITEMORDER_ABC ! default
      if (present(itemorderflag)) &
	itemorderflagArg = itemorderflag

      stypep => state%statep

      if (present(name)) call ESMF_GetName(stypep%base, name=name, rc=localrc)
      if (present(stateintent)) stateintent = stypep%st

      localitemcount = infoCountWorker (stypep)

      if (present(itemCount))  &
        itemCount = localitemcount 

      if (present(itemNameList)) then
        ilpos = 1
        call itemNameWorker (stypep, prefix="")
      endif

      if (present(itemtypeList)) then
        ilpos = 1
        call itemTypeWorker (stypep)
      endif

      if (present(rc)) rc = localrc

    contains
      
        recursive function infoCountWorker (sp) result (icount)
          type(ESMF_StateClass), pointer :: sp
          integer :: icount

          integer :: i1
          type(ESMF_StateItemWrap), pointer :: siwrap(:)
          integer :: sipcount
          integer :: memstat1

	  call ESMF_ContainerGet (sp%stateContainer, itemCount=sipcount, rc=localrc)
	  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
	      ESMF_CONTEXT, rcToReturn=rc)) return

          siwrap => null ()
          if (present (itemSearch) .or. localnestedflag) then
	    call ESMF_ContainerGet (sp%stateContainer, itemList=siwrap, rc=localrc)
	    if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
	        ESMF_CONTEXT, rcToReturn=rc)) return
          end if

          if (.not. present (itemSearch)) then
            icount = sipcount
          else
            icount = 0
            do, i1 = 1, sipcount
              if (siwrap(i1)%si%namep == itemSearch) then
        	icount = icount + 1
              end if
            end do
          end if

          if (localnestedflag) then
            do, i1 = 1, sipcount
              if (siwrap(i1)%si%otype%ot == ESMF_STATEITEM_STATE%ot) then
                icount = icount + infoCountWorker (siwrap(i1)%si%datap%spp)
              end if
            end do
          end if

          if (associated (siwrap)) &
            deallocate (siwrap, stat=memstat1)

        end function infoCountWorker
      
        recursive subroutine itemNameWorker (sp, prefix)
          type(ESMF_StateClass), pointer :: sp
          character(*), intent(in) :: prefix

        ! Copy as many names as will fit in the output array.

          integer :: i1
          type(ESMF_StateItemWrap) , pointer :: siwrap(:)
          type(ESMF_StateItem), pointer :: sip
          integer :: sipcount
          integer :: memstat1

          siwrap => null ()
	  call ESMF_ContainerGet (sp%stateContainer,  &
              itemorderflag=itemorderflagArg,  &
              itemCount=sipcount,  &
              itemList=siwrap,  &
              rc=localrc)
	  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
	      ESMF_CONTEXT, rcToReturn=rc)) return

          do, i1 = 1, sipcount
            if (ilpos > size (itemNameList)) then
              localrc = ESMF_RC_ARG_SIZE
              exit
            end if

            sip => siwrap(i1)%si

            if (.not. present (itemSearch)) then
              itemNameList(ilpos) = ESMF_StringConcat (prefix, sip%namep)
              ilpos = ilpos + 1
            else
              if (sip%namep == itemSearch) then
                itemNameList(ilpos) = ESMF_StringConcat (prefix, sip%namep)
                ilpos = ilpos + 1
              end if
            end if

            if (sip%otype%ot == ESMF_STATEITEM_STATE%ot  &
                .and. localnestedflag) then
              call itemNameWorker (sip%datap%spp,  &
                  prefix=ESMF_StringConcat (prefix, ESMF_StringConcat (trim (sip%namep), '/')))
            end if
          end do

          if (associated (siwrap)) &
            deallocate (siwrap, stat=memstat1)

        end subroutine itemNameWorker
      
        recursive subroutine itemTypeWorker (sp)
          type(ESMF_StateClass), pointer :: sp

        ! Copy as many type fields as will fit in the output array.

          integer :: i1
          type(ESMF_StateItemWrap), pointer :: siwrap(:)
          type(ESMF_StateItem), pointer :: sip
          integer :: sipcount
          integer :: memstat1

          siwrap => null ()
	  call ESMF_ContainerGet (sp%stateContainer,  &
              itemorderflag=itemorderflagArg,  &
              itemCount=sipcount,  &
              itemList=siwrap,  &
              rc=localrc)
	  if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
	      ESMF_CONTEXT, rcToReturn=rc)) return

          do, i1 = 1, sipcount
            if (ilpos > size (itemtypeList)) then
              localrc = ESMF_RC_ARG_SIZE
              exit
            end if

            sip => siwrap(i1)%si

            if (.not. present (itemSearch)) then
              itemtypeList(ilpos) = sip%otype
              ilpos = ilpos + 1
            else
              if (sip%namep == itemSearch) then
                itemtypeList(ilpos) = sip%otype
                ilpos = ilpos + 1
              end if
            end if

            if (sip%otype%ot == ESMF_STATEITEM_STATE%ot  &
                .and. localnestedflag) then
              call itemTypeWorker (sip%datap%spp)
            end if
          end do

          if (associated (siwrap)) &
            deallocate (siwrap, stat=memstat1)

        end subroutine itemTypeWorker

    end subroutine ESMF_StateGetInfo

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateGetItemInfo"
!BOP
! !IROUTINE: ESMF_StateGet - Get information about an item in a State by item name
!
! !INTERFACE:
      ! Private name; call using ESMF_StateGet()   
      subroutine ESMF_StateGetItemInfo(state, itemName, itemType, keywordEnforcer, rc)
!
! !ARGUMENTS:
      type(ESMF_State),         intent(in)  :: state
      character (len=*),        intent(in)  :: itemName
      type(ESMF_StateItem_Flag), intent(out) :: itemType
    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
      integer,                  intent(out), optional :: rc             

!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!     Returns the type for the item named
!     {\tt name} in this {\tt ESMF\_State}.  If no item with this name
!     exists, the value {\tt ESMF\_STATEITEM\_NOTFOUND} will be returned
!     and the error code will not be set to an error.  Thus this routine
!     can be used to safely query for the existence of items by name 
!     whether or not they are expected to be there.   The error code will
!     be set in case of other errors, for example if the {\tt ESMF\_State}
!     itself is invalid.
!
!     The arguments are:
!     \begin{description}     
!     \item[state]
!        {\tt ESMF\_State} to be queried.
!      \item[itemName]
!        Name of the item to return information about.
!      \item[itemType]
!        Returned item types for the item with the given name, including 
!        placeholder names.  Options are
!        listed in Section~\ref{const:stateitem}.  If no item with the
!        given name is found, {\tt ESMF\_STATEITEM\_NOTFOUND} will be returned
!        and {\tt rc} will {\bf not} be set to an error.
!      \item[{[rc]}]
!        Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!       \end{description}
!
!
!EOP
      integer :: localrc
      type(ESMF_Container), pointer :: scp
      type(ESMF_StateItemWrap) :: siwrap
      logical :: foundflag

        ! check input variables
        ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

      ! Initialize return code; assume routine not implemented
      if (present(rc)) rc = ESMF_RC_NOT_IMPL
      localrc = ESMF_RC_NOT_IMPL

      call ESMF_StateValidate(state, rc=localrc)
      if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return

      scp => state%statep%stateContainer

      ! Find the object which matches this name
      call ESMF_ContainerGet (scp, itemname=itemName, &
          isPresent=foundflag, rc=localrc)
      if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) return

      if (foundflag) then
	call ESMF_ContainerGet (scp, itemName=itemName,  &
            item=siwrap, rc=localrc)
	if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return

        itemtype = siwrap%si%otype
      else
        itemtype = ESMF_STATEITEM_NOTFOUND
      end if

      if (present(rc)) rc = ESMF_SUCCESS

    end subroutine ESMF_StateGetItemInfo

!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_StateGet - Get an item from a State by item name
!
! !INTERFACE:
!      subroutine ESMF_StateGet(state, itemName, <item>, rc)
!
! !ARGUMENTS:
!      type(ESMF_State),      intent(in)            :: state
!      character (len=*),     intent(in)            :: itemName
!      <item>, see below for supported values
!    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
!      integer,               intent(out), optional :: rc             
!
!
! !STATUS:
! \begin{itemize}
! \item\apiStatusCompatibleVersion{5.2.0r}
! \end{itemize}
!
! !DESCRIPTION:
!      \begin{sloppypar}
!      Returns an <item> from an {\tt ESMF\_State} by item name.  
!      If the {\tt ESMF\_State} contains the <item> directly, only
!      {\tt itemName} is required.
!      \end{sloppypar}
!
!      If the {\tt state} contains nested {\tt ESMF\_State}s,
!      the {\tt itemName} argument may specify a fully qualified name
!      to access the desired item with a single call.  This is performed
!      using the '/' character to separate the names of the intermediate
!      State names leading to the desired item.  (E.g.,
!      {\tt itemName='state1/state12/item'}).
!
!      Supported values for <item> are:
!      \begin{description}
!      \item type(ESMF\_Array),  intent(out)           :: array
!      \item type(ESMF\_ArrayBundle), intent(out)      :: arraybundle
!      \item type(ESMF\_Field), intent(out)            :: field
!      \item type(ESMF\_FieldBundle), intent(out)      :: fieldbundle
!      \item type(ESMF\_RouteHandle),  intent(out)     :: routehandle
!      \item type(ESMF\_State), intent(out)            :: nestedState
!      \end{description}
!
!     The arguments are:
!     \begin{description}     
!     \item[state]
!     State to query for an <item> named {\tt itemName}.
!     \item[itemName]
!     Name of <item> to be returned.  This name may be fully
!     qualified in order to access nested State items.
!     \item[<item>]
!     Returned reference to the <item>.
!     \item[{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOP
!------------------------------------------------------------------------------
#define StateGetMacro(mtype,mentry,mname,mcomponent) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_StateGet" @\
!BOPI @\
 @\
! !IROUTINE: ESMF_StateGet - Retrieve an item from a State @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_StateGet()  @\
      subroutine ESMF_StateGet##mentry(state, itemName, mname,  & @\
          keywordEnforcer, rc) @\
! @\
! !ARGUMENTS: @\
      type(ESMF_State),  intent(in)	       :: state @\
      character (len=*), intent(in)	       :: itemName @\
      type(mtype),       intent(out)	       :: mname @\
    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below @\
      integer,           intent(out), optional :: rc @\
 @\
!EOPI @\
 @\
      type(ESMF_StateItem), pointer :: dataitem @\
      logical :: exists @\
      integer :: localrc @\
      character(len=len(itemName)+ESMF_MAXSTR) :: errmsg @\
 @\
      ! print *, 'ESMF_StateGet', #mentry, ': getting ', trim (itemName) @\
      localrc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc) @\
 @\
      call ESMF_StateValidate(state, rc=localrc) @\
      if (ESMF_LogFoundError(localrc, & @\
            ESMF_ERR_PASSTHRU, & @\
            ESMF_CONTEXT, rcToReturn=rc)) return @\
 @\
      ! Assume failure until we know we will succeed @\
      if (present(rc)) rc=ESMF_RC_NOT_IMPL @\
      ! TODO: do we need an empty (or invalid) item to mark failure? @\
 @\
      exists = ESMF_StateClassFindData(state%statep,   & @\
                 dataname=itemName, expected=.true., & @\
                 dataitem=dataitem,  & @\
                 rc=localrc) @\
      if (.not. exists) then @\
          write(errmsg, *) "no ", #mtype, " found named: ", trim(itemName) @\
          if (ESMF_LogFoundError(ESMF_RC_NOT_FOUND, msg=errmsg, & @\
              ESMF_CONTEXT, rcToReturn=rc)) return @\
      endif @\
 @\
      if (dataitem%otype .ne. ESMF_STATEITEM_##mentry) then @\
          write(errmsg, *) trim(itemName), " found but not type ", #mtype @\
          if (ESMF_LogFoundError(ESMF_RC_ARG_INCOMP, msg=errmsg, & @\
                ESMF_CONTEXT, rcToReturn=rc)) return @\
      endif @\
 @\
^if !defined (stateversion) @\
      mname = dataitem%datap%mcomponent @\
^else @\
      mname%statep => dataitem%datap%mcomponent @\
      ! validate created state @\
      ESMF_INIT_SET_CREATED(nestedState) @\
^endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine ESMF_StateGet##mentry

!------------------------------------------------------------------------------
StateGetMacro(ESMF_Array,Array,array,ap)
StateGetMacro(ESMF_ArrayBundle,ArrayBundle,arraybundle,abp)
StateGetMacro(ESMF_Field,Field,field,fp)
StateGetMacro(ESMF_FieldBundle,FieldBundle,fieldbundle,fbp)
StateGetMacro(ESMF_RouteHandle,RouteHandle,routehandle,rp)
^define stateversion
StateGetMacro(ESMF_State,State,nestedState,spp)
^undef  stateversion

! -------------------------- ESMF-public method -------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateIsCreated()"
!BOP
! !IROUTINE: ESMF_StateIsCreated - Check whether an State object has been created

! !INTERFACE:
  function ESMF_StateIsCreated(state, keywordEnforcer, rc)
! !RETURN VALUE:
    logical :: ESMF_StateIsCreated
!
! !ARGUMENTS:
    type(ESMF_State), intent(in)            :: state
type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    integer,          intent(out), optional :: rc

! !DESCRIPTION:
!   Return {\tt .true.} if the {\tt state} has been created. Otherwise return
!   {\tt .false.}. If an error occurs, i.e. {\tt rc /= ESMF\_SUCCESS} is
!   returned, the return value of the function will also be {\tt .false.}.
!
! The arguments are:
!   \begin{description}
!   \item[state]
!     {\tt ESMF\_State} queried.
!   \item[{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!   \end{description}
!
!EOP
  !-----------------------------------------------------------------------------
    ESMF_StateIsCreated = .false.   ! initialize
    if (present(rc)) rc = ESMF_SUCCESS
    if (ESMF_StateGetInit(state)==ESMF_INIT_CREATED) &
      ESMF_StateIsCreated = .true.
  end function
!------------------------------------------------------------------------------




!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateIsReconcileNeeded"
!BOPI
! !IROUTINE: ESMF_StateIsReconcileNeeded -- Return logical true if reconciliation needed
!
! !INTERFACE:
  function ESMF_StateIsReconcileNeeded(state, keywordEnforcer, collectiveflag, vm, rc)
!
! !RETURN VALUE:
    logical :: ESMF_StateIsReconcileNeeded
!
! !ARGUMENTS:
    type(ESMF_State), intent(in)            :: state
    type(ESMF_KeywordEnforcer), optional:: keywordEnforcer ! must use keywords below
    logical,          intent(in),  optional :: collectiveflag
    type(ESMF_VM),    intent(in),  optional :: vm
    integer,          intent(out), optional :: rc

!
! !DESCRIPTION:
!   Returns true if the {\tt state} needs to be reconciled in order
!   to be coherent across PETs.  By default, this is a local call.
!   Optionally, the {\tt collectiveflag} may be set to collectively
!   determine whether other PETs in the VM may need to be reconciled.
!
!   The arguments are:
!   \begin{description}     
!   \item[state]
!     {\tt ESMF\_State} to query.
!   \item[{[collectiveflag]}]
!     Perform a collective style call across all PETs in the VM.
!   \item[vm]
!     The current {\tt ESMF\_VM} (virtual machine).  All PETs in this
!     {\tt ESMF\_VM} will exchange information about objects which might
!     only be known to one or more PETs, and ensure all PETs in this VM
!     have a consistent view of the object list in this {\tt ESMF\_State}.
!     Required when {\tt collectiveflag} is set to {\tt .true.}.
!   \item[{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!   \end{description}
!
!EOPI

    logical :: localrecflag
    integer :: localrc
    integer :: commsend, commrecv

    ! check input variables
    ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)
    ESMF_INIT_CHECK_DEEP(ESMF_VMGetInit,vm,rc)

    localrecflag = is_rec_needed_worker (state%statep)

    if (present (collectiveflag)) then
      if (collectiveflag) then

        if (.not. present (vm)) then
          localrc = ESMF_FAILURE
          if (ESMF_LogFoundError(localrc, &
              msg="VM is required for collective inquiry", &
              ESMF_CONTEXT, rcToReturn=rc)) return
        end if

        commsend = merge (1, 0, localrecflag)
        call ESMF_VMAllReduce (vm=vm,  &
            sendData=commsend, recvData=commrecv, reduceflag=ESMF_REDUCE_SUM,  &
            rc=localrc)
        if (ESMF_LogFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return
        localrecflag = commrecv /= 0
      end if
    end if

    ESMF_StateIsReconcileNeeded = localrecflag
    if (present (rc)) rc = ESMF_SUCCESS

  contains

    recursive function is_rec_needed_worker (sp1) result (is_rec_needed)
      type(ESMF_StateClass), intent(in) :: sp1
      logical :: is_rec_needed

      type(ESMF_StateItem) , pointer :: nextitem1
      integer :: i1

      type(ESMF_StateItemWrap), pointer :: siwrap(:)
      integer :: ptrcnt

      integer :: localrc1
      integer :: memstat1

    ! Default return this levels flag

      is_rec_needed = sp1%reconcileneededflag
      if (is_rec_needed) return

    ! Then search nested States

      siwrap => null ()
      call ESMF_ContainerGet (sp1%stateContainer,  &
          itemCount=ptrcnt, itemList=siwrap, rc=localrc1)
      if (ESMF_LogFoundError(localrc1, ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) return

      do, i1 = 1, ptrcnt
        nextitem1 => siwrap(i1)%si
        if (nextitem1%otype == ESMF_STATEITEM_STATE) then
          is_rec_needed =  &
              is_rec_needed_worker (nextitem1%datap%spp)
          if (is_rec_needed) then
            deallocate (siwrap, stat=memstat1)
            if (ESMF_LogFoundDeallocError(memstat1, ESMF_ERR_PASSTHRU, &
                ESMF_CONTEXT, rcToReturn=rc)) return
            return
          end if
        end if
      end do

      if (associated (siwrap))  &
          deallocate (siwrap, stat=memstat1)
      if (ESMF_LogFoundDeallocError(memstat1, ESMF_ERR_PASSTHRU, &
          ESMF_CONTEXT, rcToReturn=rc)) return

    end function is_rec_needed_worker

  end function ESMF_StateIsReconcileNeeded


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StatePrint"
!BOP
! !IROUTINE: ESMF_StatePrint - Print State information
!
! !INTERFACE:
      subroutine ESMF_StatePrint(state, options, nestedFlag, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(in) :: state
      character(len=*), intent(in),  optional :: options
      logical,          intent(in),  optional :: nestedFlag
      integer,          intent(out), optional :: rc 
!
! !DESCRIPTION:
!     Prints information about the {\tt state} to {\tt stdout}.
!
!     The arguments are:
!     \begin{description}
!     \item[state]
!       The {\tt ESMF\_State} to print.
!     \item[{[options]}]
!       Print options:
!         " ", or "brief" - print names and types of the objects within the state (default),
!         "long" - print additional information, such as proxy flags
!     \item[{[nestedFlag]}]
!       When set to {\tt .false.}, prints information about the current
!       State level only (default),
!       When set to {\tt .true.}, additionally prints information from
!       nested States
!     \item[{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!      \end{description}
!

!EOP

       integer :: localrc
       character (len=8) :: localopts
       logical :: localnestedflag            ! Print nested states flag
       logical :: longflag                   ! Extended output
       logical :: debugflag                  ! Debug level output
       type(ESMF_VM) :: localvm
       integer :: mypet
       character(8) :: mypet_string
       
       ! Initialize return code; assume failure until success is certain
       if (present(rc)) rc = ESMF_RC_NOT_IMPL
       localrc = ESMF_RC_NOT_IMPL

       ! check input variables
       ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

       ! Validate options arg

       localnestedflag = .false.
       if (present (nestedFlag)) then
         localnestedflag = nestedFlag
       end if
       
       localopts = "brief"
       if (present (options)) then
         if (options /= " ")  &
           localopts = adjustl (options)
       end if

       debugflag = .false.
       longflag  = .false.
       localopts = ESMF_UtilStringLowerCase (localopts)
       select case (localopts)
       case ("brief")
       case ("debug")
	 debugflag = .true.
	 longflag  = .true.
       case ("long")
         longflag  = .true.
       case default
	 write (ESMF_UtilIOStderr,*) "ESMF_StatePrint: Illegal options arg: ", &
	     trim (localopts)
	 if (present (rc)) rc = ESMF_RC_ARG_BAD
	 return 
       end select

       if (.not.associated(state%statep)) then 
	 write (ESMF_UtilIOStdout,*) "Uninitialized or already destroyed State"
	 if (present (rc)) rc = ESMF_SUCCESS
	 return
       end if
       if (state%statep%st .eq. ESMF_STATEINTENT_INVALID) then
	 write (ESMF_UtilIOStdout,*) "Uninitialized or already destroyed State"
	 if (present (rc)) rc = ESMF_SUCCESS
	 return
       end if

       call ESMF_VMGetCurrent(vm=localvm, rc=localrc)
       if (ESMF_LogFoundError(localrc, &
           ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc)) return

       call ESMF_VMGet (localvm, localPet=mypet, rc=localrc)
       if (ESMF_LogFoundError(localrc, &
           ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc)) return

       write (mypet_string,'(i8)') mypet
       mypet_string = adjustl (mypet_string)
       write (ESMF_UtilIOStdout,*)  &
           "StatePrint (pet ", trim (mypet_string), "):"

       call statePrintWorker (state%statep, level=0, rc1=rc)

   contains

     recursive subroutine statePrintWorker (sp1, level, rc1)
       type(ESMF_StateClass), pointer :: sp1
       integer, intent(in) :: level
       integer, intent(out), optional :: rc1

       type(ESMF_StateItemWrap), pointer :: siwrap(:)
       integer :: ptrcnt
       type(ESMF_StateItem) , pointer :: sip

       character(len=2*level+1) :: nestr
       character(len=ESMF_MAXSTR) :: name
       character(len=ESMF_MAXSTR) :: msgbuf
       character(len=ESMF_MAXSTR*2) :: outbuf

       integer :: i1
       integer :: localrc1
       integer :: memstat1

       if (present (rc1)) rc1 = ESMF_FAILURE

       nestr = repeat("->", level)

       call ESMF_GetName (sp1%base, name=name, rc=localrc1)
       if (ESMF_LogFoundError(localrc1, &
           ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc1)) return
       write (ESMF_UtilIOStdout,*) nestr, "State name: ", trim(name)

       select case (sp1%st%state)
       case (ESMF_STATEINTENT_IMPORT%state)
         msgbuf = "Import State"
       case (ESMF_STATEINTENT_EXPORT%state)
         msgbuf = "Export State"
       case (ESMF_STATEINTENT_UNSPECIFIED%state)
         msgbuf = "Unspecified intent direction"
       case (ESMF_STATEINTENT_INVALID%state)
         msgbuf = "Uninitialized or already destroyed State"
         if (present (rc1)) rc1 = ESMF_SUCCESS
         return
       case default
         msgbuf = "error: unknown state"
         if (present (rc1)) rc1 = ESMF_SUCCESS
         return
       end select

       siwrap => null ()
       call ESMF_ContainerGet (sp1%stateContainer,  &
           itemList=siwrap, rc=localrc1)
       if (ESMF_LogFoundError(localrc1, ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc1)) return
       if (associated (siwrap))  &
           deallocate (siwrap, stat=memstat1)

       siwrap => null ()
       call ESMF_ContainerGet (sp1%stateContainer,  &
           itemList=siwrap, rc=localrc1)
       if (ESMF_LogFoundError(localrc1, ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc1)) return
       ptrcnt = size (siwrap)

       write (ESMF_UtilIOStdout,'(1x,4a,i0)') nestr,  &
           "   status: ", trim(msgbuf),  &
           ", object count: ", ptrcnt
       write (ESMF_UtilIOStdout,'(1x,2a,L1)') nestr,  &
           "   reconcile needed: ", sp1%reconcileneededflag

       ! Prints Attributes associated with the State 
       call ESMF_UtilIOUnitFlush (unit=ESMF_UtilIOstdout, rc=localrc1)
       if (ESMF_LogFoundError(localrc1, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc1)) return
       call c_ESMC_BasePrint(sp1%base, level, "brief", localrc1)
       if (ESMF_LogFoundError(localrc1, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc1)) return

       if (debugflag) then
	 write (ESMF_UtilIOStdout,*) 'ContainerPrint:'
	 call ESMF_ContainerPrint (sp1%stateContainer, rc=localrc1)
	 if (ESMF_LogFoundError(localrc1, &
              ESMF_ERR_PASSTHRU, &
              ESMF_CONTEXT, rcToReturn=rc1)) return
       end if

       do, i1 = 1, ptrcnt
         sip => siwrap(i1)%si
         write (outbuf,'(1x,2a,i0,a)') nestr, " object: ", i1, ", "
         call ESMF_StateItemPrint (sip,  &
             header=trim (outbuf),  &
             prefixstr=nestr,  &
             longflag=longflag, debugflag=debugflag)

         if (localnestedflag .and. sip%otype%ot == ESMF_STATEITEM_STATE%ot) then
           call statePrintWorker (sip%datap%spp, level=level+1, rc1=localrc1)
	   if (ESMF_LogFoundError(localrc1, &
               ESMF_ERR_PASSTHRU, &
               ESMF_CONTEXT, rcToReturn=rc1)) then
             if (associated (siwrap)) deallocate (siwrap, stat=memstat1)
             return
           end if
         end if
       end do

       if (associated (siwrap))  &
           deallocate (siwrap, stat=memstat1)
       if (ESMF_LogFoundDeallocError(memstat1, ESMF_ERR_PASSTHRU, &
           ESMF_CONTEXT, rcToReturn=rc1)) return

       if (present (rc1)) rc1 = ESMF_SUCCESS

     end subroutine statePrintWorker

   end subroutine ESMF_StatePrint

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateRead"
!BOP
! !IROUTINE: ESMF_StateRead -- Read data items from a file into a State
!
! !INTERFACE:
      subroutine ESMF_StateRead(state, fileName, rc)
!
! !ARGUMENTS:
      type(ESMF_State),  intent(inout)         :: state 
      character (len=*), intent(in)            :: fileName
      integer,           intent(out), optional :: rc 
!
! !DESCRIPTION:
!     Currently limited to read in all Arrays from a netCDF file and add them
!     to a State object.  Future releases will enable more items of a State
!     to be read from a file of various formats.
!
!     Only PET 0 reads the file; the States in other PETs remain empty.
!     Currently, the data is not decomposed or distributed; each PET
!     has only 1 DE and only PET 0 contains data after reading the file.
!     Future versions of ESMF will support data decomposition and distribution
!     upon reading a file.  See Section~\ref{example:StateRdWr} for
!     an example.
!
!     Note that the third party NetCDF library must be installed.  For more
!     details, see the "ESMF Users Guide",
!     "Building and Installing the ESMF, Third Party Libraries, NetCDF" and
!     the website http://www.unidata.ucar.edu/software/netcdf.
!
!     The arguments are:
!     \begin{description}
!     \item[state]
!       The {\tt ESMF\_State} to add items read from file.  Currently only
!       Arrays are supported.
!     \item[fileName]
!       File to be read.
!     \item[{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!       Equals {\tt ESMF\_RC\_LIB\_NOT\_PRESENT} if the NetCDF library is
!       not present.
!     \end{description}
!
!EOP
!       TODO: use item flag ESMF_STATEITEM_ARRAY<BUNDLE>

        integer :: localrc

        ! Initialize return code; assume failure until success is certain
        if (present(rc)) rc = ESMF_RC_NOT_IMPL
        localrc = ESMF_RC_NOT_IMPL

        ! check input variables
        ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

        if (fileName == ' ') then
          if (ESMF_LogFoundError (ESMF_RC_ARG_VALUE, msg='File name required',  &
              ESMF_CONTEXT, rcToReturn=rc)) return
        end if

        ! invoke C to C++ entry point 
        call c_ESMC_StateRead(state, state%statep%base, trim (fileName), localrc)
        if (ESMF_LogFoundError(localrc, ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rcToReturn=rc)) return

        if (present(rc)) rc = ESMF_SUCCESS
        end subroutine ESMF_StateRead


!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateReadRestart"
!BOPI
! !IROUTINE: ESMF_StateReadRestart -- ReadRestart the internal data from a State
!
! !INTERFACE:
      function ESMF_StateReadRestart(name, rc)
!
! !RETURN VALUE:
      type(ESMF_State) :: ESMF_StateReadRestart
!
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name              
      integer,  intent(out), optional :: rc               
!
! !DESCRIPTION:
!      Used to reinitialize all data associated with an
!      {\tt ESMF\_State} from the last call to WriteRestart.
!
!     The arguments are:
!     \begin{description}
!     \item[name]
!       Name of {\tt ESMF\_State} to reinitialize.
!     \item[{[rc]}]
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

!
! TODO: code goes here
!
        type (ESMF_State) :: a 

!       this is just to shut the compiler up
        type (ESMF_StateClass), target :: b 
        a%statep => b
        nullify(a%statep)

        ESMF_StateReadRestart = a 
        if (present(rc)) rc = ESMF_RC_NOT_IMPL
 
        end function ESMF_StateReadRestart

end module ESMF_StateAPIMod
